// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module func_table
//
// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
//
// Please do not modify directly;
// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
// VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
//
// python3 $VULKAN_REGISTRY_SCRIPTS_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o
// $CEREAL_OUTPUT_DIR
//

#include <log/log.h>

#include <cstring>

#include "../OpenglSystemCommon/HostConnection.h"
#include "ResourceTracker.h"
#include "VkEncoder.h"
#include "gfxstream_vk_entrypoints.h"
#include "gfxstream_vk_private.h"
#include "goldfish_vk_private_defs.h"

// Stuff we are not going to use but if included,
// will cause compile errors. These are Android Vulkan
// required extensions, but the approach will be to
// implement them completely on the guest side.
#undef VK_KHR_android_surface
#if defined(LINUX_GUEST_BUILD) || defined(__Fuchsia__)
#undef VK_ANDROID_native_buffer
#endif
#ifdef VK_VERSION_1_0
void gfxstream_vk_GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice,
                                            VkPhysicalDeviceFeatures* pFeatures) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceFeatures(gfxstream_physicalDevice->internal_object, pFeatures,
                                           true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice,
                                                    VkFormat format,
                                                    VkFormatProperties* pFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceFormatProperties(gfxstream_physicalDevice->internal_object,
                                                   format, pFormatProperties, true /* do lock */);
    }
}
VkResult gfxstream_vk_GetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling,
    VkImageUsageFlags usage, VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties");
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetPhysicalDeviceImageFormatProperties_VkResult_return =
            vkEnc->vkGetPhysicalDeviceImageFormatProperties(
                gfxstream_physicalDevice->internal_object, format, type, tiling, usage, flags,
                pImageFormatProperties, true /* do lock */);
    }
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}
void gfxstream_vk_GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceProperties(gfxstream_physicalDevice->internal_object, pProperties,
                                             true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceQueueFamilyProperties(gfxstream_physicalDevice->internal_object,
                                                        pQueueFamilyPropertyCount,
                                                        pQueueFamilyProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceMemoryProperties(gfxstream_physicalDevice->internal_object,
                                                   pMemoryProperties, true /* do lock */);
    }
}
VkResult gfxstream_vk_EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice,
                                                     uint32_t* pPropertyCount,
                                                     VkLayerProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkEnumerateDeviceLayerProperties");
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnumerateDeviceLayerProperties_VkResult_return = vkEnc->vkEnumerateDeviceLayerProperties(
            gfxstream_physicalDevice->internal_object, pPropertyCount, pProperties,
            true /* do lock */);
    }
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}
VkResult gfxstream_vk_QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                  VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmit");
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSubmitInfo> internal_pSubmits(submitCount);
        std::vector<std::vector<VkSemaphore>> internal_VkSubmitInfo_pWaitSemaphores;
        std::vector<std::vector<VkCommandBuffer>> internal_VkSubmitInfo_pCommandBuffers;
        std::vector<std::vector<VkSemaphore>> internal_VkSubmitInfo_pSignalSemaphores;
        for (uint32_t i = 0; i < submitCount; ++i) {
            internal_pSubmits[i] = pSubmits[i];
            /* VkSubmitInfo::pWaitSemaphores */
            internal_VkSubmitInfo_pWaitSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkSubmitInfo_pWaitSemaphores[i] = transformVkSemaphoreList(
                internal_pSubmits[i].pWaitSemaphores, internal_pSubmits[i].waitSemaphoreCount);
            internal_pSubmits[i].pWaitSemaphores = internal_VkSubmitInfo_pWaitSemaphores[i].data();
            internal_pSubmits[i].waitSemaphoreCount =
                internal_VkSubmitInfo_pWaitSemaphores[i].size();
            /* VkSubmitInfo::pCommandBuffers */
            internal_VkSubmitInfo_pCommandBuffers.push_back(std::vector<VkCommandBuffer>());
            internal_VkSubmitInfo_pCommandBuffers[i].reserve(
                internal_pSubmits[i].commandBufferCount);
            memset(&internal_VkSubmitInfo_pCommandBuffers[i][0], 0,
                   sizeof(VkCommandBuffer) * internal_pSubmits[i].commandBufferCount);
            for (uint32_t j = 0; j < internal_pSubmits[i].commandBufferCount; ++j) {
                VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_pCommandBuffers,
                               internal_pSubmits[i].pCommandBuffers[j]);
                internal_VkSubmitInfo_pCommandBuffers[i][j] =
                    gfxstream_pCommandBuffers->internal_object;
            }
            internal_pSubmits[i].pCommandBuffers = internal_VkSubmitInfo_pCommandBuffers[i].data();
            /* VkSubmitInfo::pSignalSemaphores */
            internal_VkSubmitInfo_pSignalSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkSubmitInfo_pSignalSemaphores[i] = transformVkSemaphoreList(
                internal_pSubmits[i].pSignalSemaphores, internal_pSubmits[i].signalSemaphoreCount);
            internal_pSubmits[i].pSignalSemaphores =
                internal_VkSubmitInfo_pSignalSemaphores[i].data();
            internal_pSubmits[i].signalSemaphoreCount =
                internal_VkSubmitInfo_pSignalSemaphores[i].size();
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkQueueSubmit_VkResult_return = resources->on_vkQueueSubmit(
            vkEnc, VK_SUCCESS, gfxstream_queue->internal_object, submitCount,
            internal_pSubmits.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE);
    }
    return vkQueueSubmit_VkResult_return;
}
VkResult gfxstream_vk_QueueWaitIdle(VkQueue queue) {
    AEMU_SCOPED_TRACE("vkQueueWaitIdle");
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkQueueWaitIdle_VkResult_return =
            resources->on_vkQueueWaitIdle(vkEnc, VK_SUCCESS, gfxstream_queue->internal_object);
    }
    return vkQueueWaitIdle_VkResult_return;
}
VkResult gfxstream_vk_DeviceWaitIdle(VkDevice device) {
    AEMU_SCOPED_TRACE("vkDeviceWaitIdle");
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkDeviceWaitIdle_VkResult_return =
            vkEnc->vkDeviceWaitIdle(gfxstream_device->internal_object, true /* do lock */);
    }
    return vkDeviceWaitIdle_VkResult_return;
}
void gfxstream_vk_FreeMemory(VkDevice device, VkDeviceMemory memory,
                             const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkFreeMemory");
    if (VK_NULL_HANDLE == memory) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkFreeMemory(
            vkEnc, gfxstream_device->internal_object,
            gfxstream_memory ? gfxstream_memory->internal_object : VK_NULL_HANDLE, pAllocator);
    }
    vk_device_memory_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_memory->vk);
}
VkResult gfxstream_vk_MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset,
                                VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
    AEMU_SCOPED_TRACE("vkMapMemory");
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkMapMemory_VkResult_return =
            vkEnc->vkMapMemory(gfxstream_device->internal_object, gfxstream_memory->internal_object,
                               offset, size, flags, ppData, true /* do lock */);
    }
    return vkMapMemory_VkResult_return;
}
void gfxstream_vk_UnmapMemory(VkDevice device, VkDeviceMemory memory) {
    AEMU_SCOPED_TRACE("vkUnmapMemory");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkUnmapMemory(gfxstream_device->internal_object, gfxstream_memory->internal_object,
                             true /* do lock */);
    }
}
VkResult gfxstream_vk_FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                              const VkMappedMemoryRange* pMemoryRanges) {
    AEMU_SCOPED_TRACE("vkFlushMappedMemoryRanges");
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkMappedMemoryRange> internal_pMemoryRanges(memoryRangeCount);
        for (uint32_t i = 0; i < memoryRangeCount; ++i) {
            internal_pMemoryRanges[i] = pMemoryRanges[i];
            /* VkMappedMemoryRange::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                           internal_pMemoryRanges[i].memory);
            internal_pMemoryRanges[i].memory = gfxstream_memory->internal_object;
        }
        vkFlushMappedMemoryRanges_VkResult_return =
            vkEnc->vkFlushMappedMemoryRanges(gfxstream_device->internal_object, memoryRangeCount,
                                             internal_pMemoryRanges.data(), true /* do lock */);
    }
    return vkFlushMappedMemoryRanges_VkResult_return;
}
VkResult gfxstream_vk_InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                   const VkMappedMemoryRange* pMemoryRanges) {
    AEMU_SCOPED_TRACE("vkInvalidateMappedMemoryRanges");
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkMappedMemoryRange> internal_pMemoryRanges(memoryRangeCount);
        for (uint32_t i = 0; i < memoryRangeCount; ++i) {
            internal_pMemoryRanges[i] = pMemoryRanges[i];
            /* VkMappedMemoryRange::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                           internal_pMemoryRanges[i].memory);
            internal_pMemoryRanges[i].memory = gfxstream_memory->internal_object;
        }
        vkInvalidateMappedMemoryRanges_VkResult_return = vkEnc->vkInvalidateMappedMemoryRanges(
            gfxstream_device->internal_object, memoryRangeCount, internal_pMemoryRanges.data(),
            true /* do lock */);
    }
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}
void gfxstream_vk_GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory,
                                            VkDeviceSize* pCommittedMemoryInBytes) {
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryCommitment");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceMemoryCommitment(gfxstream_device->internal_object,
                                           gfxstream_memory->internal_object,
                                           pCommittedMemoryInBytes, true /* do lock */);
    }
}
VkResult gfxstream_vk_BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
                                       VkDeviceSize memoryOffset) {
    AEMU_SCOPED_TRACE("vkBindBufferMemory");
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBindBufferMemory_VkResult_return = resources->on_vkBindBufferMemory(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, gfxstream_buffer->internal_object,
            gfxstream_memory->internal_object, memoryOffset);
    }
    return vkBindBufferMemory_VkResult_return;
}
VkResult gfxstream_vk_BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory,
                                      VkDeviceSize memoryOffset) {
    AEMU_SCOPED_TRACE("vkBindImageMemory");
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBindImageMemory_VkResult_return = resources->on_vkBindImageMemory(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, gfxstream_image->internal_object,
            gfxstream_memory->internal_object, memoryOffset);
    }
    return vkBindImageMemory_VkResult_return;
}
void gfxstream_vk_GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer,
                                              VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetBufferMemoryRequirements(vkEnc, gfxstream_device->internal_object,
                                                    gfxstream_buffer->internal_object,
                                                    pMemoryRequirements);
    }
}
void gfxstream_vk_GetImageMemoryRequirements(VkDevice device, VkImage image,
                                             VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetImageMemoryRequirements(vkEnc, gfxstream_device->internal_object,
                                                   gfxstream_image->internal_object,
                                                   pMemoryRequirements);
    }
}
void gfxstream_vk_GetImageSparseMemoryRequirements(
    VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetImageSparseMemoryRequirements(
            gfxstream_device->internal_object, gfxstream_image->internal_object,
            pSparseMemoryRequirementCount, pSparseMemoryRequirements, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
    VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties(
            gfxstream_physicalDevice->internal_object, format, type, samples, usage, tiling,
            pPropertyCount, pProperties, true /* do lock */);
    }
}
VkResult gfxstream_vk_QueueBindSparse(VkQueue queue, uint32_t bindInfoCount,
                                      const VkBindSparseInfo* pBindInfo, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueBindSparse");
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkBindSparseInfo> internal_pBindInfo(bindInfoCount);
        std::vector<std::vector<VkSemaphore>> internal_VkBindSparseInfo_pWaitSemaphores;
        std::vector<std::vector<VkSparseBufferMemoryBindInfo>>
            internal_VkBindSparseInfo_pBufferBinds;
        std::vector<std::vector<VkSparseMemoryBind>> internal_VkSparseBufferMemoryBindInfo_pBinds;
        std::vector<std::vector<VkSparseImageOpaqueMemoryBindInfo>>
            internal_VkBindSparseInfo_pImageOpaqueBinds;
        std::vector<std::vector<VkSparseMemoryBind>>
            internal_VkSparseImageOpaqueMemoryBindInfo_pBinds;
        std::vector<std::vector<VkSparseImageMemoryBindInfo>> internal_VkBindSparseInfo_pImageBinds;
        std::vector<std::vector<VkSparseImageMemoryBind>>
            internal_VkSparseImageMemoryBindInfo_pBinds;
        std::vector<std::vector<VkSemaphore>> internal_VkBindSparseInfo_pSignalSemaphores;
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            internal_pBindInfo[i] = pBindInfo[i];
            /* VkBindSparseInfo::pWaitSemaphores */
            internal_VkBindSparseInfo_pWaitSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkBindSparseInfo_pWaitSemaphores[i] = transformVkSemaphoreList(
                internal_pBindInfo[i].pWaitSemaphores, internal_pBindInfo[i].waitSemaphoreCount);
            internal_pBindInfo[i].pWaitSemaphores =
                internal_VkBindSparseInfo_pWaitSemaphores[i].data();
            internal_pBindInfo[i].waitSemaphoreCount =
                internal_VkBindSparseInfo_pWaitSemaphores[i].size();
            /* VkBindSparseInfo::pBufferBinds */
            internal_VkBindSparseInfo_pBufferBinds.push_back(
                std::vector<VkSparseBufferMemoryBindInfo>());
            internal_VkBindSparseInfo_pBufferBinds[i].reserve(
                internal_pBindInfo[i].bufferBindCount);
            memset(&internal_VkBindSparseInfo_pBufferBinds[i][0], 0,
                   sizeof(VkSparseBufferMemoryBindInfo) * internal_pBindInfo[i].bufferBindCount);
            for (uint32_t j = 0; j < internal_pBindInfo[i].bufferBindCount; ++j) {
                internal_VkBindSparseInfo_pBufferBinds[i][j] =
                    internal_pBindInfo[i].pBufferBinds[j];
                /* VkSparseBufferMemoryBindInfo::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkBindSparseInfo_pBufferBinds[i][j].buffer);
                internal_VkBindSparseInfo_pBufferBinds[i][j].buffer =
                    gfxstream_buffer->internal_object;
                /* VkSparseBufferMemoryBindInfo::pBinds */
                internal_VkSparseBufferMemoryBindInfo_pBinds.push_back(
                    std::vector<VkSparseMemoryBind>());
                internal_VkSparseBufferMemoryBindInfo_pBinds[j].reserve(
                    internal_VkBindSparseInfo_pBufferBinds[i][j].bindCount);
                memset(&internal_VkSparseBufferMemoryBindInfo_pBinds[j][0], 0,
                       sizeof(VkSparseMemoryBind) *
                           internal_VkBindSparseInfo_pBufferBinds[i][j].bindCount);
                for (uint32_t k = 0; k < internal_VkBindSparseInfo_pBufferBinds[i][j].bindCount;
                     ++k) {
                    internal_VkSparseBufferMemoryBindInfo_pBinds[j][k] =
                        internal_VkBindSparseInfo_pBufferBinds[i][j].pBinds[k];
                    /* VkSparseMemoryBind::memory */
                    if (internal_VkSparseBufferMemoryBindInfo_pBinds[j][k].memory) {
                        VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                                       internal_VkSparseBufferMemoryBindInfo_pBinds[j][k].memory);
                        internal_VkSparseBufferMemoryBindInfo_pBinds[j][k].memory =
                            gfxstream_memory->internal_object;
                    }
                }
                internal_VkBindSparseInfo_pBufferBinds[i][j].pBinds =
                    internal_VkSparseBufferMemoryBindInfo_pBinds[j].data();
            }
            internal_pBindInfo[i].pBufferBinds = internal_VkBindSparseInfo_pBufferBinds[i].data();
            /* VkBindSparseInfo::pImageOpaqueBinds */
            internal_VkBindSparseInfo_pImageOpaqueBinds.push_back(
                std::vector<VkSparseImageOpaqueMemoryBindInfo>());
            internal_VkBindSparseInfo_pImageOpaqueBinds[i].reserve(
                internal_pBindInfo[i].imageOpaqueBindCount);
            memset(&internal_VkBindSparseInfo_pImageOpaqueBinds[i][0], 0,
                   sizeof(VkSparseImageOpaqueMemoryBindInfo) *
                       internal_pBindInfo[i].imageOpaqueBindCount);
            for (uint32_t j = 0; j < internal_pBindInfo[i].imageOpaqueBindCount; ++j) {
                internal_VkBindSparseInfo_pImageOpaqueBinds[i][j] =
                    internal_pBindInfo[i].pImageOpaqueBinds[j];
                /* VkSparseImageOpaqueMemoryBindInfo::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].image);
                internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].image =
                    gfxstream_image->internal_object;
                /* VkSparseImageOpaqueMemoryBindInfo::pBinds */
                internal_VkSparseImageOpaqueMemoryBindInfo_pBinds.push_back(
                    std::vector<VkSparseMemoryBind>());
                internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j].reserve(
                    internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].bindCount);
                memset(&internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][0], 0,
                       sizeof(VkSparseMemoryBind) *
                           internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].bindCount);
                for (uint32_t l = 0;
                     l < internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].bindCount; ++l) {
                    internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l] =
                        internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].pBinds[l];
                    /* VkSparseMemoryBind::memory */
                    if (internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l].memory) {
                        VK_FROM_HANDLE(
                            gfxstream_vk_device_memory, gfxstream_memory,
                            internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l].memory);
                        internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l].memory =
                            gfxstream_memory->internal_object;
                    }
                }
                internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].pBinds =
                    internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j].data();
            }
            internal_pBindInfo[i].pImageOpaqueBinds =
                internal_VkBindSparseInfo_pImageOpaqueBinds[i].data();
            /* VkBindSparseInfo::pImageBinds */
            internal_VkBindSparseInfo_pImageBinds.push_back(
                std::vector<VkSparseImageMemoryBindInfo>());
            internal_VkBindSparseInfo_pImageBinds[i].reserve(internal_pBindInfo[i].imageBindCount);
            memset(&internal_VkBindSparseInfo_pImageBinds[i][0], 0,
                   sizeof(VkSparseImageMemoryBindInfo) * internal_pBindInfo[i].imageBindCount);
            for (uint32_t j = 0; j < internal_pBindInfo[i].imageBindCount; ++j) {
                internal_VkBindSparseInfo_pImageBinds[i][j] = internal_pBindInfo[i].pImageBinds[j];
                /* VkSparseImageMemoryBindInfo::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkBindSparseInfo_pImageBinds[i][j].image);
                internal_VkBindSparseInfo_pImageBinds[i][j].image =
                    gfxstream_image->internal_object;
                /* VkSparseImageMemoryBindInfo::pBinds */
                internal_VkSparseImageMemoryBindInfo_pBinds.push_back(
                    std::vector<VkSparseImageMemoryBind>());
                internal_VkSparseImageMemoryBindInfo_pBinds[j].reserve(
                    internal_VkBindSparseInfo_pImageBinds[i][j].bindCount);
                memset(&internal_VkSparseImageMemoryBindInfo_pBinds[j][0], 0,
                       sizeof(VkSparseImageMemoryBind) *
                           internal_VkBindSparseInfo_pImageBinds[i][j].bindCount);
                for (uint32_t m = 0; m < internal_VkBindSparseInfo_pImageBinds[i][j].bindCount;
                     ++m) {
                    internal_VkSparseImageMemoryBindInfo_pBinds[j][m] =
                        internal_VkBindSparseInfo_pImageBinds[i][j].pBinds[m];
                    /* VkSparseImageMemoryBind::memory */
                    if (internal_VkSparseImageMemoryBindInfo_pBinds[j][m].memory) {
                        VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                                       internal_VkSparseImageMemoryBindInfo_pBinds[j][m].memory);
                        internal_VkSparseImageMemoryBindInfo_pBinds[j][m].memory =
                            gfxstream_memory->internal_object;
                    }
                }
                internal_VkBindSparseInfo_pImageBinds[i][j].pBinds =
                    internal_VkSparseImageMemoryBindInfo_pBinds[j].data();
            }
            internal_pBindInfo[i].pImageBinds = internal_VkBindSparseInfo_pImageBinds[i].data();
            /* VkBindSparseInfo::pSignalSemaphores */
            internal_VkBindSparseInfo_pSignalSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkBindSparseInfo_pSignalSemaphores[i] =
                transformVkSemaphoreList(internal_pBindInfo[i].pSignalSemaphores,
                                         internal_pBindInfo[i].signalSemaphoreCount);
            internal_pBindInfo[i].pSignalSemaphores =
                internal_VkBindSparseInfo_pSignalSemaphores[i].data();
            internal_pBindInfo[i].signalSemaphoreCount =
                internal_VkBindSparseInfo_pSignalSemaphores[i].size();
        }
        vkQueueBindSparse_VkResult_return = vkEnc->vkQueueBindSparse(
            gfxstream_queue->internal_object, bindInfoCount, internal_pBindInfo.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
            true /* do lock */);
    }
    return vkQueueBindSparse_VkResult_return;
}
VkResult gfxstream_vk_CreateFence(VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
    AEMU_SCOPED_TRACE("vkCreateFence");
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_fence* gfxstream_pFence = (gfxstream_vk_fence*)vk_object_zalloc(
        &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_fence), VK_OBJECT_TYPE_FENCE);
    vkCreateFence_VkResult_return = gfxstream_pFence ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateFence_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateFence_VkResult_return = resources->on_vkCreateFence(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pFence->internal_object);
    }
    *pFence = gfxstream_vk_fence_to_handle(gfxstream_pFence);
    return vkCreateFence_VkResult_return;
}
void gfxstream_vk_DestroyFence(VkDevice device, VkFence fence,
                               const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyFence");
    if (VK_NULL_HANDLE == fence) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyFence(gfxstream_device->internal_object,
                              gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
                              pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_fence);
}
VkResult gfxstream_vk_ResetFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences) {
    AEMU_SCOPED_TRACE("vkResetFences");
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkFence> internal_pFences(fenceCount);
        internal_pFences = transformVkFenceList(pFences, fenceCount);
        pFences = internal_pFences.data();
        fenceCount = internal_pFences.size();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkResetFences_VkResult_return =
            resources->on_vkResetFences(vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
                                        fenceCount, internal_pFences.data());
    }
    return vkResetFences_VkResult_return;
}
VkResult gfxstream_vk_GetFenceStatus(VkDevice device, VkFence fence) {
    AEMU_SCOPED_TRACE("vkGetFenceStatus");
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetFenceStatus_VkResult_return =
            vkEnc->vkGetFenceStatus(gfxstream_device->internal_object,
                                    gfxstream_fence->internal_object, true /* do lock */);
    }
    return vkGetFenceStatus_VkResult_return;
}
VkResult gfxstream_vk_WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences,
                                    VkBool32 waitAll, uint64_t timeout) {
    AEMU_SCOPED_TRACE("vkWaitForFences");
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkFence> internal_pFences(fenceCount);
        internal_pFences = transformVkFenceList(pFences, fenceCount);
        pFences = internal_pFences.data();
        fenceCount = internal_pFences.size();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkWaitForFences_VkResult_return =
            resources->on_vkWaitForFences(vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
                                          fenceCount, internal_pFences.data(), waitAll, timeout);
    }
    return vkWaitForFences_VkResult_return;
}
VkResult gfxstream_vk_CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkSemaphore* pSemaphore) {
    AEMU_SCOPED_TRACE("vkCreateSemaphore");
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_semaphore* gfxstream_pSemaphore = (gfxstream_vk_semaphore*)vk_object_zalloc(
        &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_semaphore),
        VK_OBJECT_TYPE_SEMAPHORE);
    vkCreateSemaphore_VkResult_return =
        gfxstream_pSemaphore ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateSemaphore_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateSemaphore_VkResult_return = resources->on_vkCreateSemaphore(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pSemaphore->internal_object);
    }
    *pSemaphore = gfxstream_vk_semaphore_to_handle(gfxstream_pSemaphore);
    return vkCreateSemaphore_VkResult_return;
}
void gfxstream_vk_DestroySemaphore(VkDevice device, VkSemaphore semaphore,
                                   const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySemaphore");
    if (VK_NULL_HANDLE == semaphore) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_semaphore, gfxstream_semaphore, semaphore);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroySemaphore(
            vkEnc, gfxstream_device->internal_object,
            gfxstream_semaphore ? gfxstream_semaphore->internal_object : VK_NULL_HANDLE,
            pAllocator);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_semaphore);
}
VkResult gfxstream_vk_CreateEvent(VkDevice device, const VkEventCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
    AEMU_SCOPED_TRACE("vkCreateEvent");
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_event* gfxstream_pEvent = (gfxstream_vk_event*)vk_object_zalloc(
        &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_event), VK_OBJECT_TYPE_EVENT);
    vkCreateEvent_VkResult_return = gfxstream_pEvent ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateEvent_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateEvent_VkResult_return =
            vkEnc->vkCreateEvent(gfxstream_device->internal_object, pCreateInfo, pAllocator,
                                 &gfxstream_pEvent->internal_object, true /* do lock */);
    }
    *pEvent = gfxstream_vk_event_to_handle(gfxstream_pEvent);
    return vkCreateEvent_VkResult_return;
}
void gfxstream_vk_DestroyEvent(VkDevice device, VkEvent event,
                               const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyEvent");
    if (VK_NULL_HANDLE == event) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyEvent(gfxstream_device->internal_object,
                              gfxstream_event ? gfxstream_event->internal_object : VK_NULL_HANDLE,
                              pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_event);
}
VkResult gfxstream_vk_GetEventStatus(VkDevice device, VkEvent event) {
    AEMU_SCOPED_TRACE("vkGetEventStatus");
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetEventStatus_VkResult_return =
            vkEnc->vkGetEventStatus(gfxstream_device->internal_object,
                                    gfxstream_event->internal_object, true /* do lock */);
    }
    return vkGetEventStatus_VkResult_return;
}
VkResult gfxstream_vk_SetEvent(VkDevice device, VkEvent event) {
    AEMU_SCOPED_TRACE("vkSetEvent");
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkSetEvent_VkResult_return =
            vkEnc->vkSetEvent(gfxstream_device->internal_object, gfxstream_event->internal_object,
                              true /* do lock */);
    }
    return vkSetEvent_VkResult_return;
}
VkResult gfxstream_vk_ResetEvent(VkDevice device, VkEvent event) {
    AEMU_SCOPED_TRACE("vkResetEvent");
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkResetEvent_VkResult_return =
            vkEnc->vkResetEvent(gfxstream_device->internal_object, gfxstream_event->internal_object,
                                true /* do lock */);
    }
    return vkResetEvent_VkResult_return;
}
VkResult gfxstream_vk_CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkQueryPool* pQueryPool) {
    AEMU_SCOPED_TRACE("vkCreateQueryPool");
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_query_pool* gfxstream_pQueryPool =
        (struct gfxstream_vk_query_pool*)vk_query_pool_create(
            (vk_device*)gfxstream_device, pCreateInfo, pAllocator,
            sizeof(struct gfxstream_vk_query_pool));
    vkCreateQueryPool_VkResult_return =
        gfxstream_pQueryPool ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateQueryPool_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateQueryPool_VkResult_return =
            vkEnc->vkCreateQueryPool(gfxstream_device->internal_object, pCreateInfo, pAllocator,
                                     &gfxstream_pQueryPool->internal_object, true /* do lock */);
    }
    *pQueryPool = gfxstream_vk_query_pool_to_handle(gfxstream_pQueryPool);
    return vkCreateQueryPool_VkResult_return;
}
void gfxstream_vk_DestroyQueryPool(VkDevice device, VkQueryPool queryPool,
                                   const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyQueryPool");
    if (VK_NULL_HANDLE == queryPool) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyQueryPool(
            gfxstream_device->internal_object,
            gfxstream_queryPool ? gfxstream_queryPool->internal_object : VK_NULL_HANDLE, pAllocator,
            true /* do lock */);
    }
    vk_query_pool_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_queryPool->vk);
}
VkResult gfxstream_vk_GetQueryPoolResults(VkDevice device, VkQueryPool queryPool,
                                          uint32_t firstQuery, uint32_t queryCount, size_t dataSize,
                                          void* pData, VkDeviceSize stride,
                                          VkQueryResultFlags flags) {
    AEMU_SCOPED_TRACE("vkGetQueryPoolResults");
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetQueryPoolResults_VkResult_return = vkEnc->vkGetQueryPoolResults(
            gfxstream_device->internal_object, gfxstream_queryPool->internal_object, firstQuery,
            queryCount, dataSize, pData, stride, flags, true /* do lock */);
    }
    return vkGetQueryPoolResults_VkResult_return;
}
VkResult gfxstream_vk_CreateBuffer(VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                                   const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
    AEMU_SCOPED_TRACE("vkCreateBuffer");
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_buffer* gfxstream_pBuffer = (struct gfxstream_vk_buffer*)vk_buffer_create(
        (vk_device*)gfxstream_device, pCreateInfo, pAllocator, sizeof(struct gfxstream_vk_buffer));
    vkCreateBuffer_VkResult_return = gfxstream_pBuffer ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateBuffer_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateBuffer_VkResult_return = resources->on_vkCreateBuffer(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pBuffer->internal_object);
    }
    *pBuffer = gfxstream_vk_buffer_to_handle(gfxstream_pBuffer);
    return vkCreateBuffer_VkResult_return;
}
void gfxstream_vk_DestroyBuffer(VkDevice device, VkBuffer buffer,
                                const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyBuffer");
    if (VK_NULL_HANDLE == buffer) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroyBuffer(
            vkEnc, gfxstream_device->internal_object,
            gfxstream_buffer ? gfxstream_buffer->internal_object : VK_NULL_HANDLE, pAllocator);
    }
    vk_buffer_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_buffer->vk);
}
VkResult gfxstream_vk_CreateBufferView(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkBufferView* pView) {
    AEMU_SCOPED_TRACE("vkCreateBufferView");
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_buffer_view* gfxstream_pView =
        (struct gfxstream_vk_buffer_view*)vk_buffer_view_create(
            (vk_device*)gfxstream_device, pCreateInfo, pAllocator,
            sizeof(struct gfxstream_vk_buffer_view));
    vkCreateBufferView_VkResult_return = gfxstream_pView ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateBufferView_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferViewCreateInfo> internal_pCreateInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCreateInfo[i] = pCreateInfo[i];
            /* VkBufferViewCreateInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pCreateInfo[i].buffer);
            internal_pCreateInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        vkCreateBufferView_VkResult_return = vkEnc->vkCreateBufferView(
            gfxstream_device->internal_object, internal_pCreateInfo.data(), pAllocator,
            &gfxstream_pView->internal_object, true /* do lock */);
    }
    *pView = gfxstream_vk_buffer_view_to_handle(gfxstream_pView);
    return vkCreateBufferView_VkResult_return;
}
void gfxstream_vk_DestroyBufferView(VkDevice device, VkBufferView bufferView,
                                    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyBufferView");
    if (VK_NULL_HANDLE == bufferView) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_buffer_view, gfxstream_bufferView, bufferView);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyBufferView(
            gfxstream_device->internal_object,
            gfxstream_bufferView ? gfxstream_bufferView->internal_object : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_buffer_view_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_bufferView->vk);
}
VkResult gfxstream_vk_CreateImage(VkDevice device, const VkImageCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
    AEMU_SCOPED_TRACE("vkCreateImage");
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_image* gfxstream_pImage = (struct gfxstream_vk_image*)vk_image_create(
        (vk_device*)gfxstream_device, pCreateInfo, pAllocator, sizeof(struct gfxstream_vk_image));
    vkCreateImage_VkResult_return = gfxstream_pImage ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateImage_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateImage_VkResult_return = resources->on_vkCreateImage(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pImage->internal_object);
    }
    *pImage = gfxstream_vk_image_to_handle(gfxstream_pImage);
    return vkCreateImage_VkResult_return;
}
void gfxstream_vk_DestroyImage(VkDevice device, VkImage image,
                               const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyImage");
    if (VK_NULL_HANDLE == image) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroyImage(
            vkEnc, gfxstream_device->internal_object,
            gfxstream_image ? gfxstream_image->internal_object : VK_NULL_HANDLE, pAllocator);
    }
    vk_image_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_image->vk);
}
void gfxstream_vk_GetImageSubresourceLayout(VkDevice device, VkImage image,
                                            const VkImageSubresource* pSubresource,
                                            VkSubresourceLayout* pLayout) {
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetImageSubresourceLayout(gfxstream_device->internal_object,
                                           gfxstream_image->internal_object, pSubresource, pLayout,
                                           true /* do lock */);
    }
}
VkResult gfxstream_vk_CreateImageView(VkDevice device, const VkImageViewCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator, VkImageView* pView) {
    AEMU_SCOPED_TRACE("vkCreateImageView");
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_image_view* gfxstream_pView =
        (struct gfxstream_vk_image_view*)vk_image_view_create(
            (vk_device*)gfxstream_device, false /* driver_internal */, pCreateInfo, pAllocator,
            sizeof(struct gfxstream_vk_image_view));
    vkCreateImageView_VkResult_return = gfxstream_pView ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateImageView_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImageViewCreateInfo> internal_pCreateInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCreateInfo[i] = pCreateInfo[i];
            /* VkImageViewCreateInfo::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pCreateInfo[i].image);
            internal_pCreateInfo[i].image = gfxstream_image->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateImageView_VkResult_return = resources->on_vkCreateImageView(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, internal_pCreateInfo.data(),
            pAllocator, &gfxstream_pView->internal_object);
    }
    *pView = gfxstream_vk_image_view_to_handle(gfxstream_pView);
    return vkCreateImageView_VkResult_return;
}
void gfxstream_vk_DestroyImageView(VkDevice device, VkImageView imageView,
                                   const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyImageView");
    if (VK_NULL_HANDLE == imageView) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView, imageView);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyImageView(
            gfxstream_device->internal_object,
            gfxstream_imageView ? gfxstream_imageView->internal_object : VK_NULL_HANDLE, pAllocator,
            true /* do lock */);
    }
    vk_image_view_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_imageView->vk);
}
VkResult gfxstream_vk_CreateShaderModule(VkDevice device,
                                         const VkShaderModuleCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkShaderModule* pShaderModule) {
    AEMU_SCOPED_TRACE("vkCreateShaderModule");
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_shader_module* gfxstream_pShaderModule =
        (gfxstream_vk_shader_module*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                      sizeof(gfxstream_vk_shader_module),
                                                      VK_OBJECT_TYPE_SHADER_MODULE);
    vkCreateShaderModule_VkResult_return =
        gfxstream_pShaderModule ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateShaderModule_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateShaderModule_VkResult_return = vkEnc->vkCreateShaderModule(
            gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pShaderModule->internal_object, true /* do lock */);
    }
    *pShaderModule = gfxstream_vk_shader_module_to_handle(gfxstream_pShaderModule);
    return vkCreateShaderModule_VkResult_return;
}
void gfxstream_vk_DestroyShaderModule(VkDevice device, VkShaderModule shaderModule,
                                      const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyShaderModule");
    if (VK_NULL_HANDLE == shaderModule) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_shader_module, gfxstream_shaderModule, shaderModule);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyShaderModule(
            gfxstream_device->internal_object,
            gfxstream_shaderModule ? gfxstream_shaderModule->internal_object : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_shaderModule);
}
VkResult gfxstream_vk_CreatePipelineCache(VkDevice device,
                                          const VkPipelineCacheCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkPipelineCache* pPipelineCache) {
    AEMU_SCOPED_TRACE("vkCreatePipelineCache");
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_pipeline_cache* gfxstream_pPipelineCache =
        (gfxstream_vk_pipeline_cache*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                       sizeof(gfxstream_vk_pipeline_cache),
                                                       VK_OBJECT_TYPE_PIPELINE_CACHE);
    vkCreatePipelineCache_VkResult_return =
        gfxstream_pPipelineCache ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreatePipelineCache_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreatePipelineCache_VkResult_return = vkEnc->vkCreatePipelineCache(
            gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pPipelineCache->internal_object, true /* do lock */);
    }
    *pPipelineCache = gfxstream_vk_pipeline_cache_to_handle(gfxstream_pPipelineCache);
    return vkCreatePipelineCache_VkResult_return;
}
void gfxstream_vk_DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache,
                                       const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPipelineCache");
    if (VK_NULL_HANDLE == pipelineCache) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_cache, gfxstream_pipelineCache, pipelineCache);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyPipelineCache(
            gfxstream_device->internal_object,
            gfxstream_pipelineCache ? gfxstream_pipelineCache->internal_object : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_pipelineCache);
}
VkResult gfxstream_vk_GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache,
                                           size_t* pDataSize, void* pData) {
    AEMU_SCOPED_TRACE("vkGetPipelineCacheData");
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_cache, gfxstream_pipelineCache, pipelineCache);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetPipelineCacheData_VkResult_return = vkEnc->vkGetPipelineCacheData(
            gfxstream_device->internal_object, gfxstream_pipelineCache->internal_object, pDataSize,
            pData, true /* do lock */);
    }
    return vkGetPipelineCacheData_VkResult_return;
}
VkResult gfxstream_vk_MergePipelineCaches(VkDevice device, VkPipelineCache dstCache,
                                          uint32_t srcCacheCount,
                                          const VkPipelineCache* pSrcCaches) {
    AEMU_SCOPED_TRACE("vkMergePipelineCaches");
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_cache, gfxstream_dstCache, dstCache);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkPipelineCache> internal_pSrcCaches(srcCacheCount);
        for (uint32_t i = 0; i < srcCacheCount; ++i) {
            VK_FROM_HANDLE(gfxstream_vk_pipeline_cache, gfxstream_pSrcCaches, pSrcCaches[i]);
            internal_pSrcCaches[i] = gfxstream_pSrcCaches->internal_object;
        }
        vkMergePipelineCaches_VkResult_return = vkEnc->vkMergePipelineCaches(
            gfxstream_device->internal_object, gfxstream_dstCache->internal_object, srcCacheCount,
            internal_pSrcCaches.data(), true /* do lock */);
    }
    return vkMergePipelineCaches_VkResult_return;
}
VkResult gfxstream_vk_CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache,
                                              uint32_t createInfoCount,
                                              const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                              const VkAllocationCallbacks* pAllocator,
                                              VkPipeline* pPipelines) {
    AEMU_SCOPED_TRACE("vkCreateGraphicsPipelines");
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_cache, gfxstream_pipelineCache, pipelineCache);
    struct gfxstream_vk_pipeline* gfxstream_pPipelines = (gfxstream_vk_pipeline*)vk_object_zalloc(
        &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_pipeline), VK_OBJECT_TYPE_PIPELINE);
    vkCreateGraphicsPipelines_VkResult_return =
        gfxstream_pPipelines ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateGraphicsPipelines_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkGraphicsPipelineCreateInfo> internal_pCreateInfos(createInfoCount);
        std::vector<std::vector<VkPipelineShaderStageCreateInfo>>
            internal_VkGraphicsPipelineCreateInfo_pStages;
        for (uint32_t i = 0; i < createInfoCount; ++i) {
            internal_pCreateInfos[i] = pCreateInfos[i];
            /* VkGraphicsPipelineCreateInfo::pStages */
            internal_VkGraphicsPipelineCreateInfo_pStages.push_back(
                std::vector<VkPipelineShaderStageCreateInfo>());
            internal_VkGraphicsPipelineCreateInfo_pStages[i].reserve(
                internal_pCreateInfos[i].stageCount);
            memset(&internal_VkGraphicsPipelineCreateInfo_pStages[i][0], 0,
                   sizeof(VkPipelineShaderStageCreateInfo) * internal_pCreateInfos[i].stageCount);
            for (uint32_t j = 0; j < internal_pCreateInfos[i].stageCount; ++j) {
                if (internal_pCreateInfos[i].pStages) {
                    internal_VkGraphicsPipelineCreateInfo_pStages[i][j] =
                        internal_pCreateInfos[i].pStages[j];
                    /* VkPipelineShaderStageCreateInfo::module */
                    if (internal_VkGraphicsPipelineCreateInfo_pStages[i][j].module) {
                        VK_FROM_HANDLE(gfxstream_vk_shader_module, gfxstream_module,
                                       internal_VkGraphicsPipelineCreateInfo_pStages[i][j].module);
                        internal_VkGraphicsPipelineCreateInfo_pStages[i][j].module =
                            gfxstream_module->internal_object;
                    }
                }
            }
            internal_pCreateInfos[i].pStages =
                internal_VkGraphicsPipelineCreateInfo_pStages[i].data();
            /* VkGraphicsPipelineCreateInfo::layout */
            if (internal_pCreateInfos[i].layout) {
                VK_FROM_HANDLE(gfxstream_vk_pipeline_layout, gfxstream_layout,
                               internal_pCreateInfos[i].layout);
                internal_pCreateInfos[i].layout = gfxstream_layout->internal_object;
            }
            /* VkGraphicsPipelineCreateInfo::renderPass */
            if (internal_pCreateInfos[i].renderPass) {
                VK_FROM_HANDLE(gfxstream_vk_render_pass, gfxstream_renderPass,
                               internal_pCreateInfos[i].renderPass);
                internal_pCreateInfos[i].renderPass = gfxstream_renderPass->internal_object;
            }
            /* VkGraphicsPipelineCreateInfo::basePipelineHandle */
            if (internal_pCreateInfos[i].basePipelineHandle) {
                VK_FROM_HANDLE(gfxstream_vk_pipeline, gfxstream_basePipelineHandle,
                               internal_pCreateInfos[i].basePipelineHandle);
                internal_pCreateInfos[i].basePipelineHandle =
                    gfxstream_basePipelineHandle->internal_object;
            }
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateGraphicsPipelines_VkResult_return = resources->on_vkCreateGraphicsPipelines(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
            gfxstream_pipelineCache ? gfxstream_pipelineCache->internal_object : VK_NULL_HANDLE,
            createInfoCount, internal_pCreateInfos.data(), pAllocator,
            &gfxstream_pPipelines->internal_object);
    }
    *pPipelines = gfxstream_vk_pipeline_to_handle(gfxstream_pPipelines);
    return vkCreateGraphicsPipelines_VkResult_return;
}
void gfxstream_vk_DestroyPipeline(VkDevice device, VkPipeline pipeline,
                                  const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPipeline");
    if (VK_NULL_HANDLE == pipeline) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_pipeline, gfxstream_pipeline, pipeline);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyPipeline(
            gfxstream_device->internal_object,
            gfxstream_pipeline ? gfxstream_pipeline->internal_object : VK_NULL_HANDLE, pAllocator,
            true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_pipeline);
}
VkResult gfxstream_vk_CreatePipelineLayout(VkDevice device,
                                           const VkPipelineLayoutCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkPipelineLayout* pPipelineLayout) {
    AEMU_SCOPED_TRACE("vkCreatePipelineLayout");
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_pipeline_layout* gfxstream_pPipelineLayout =
        (gfxstream_vk_pipeline_layout*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                        sizeof(gfxstream_vk_pipeline_layout),
                                                        VK_OBJECT_TYPE_PIPELINE_LAYOUT);
    vkCreatePipelineLayout_VkResult_return =
        gfxstream_pPipelineLayout ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreatePipelineLayout_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkPipelineLayoutCreateInfo> internal_pCreateInfo(1);
        std::vector<std::vector<VkDescriptorSetLayout>>
            internal_VkPipelineLayoutCreateInfo_pSetLayouts;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCreateInfo[i] = pCreateInfo[i];
            /* VkPipelineLayoutCreateInfo::pSetLayouts */
            internal_VkPipelineLayoutCreateInfo_pSetLayouts.push_back(
                std::vector<VkDescriptorSetLayout>());
            internal_VkPipelineLayoutCreateInfo_pSetLayouts[i].reserve(
                internal_pCreateInfo[i].setLayoutCount);
            memset(&internal_VkPipelineLayoutCreateInfo_pSetLayouts[i][0], 0,
                   sizeof(VkDescriptorSetLayout) * internal_pCreateInfo[i].setLayoutCount);
            for (uint32_t j = 0; j < internal_pCreateInfo[i].setLayoutCount; ++j) {
                if (internal_pCreateInfo[i].pSetLayouts) {
                    VK_FROM_HANDLE(gfxstream_vk_descriptor_set_layout, gfxstream_pSetLayouts,
                                   internal_pCreateInfo[i].pSetLayouts[j]);
                    internal_VkPipelineLayoutCreateInfo_pSetLayouts[i][j] =
                        gfxstream_pSetLayouts->internal_object;
                }
            }
            internal_pCreateInfo[i].pSetLayouts =
                internal_VkPipelineLayoutCreateInfo_pSetLayouts[i].data();
        }
        vkCreatePipelineLayout_VkResult_return = vkEnc->vkCreatePipelineLayout(
            gfxstream_device->internal_object, internal_pCreateInfo.data(), pAllocator,
            &gfxstream_pPipelineLayout->internal_object, true /* do lock */);
    }
    *pPipelineLayout = gfxstream_vk_pipeline_layout_to_handle(gfxstream_pPipelineLayout);
    return vkCreatePipelineLayout_VkResult_return;
}
void gfxstream_vk_DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout,
                                        const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPipelineLayout");
    if (VK_NULL_HANDLE == pipelineLayout) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_layout, gfxstream_pipelineLayout, pipelineLayout);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyPipelineLayout(
            gfxstream_device->internal_object,
            gfxstream_pipelineLayout ? gfxstream_pipelineLayout->internal_object : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_pipelineLayout);
}
VkResult gfxstream_vk_CreateSampler(VkDevice device, const VkSamplerCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator, VkSampler* pSampler) {
    AEMU_SCOPED_TRACE("vkCreateSampler");
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateSampler_VkResult_return =
            resources->on_vkCreateSampler(vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
                                          pCreateInfo, pAllocator, pSampler);
    }
    return vkCreateSampler_VkResult_return;
}
void gfxstream_vk_DestroySampler(VkDevice device, VkSampler sampler,
                                 const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySampler");
    if (VK_NULL_HANDLE == sampler) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroySampler(gfxstream_device->internal_object, sampler, pAllocator,
                                true /* do lock */);
    }
}
VkResult gfxstream_vk_CreateDescriptorSetLayout(VkDevice device,
                                                const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                const VkAllocationCallbacks* pAllocator,
                                                VkDescriptorSetLayout* pSetLayout) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorSetLayout");
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_descriptor_set_layout* gfxstream_pSetLayout =
        (gfxstream_vk_descriptor_set_layout*)vk_object_zalloc(
            &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_descriptor_set_layout),
            VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT);
    vkCreateDescriptorSetLayout_VkResult_return =
        gfxstream_pSetLayout ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateDescriptorSetLayout_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateDescriptorSetLayout_VkResult_return = resources->on_vkCreateDescriptorSetLayout(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pSetLayout->internal_object);
    }
    *pSetLayout = gfxstream_vk_descriptor_set_layout_to_handle(gfxstream_pSetLayout);
    return vkCreateDescriptorSetLayout_VkResult_return;
}
void gfxstream_vk_DestroyDescriptorSetLayout(VkDevice device,
                                             VkDescriptorSetLayout descriptorSetLayout,
                                             const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorSetLayout");
    if (VK_NULL_HANDLE == descriptorSetLayout) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_set_layout, gfxstream_descriptorSetLayout,
                   descriptorSetLayout);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroyDescriptorSetLayout(
            vkEnc, gfxstream_device->internal_object,
            gfxstream_descriptorSetLayout ? gfxstream_descriptorSetLayout->internal_object
                                          : VK_NULL_HANDLE,
            pAllocator);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_descriptorSetLayout);
}
VkResult gfxstream_vk_CreateDescriptorPool(VkDevice device,
                                           const VkDescriptorPoolCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkDescriptorPool* pDescriptorPool) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorPool");
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_descriptor_pool* gfxstream_pDescriptorPool =
        (gfxstream_vk_descriptor_pool*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                        sizeof(gfxstream_vk_descriptor_pool),
                                                        VK_OBJECT_TYPE_DESCRIPTOR_POOL);
    vkCreateDescriptorPool_VkResult_return =
        gfxstream_pDescriptorPool ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateDescriptorPool_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateDescriptorPool_VkResult_return = resources->on_vkCreateDescriptorPool(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pDescriptorPool->internal_object);
    }
    *pDescriptorPool = gfxstream_vk_descriptor_pool_to_handle(gfxstream_pDescriptorPool);
    return vkCreateDescriptorPool_VkResult_return;
}
void gfxstream_vk_DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                        const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorPool");
    if (VK_NULL_HANDLE == descriptorPool) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_pool, gfxstream_descriptorPool, descriptorPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroyDescriptorPool(
            vkEnc, gfxstream_device->internal_object,
            gfxstream_descriptorPool ? gfxstream_descriptorPool->internal_object : VK_NULL_HANDLE,
            pAllocator);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_descriptorPool);
}
VkResult gfxstream_vk_ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                          VkDescriptorPoolResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetDescriptorPool");
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_pool, gfxstream_descriptorPool, descriptorPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkResetDescriptorPool_VkResult_return = resources->on_vkResetDescriptorPool(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
            gfxstream_descriptorPool->internal_object, flags);
    }
    return vkResetDescriptorPool_VkResult_return;
}
VkResult gfxstream_vk_AllocateDescriptorSets(VkDevice device,
                                             const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                             VkDescriptorSet* pDescriptorSets) {
    AEMU_SCOPED_TRACE("vkAllocateDescriptorSets");
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDescriptorSetAllocateInfo> internal_pAllocateInfo(1);
        std::vector<std::vector<VkDescriptorSetLayout>>
            internal_VkDescriptorSetAllocateInfo_pSetLayouts;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pAllocateInfo[i] = pAllocateInfo[i];
            /* VkDescriptorSetAllocateInfo::descriptorPool */
            VK_FROM_HANDLE(gfxstream_vk_descriptor_pool, gfxstream_descriptorPool,
                           internal_pAllocateInfo[i].descriptorPool);
            internal_pAllocateInfo[i].descriptorPool = gfxstream_descriptorPool->internal_object;
            /* VkDescriptorSetAllocateInfo::pSetLayouts */
            internal_VkDescriptorSetAllocateInfo_pSetLayouts.push_back(
                std::vector<VkDescriptorSetLayout>());
            internal_VkDescriptorSetAllocateInfo_pSetLayouts[i].reserve(
                internal_pAllocateInfo[i].descriptorSetCount);
            memset(&internal_VkDescriptorSetAllocateInfo_pSetLayouts[i][0], 0,
                   sizeof(VkDescriptorSetLayout) * internal_pAllocateInfo[i].descriptorSetCount);
            for (uint32_t j = 0; j < internal_pAllocateInfo[i].descriptorSetCount; ++j) {
                VK_FROM_HANDLE(gfxstream_vk_descriptor_set_layout, gfxstream_pSetLayouts,
                               internal_pAllocateInfo[i].pSetLayouts[j]);
                internal_VkDescriptorSetAllocateInfo_pSetLayouts[i][j] =
                    gfxstream_pSetLayouts->internal_object;
            }
            internal_pAllocateInfo[i].pSetLayouts =
                internal_VkDescriptorSetAllocateInfo_pSetLayouts[i].data();
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkAllocateDescriptorSets_VkResult_return = resources->on_vkAllocateDescriptorSets(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, internal_pAllocateInfo.data(),
            pDescriptorSets);
    }
    return vkAllocateDescriptorSets_VkResult_return;
}
VkResult gfxstream_vk_FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool,
                                         uint32_t descriptorSetCount,
                                         const VkDescriptorSet* pDescriptorSets) {
    AEMU_SCOPED_TRACE("vkFreeDescriptorSets");
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    if (VK_NULL_HANDLE == pDescriptorSets) {
        return vkFreeDescriptorSets_VkResult_return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_pool, gfxstream_descriptorPool, descriptorPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkFreeDescriptorSets_VkResult_return = resources->on_vkFreeDescriptorSets(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
            gfxstream_descriptorPool->internal_object, descriptorSetCount, pDescriptorSets);
    }
    return vkFreeDescriptorSets_VkResult_return;
}
VkResult gfxstream_vk_CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkFramebuffer* pFramebuffer) {
    AEMU_SCOPED_TRACE("vkCreateFramebuffer");
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_framebuffer* gfxstream_pFramebuffer =
        (gfxstream_vk_framebuffer*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                    sizeof(gfxstream_vk_framebuffer),
                                                    VK_OBJECT_TYPE_FRAMEBUFFER);
    vkCreateFramebuffer_VkResult_return =
        gfxstream_pFramebuffer ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateFramebuffer_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkFramebufferCreateInfo> internal_pCreateInfo(1);
        std::vector<std::vector<VkImageView>> internal_VkFramebufferCreateInfo_pAttachments;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCreateInfo[i] = pCreateInfo[i];
            /* VkFramebufferCreateInfo::renderPass */
            VK_FROM_HANDLE(gfxstream_vk_render_pass, gfxstream_renderPass,
                           internal_pCreateInfo[i].renderPass);
            internal_pCreateInfo[i].renderPass = gfxstream_renderPass->internal_object;
            /* VkFramebufferCreateInfo::pAttachments */
            internal_VkFramebufferCreateInfo_pAttachments.push_back(std::vector<VkImageView>());
            internal_VkFramebufferCreateInfo_pAttachments[i].reserve(
                internal_pCreateInfo[i].attachmentCount);
            memset(&internal_VkFramebufferCreateInfo_pAttachments[i][0], 0,
                   sizeof(VkImageView) * internal_pCreateInfo[i].attachmentCount);
            for (uint32_t j = 0; j < internal_pCreateInfo[i].attachmentCount; ++j) {
                if (internal_pCreateInfo[i].pAttachments) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_pAttachments,
                                   internal_pCreateInfo[i].pAttachments[j]);
                    internal_VkFramebufferCreateInfo_pAttachments[i][j] =
                        gfxstream_pAttachments->internal_object;
                }
            }
            internal_pCreateInfo[i].pAttachments =
                internal_VkFramebufferCreateInfo_pAttachments[i].data();
        }
        vkCreateFramebuffer_VkResult_return = vkEnc->vkCreateFramebuffer(
            gfxstream_device->internal_object, internal_pCreateInfo.data(), pAllocator,
            &gfxstream_pFramebuffer->internal_object, true /* do lock */);
    }
    *pFramebuffer = gfxstream_vk_framebuffer_to_handle(gfxstream_pFramebuffer);
    return vkCreateFramebuffer_VkResult_return;
}
void gfxstream_vk_DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer,
                                     const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyFramebuffer");
    if (VK_NULL_HANDLE == framebuffer) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_framebuffer, gfxstream_framebuffer, framebuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyFramebuffer(
            gfxstream_device->internal_object,
            gfxstream_framebuffer ? gfxstream_framebuffer->internal_object : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_framebuffer);
}
VkResult gfxstream_vk_CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkRenderPass* pRenderPass) {
    AEMU_SCOPED_TRACE("vkCreateRenderPass");
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_render_pass* gfxstream_pRenderPass =
        (gfxstream_vk_render_pass*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                    sizeof(gfxstream_vk_render_pass),
                                                    VK_OBJECT_TYPE_RENDER_PASS);
    vkCreateRenderPass_VkResult_return =
        gfxstream_pRenderPass ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateRenderPass_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateRenderPass_VkResult_return =
            vkEnc->vkCreateRenderPass(gfxstream_device->internal_object, pCreateInfo, pAllocator,
                                      &gfxstream_pRenderPass->internal_object, true /* do lock */);
    }
    *pRenderPass = gfxstream_vk_render_pass_to_handle(gfxstream_pRenderPass);
    return vkCreateRenderPass_VkResult_return;
}
void gfxstream_vk_DestroyRenderPass(VkDevice device, VkRenderPass renderPass,
                                    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyRenderPass");
    if (VK_NULL_HANDLE == renderPass) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_render_pass, gfxstream_renderPass, renderPass);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyRenderPass(
            gfxstream_device->internal_object,
            gfxstream_renderPass ? gfxstream_renderPass->internal_object : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_renderPass);
}
void gfxstream_vk_GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass,
                                           VkExtent2D* pGranularity) {
    AEMU_SCOPED_TRACE("vkGetRenderAreaGranularity");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_render_pass, gfxstream_renderPass, renderPass);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetRenderAreaGranularity(gfxstream_device->internal_object,
                                          gfxstream_renderPass->internal_object, pGranularity,
                                          true /* do lock */);
    }
}
VkResult gfxstream_vk_BeginCommandBuffer(VkCommandBuffer commandBuffer,
                                         const VkCommandBufferBeginInfo* pBeginInfo) {
    AEMU_SCOPED_TRACE("vkBeginCommandBuffer");
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCommandBufferBeginInfo> internal_pBeginInfo(1);
        std::vector<VkCommandBufferInheritanceInfo>
            internal_VkCommandBufferBeginInfo_pInheritanceInfo;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pBeginInfo[i] = pBeginInfo[i];
            /* VkCommandBufferBeginInfo::pInheritanceInfo */
            if (internal_pBeginInfo[i].pInheritanceInfo) {
                internal_VkCommandBufferBeginInfo_pInheritanceInfo[i] =
                    internal_pBeginInfo[i].pInheritanceInfo[0];
                /* VkCommandBufferInheritanceInfo::renderPass */
                if (internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].renderPass) {
                    VK_FROM_HANDLE(
                        gfxstream_vk_render_pass, gfxstream_renderPass,
                        internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].renderPass);
                    internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].renderPass =
                        gfxstream_renderPass->internal_object;
                }
                /* VkCommandBufferInheritanceInfo::framebuffer */
                if (internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].framebuffer) {
                    VK_FROM_HANDLE(
                        gfxstream_vk_framebuffer, gfxstream_framebuffer,
                        internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].framebuffer);
                    internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].framebuffer =
                        gfxstream_framebuffer->internal_object;
                }
                internal_pBeginInfo[i].pInheritanceInfo =
                    &internal_VkCommandBufferBeginInfo_pInheritanceInfo[i];
            }
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBeginCommandBuffer_VkResult_return = resources->on_vkBeginCommandBuffer(
            vkEnc, VK_SUCCESS, gfxstream_commandBuffer->internal_object,
            internal_pBeginInfo.data());
    }
    return vkBeginCommandBuffer_VkResult_return;
}
VkResult gfxstream_vk_EndCommandBuffer(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkEndCommandBuffer");
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkEndCommandBuffer_VkResult_return = resources->on_vkEndCommandBuffer(
            vkEnc, VK_SUCCESS, gfxstream_commandBuffer->internal_object);
    }
    return vkEndCommandBuffer_VkResult_return;
}
VkResult gfxstream_vk_ResetCommandBuffer(VkCommandBuffer commandBuffer,
                                         VkCommandBufferResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetCommandBuffer");
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkResetCommandBuffer_VkResult_return = resources->on_vkResetCommandBuffer(
            vkEnc, VK_SUCCESS, gfxstream_commandBuffer->internal_object, flags);
    }
    return vkResetCommandBuffer_VkResult_return;
}
void gfxstream_vk_CmdBindPipeline(VkCommandBuffer commandBuffer,
                                  VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    AEMU_SCOPED_TRACE("vkCmdBindPipeline");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_pipeline, gfxstream_pipeline, pipeline);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdBindPipeline(gfxstream_commandBuffer->internal_object, pipelineBindPoint,
                                 gfxstream_pipeline->internal_object, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                 uint32_t viewportCount, const VkViewport* pViewports) {
    AEMU_SCOPED_TRACE("vkCmdSetViewport");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetViewport(gfxstream_commandBuffer->internal_object, firstViewport,
                                viewportCount, pViewports, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor,
                                uint32_t scissorCount, const VkRect2D* pScissors) {
    AEMU_SCOPED_TRACE("vkCmdSetScissor");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetScissor(gfxstream_commandBuffer->internal_object, firstScissor, scissorCount,
                               pScissors, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
    AEMU_SCOPED_TRACE("vkCmdSetLineWidth");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetLineWidth(gfxstream_commandBuffer->internal_object, lineWidth,
                                 true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor,
                                  float depthBiasClamp, float depthBiasSlopeFactor) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBias");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthBias(gfxstream_commandBuffer->internal_object, depthBiasConstantFactor,
                                 depthBiasClamp, depthBiasSlopeFactor, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetBlendConstants(VkCommandBuffer commandBuffer,
                                       const float blendConstants[4]) {
    AEMU_SCOPED_TRACE("vkCmdSetBlendConstants");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetBlendConstants(gfxstream_commandBuffer->internal_object, blendConstants,
                                      true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds,
                                    float maxDepthBounds) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBounds");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthBounds(gfxstream_commandBuffer->internal_object, minDepthBounds,
                                   maxDepthBounds, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilCompareMask(VkCommandBuffer commandBuffer,
                                           VkStencilFaceFlags faceMask, uint32_t compareMask) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilCompareMask");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilCompareMask(gfxstream_commandBuffer->internal_object, faceMask,
                                          compareMask, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                         uint32_t writeMask) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilWriteMask");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilWriteMask(gfxstream_commandBuffer->internal_object, faceMask,
                                        writeMask, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                         uint32_t reference) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilReference");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilReference(gfxstream_commandBuffer->internal_object, faceMask,
                                        reference, true /* do lock */);
    }
}
void gfxstream_vk_CmdBindDescriptorSets(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
    uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
    AEMU_SCOPED_TRACE("vkCmdBindDescriptorSets");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_layout, gfxstream_layout, layout);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkCmdBindDescriptorSets(vkEnc, gfxstream_commandBuffer->internal_object,
                                              pipelineBindPoint, gfxstream_layout->internal_object,
                                              firstSet, descriptorSetCount, pDescriptorSets,
                                              dynamicOffsetCount, pDynamicOffsets);
    }
}
void gfxstream_vk_CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                     VkDeviceSize offset, VkIndexType indexType) {
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdBindIndexBuffer(gfxstream_commandBuffer->internal_object,
                                    gfxstream_buffer->internal_object, offset, indexType,
                                    true /* do lock */);
    }
}
void gfxstream_vk_CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                       uint32_t bindingCount, const VkBuffer* pBuffers,
                                       const VkDeviceSize* pOffsets) {
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBuffer> internal_pBuffers(bindingCount);
        for (uint32_t i = 0; i < bindingCount; ++i) {
            if (pBuffers) {
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_pBuffers, pBuffers[i]);
                internal_pBuffers[i] = gfxstream_pBuffers->internal_object;
            }
        }
        vkEnc->vkCmdBindVertexBuffers(gfxstream_commandBuffer->internal_object, firstBinding,
                                      bindingCount, internal_pBuffers.data(), pOffsets,
                                      true /* do lock */);
    }
}
void gfxstream_vk_CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount,
                          uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
    AEMU_SCOPED_TRACE("vkCmdDraw");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDraw(gfxstream_commandBuffer->internal_object, vertexCount, instanceCount,
                         firstVertex, firstInstance, true /* do lock */);
    }
}
void gfxstream_vk_CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount,
                                 uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset,
                                 uint32_t firstInstance) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndexed");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDrawIndexed(gfxstream_commandBuffer->internal_object, indexCount, instanceCount,
                                firstIndex, vertexOffset, firstInstance, true /* do lock */);
    }
}
void gfxstream_vk_CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                  VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndirect");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDrawIndirect(gfxstream_commandBuffer->internal_object,
                                 gfxstream_buffer->internal_object, offset, drawCount, stride,
                                 true /* do lock */);
    }
}
void gfxstream_vk_CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                         VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirect");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDrawIndexedIndirect(gfxstream_commandBuffer->internal_object,
                                        gfxstream_buffer->internal_object, offset, drawCount,
                                        stride, true /* do lock */);
    }
}
void gfxstream_vk_CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX,
                              uint32_t groupCountY, uint32_t groupCountZ) {
    AEMU_SCOPED_TRACE("vkCmdDispatch");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDispatch(gfxstream_commandBuffer->internal_object, groupCountX, groupCountY,
                             groupCountZ, true /* do lock */);
    }
}
void gfxstream_vk_CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                      VkDeviceSize offset) {
    AEMU_SCOPED_TRACE("vkCmdDispatchIndirect");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDispatchIndirect(gfxstream_commandBuffer->internal_object,
                                     gfxstream_buffer->internal_object, offset, true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                VkBuffer dstBuffer, uint32_t regionCount,
                                const VkBufferCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_srcBuffer, srcBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer, dstBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdCopyBuffer(
            gfxstream_commandBuffer->internal_object, gfxstream_srcBuffer->internal_object,
            gfxstream_dstBuffer->internal_object, regionCount, pRegions, true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                               VkImageLayout srcImageLayout, VkImage dstImage,
                               VkImageLayout dstImageLayout, uint32_t regionCount,
                               const VkImageCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyImage");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage, srcImage);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage, dstImage);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdCopyImage(gfxstream_commandBuffer->internal_object,
                              gfxstream_srcImage->internal_object, srcImageLayout,
                              gfxstream_dstImage->internal_object, dstImageLayout, regionCount,
                              pRegions, true /* do lock */);
    }
}
void gfxstream_vk_CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                               VkImageLayout srcImageLayout, VkImage dstImage,
                               VkImageLayout dstImageLayout, uint32_t regionCount,
                               const VkImageBlit* pRegions, VkFilter filter) {
    AEMU_SCOPED_TRACE("vkCmdBlitImage");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage, srcImage);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage, dstImage);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdBlitImage(gfxstream_commandBuffer->internal_object,
                              gfxstream_srcImage->internal_object, srcImageLayout,
                              gfxstream_dstImage->internal_object, dstImageLayout, regionCount,
                              pRegions, filter, true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                       VkImage dstImage, VkImageLayout dstImageLayout,
                                       uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_srcBuffer, srcBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage, dstImage);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdCopyBufferToImage(gfxstream_commandBuffer->internal_object,
                                      gfxstream_srcBuffer->internal_object,
                                      gfxstream_dstImage->internal_object, dstImageLayout,
                                      regionCount, pRegions, true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage,
                                       VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                       uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage, srcImage);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer, dstBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdCopyImageToBuffer(gfxstream_commandBuffer->internal_object,
                                      gfxstream_srcImage->internal_object, srcImageLayout,
                                      gfxstream_dstBuffer->internal_object, regionCount, pRegions,
                                      true /* do lock */);
    }
}
void gfxstream_vk_CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                  VkDeviceSize dstOffset, VkDeviceSize dataSize,
                                  const void* pData) {
    AEMU_SCOPED_TRACE("vkCmdUpdateBuffer");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer, dstBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdUpdateBuffer(gfxstream_commandBuffer->internal_object,
                                 gfxstream_dstBuffer->internal_object, dstOffset, dataSize, pData,
                                 true /* do lock */);
    }
}
void gfxstream_vk_CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    AEMU_SCOPED_TRACE("vkCmdFillBuffer");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer, dstBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdFillBuffer(gfxstream_commandBuffer->internal_object,
                               gfxstream_dstBuffer->internal_object, dstOffset, size, data,
                               true /* do lock */);
    }
}
void gfxstream_vk_CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image,
                                     VkImageLayout imageLayout, const VkClearColorValue* pColor,
                                     uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
    AEMU_SCOPED_TRACE("vkCmdClearColorImage");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdClearColorImage(gfxstream_commandBuffer->internal_object,
                                    gfxstream_image->internal_object, imageLayout, pColor,
                                    rangeCount, pRanges, true /* do lock */);
    }
}
void gfxstream_vk_CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image,
                                            VkImageLayout imageLayout,
                                            const VkClearDepthStencilValue* pDepthStencil,
                                            uint32_t rangeCount,
                                            const VkImageSubresourceRange* pRanges) {
    AEMU_SCOPED_TRACE("vkCmdClearDepthStencilImage");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdClearDepthStencilImage(gfxstream_commandBuffer->internal_object,
                                           gfxstream_image->internal_object, imageLayout,
                                           pDepthStencil, rangeCount, pRanges, true /* do lock */);
    }
}
void gfxstream_vk_CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                      const VkClearAttachment* pAttachments, uint32_t rectCount,
                                      const VkClearRect* pRects) {
    AEMU_SCOPED_TRACE("vkCmdClearAttachments");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdClearAttachments(gfxstream_commandBuffer->internal_object, attachmentCount,
                                     pAttachments, rectCount, pRects, true /* do lock */);
    }
}
void gfxstream_vk_CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                  VkImageLayout srcImageLayout, VkImage dstImage,
                                  VkImageLayout dstImageLayout, uint32_t regionCount,
                                  const VkImageResolve* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdResolveImage");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage, srcImage);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage, dstImage);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdResolveImage(gfxstream_commandBuffer->internal_object,
                                 gfxstream_srcImage->internal_object, srcImageLayout,
                                 gfxstream_dstImage->internal_object, dstImageLayout, regionCount,
                                 pRegions, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event,
                              VkPipelineStageFlags stageMask) {
    AEMU_SCOPED_TRACE("vkCmdSetEvent");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetEvent(gfxstream_commandBuffer->internal_object,
                             gfxstream_event->internal_object, stageMask, true /* do lock */);
    }
}
void gfxstream_vk_CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event,
                                VkPipelineStageFlags stageMask) {
    AEMU_SCOPED_TRACE("vkCmdResetEvent");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdResetEvent(gfxstream_commandBuffer->internal_object,
                               gfxstream_event->internal_object, stageMask, true /* do lock */);
    }
}
void gfxstream_vk_CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                const VkEvent* pEvents, VkPipelineStageFlags srcStageMask,
                                VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount,
                                const VkMemoryBarrier* pMemoryBarriers,
                                uint32_t bufferMemoryBarrierCount,
                                const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                                uint32_t imageMemoryBarrierCount,
                                const VkImageMemoryBarrier* pImageMemoryBarriers) {
    AEMU_SCOPED_TRACE("vkCmdWaitEvents");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkEvent> internal_pEvents(eventCount);
        for (uint32_t i = 0; i < eventCount; ++i) {
            VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_pEvents, pEvents[i]);
            internal_pEvents[i] = gfxstream_pEvents->internal_object;
        }
        std::vector<VkBufferMemoryBarrier> internal_pBufferMemoryBarriers(bufferMemoryBarrierCount);
        for (uint32_t i = 0; i < bufferMemoryBarrierCount; ++i) {
            internal_pBufferMemoryBarriers[i] = pBufferMemoryBarriers[i];
            /* VkBufferMemoryBarrier::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                           internal_pBufferMemoryBarriers[i].buffer);
            internal_pBufferMemoryBarriers[i].buffer = gfxstream_buffer->internal_object;
        }
        std::vector<VkImageMemoryBarrier> internal_pImageMemoryBarriers(imageMemoryBarrierCount);
        for (uint32_t i = 0; i < imageMemoryBarrierCount; ++i) {
            internal_pImageMemoryBarriers[i] = pImageMemoryBarriers[i];
            /* VkImageMemoryBarrier::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                           internal_pImageMemoryBarriers[i].image);
            internal_pImageMemoryBarriers[i].image = gfxstream_image->internal_object;
        }
        vkEnc->vkCmdWaitEvents(gfxstream_commandBuffer->internal_object, eventCount,
                               internal_pEvents.data(), srcStageMask, dstStageMask,
                               memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
                               internal_pBufferMemoryBarriers.data(), imageMemoryBarrierCount,
                               internal_pImageMemoryBarriers.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdPipelineBarrier(
    VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBufferMemoryBarrier> internal_pBufferMemoryBarriers(bufferMemoryBarrierCount);
        for (uint32_t i = 0; i < bufferMemoryBarrierCount; ++i) {
            internal_pBufferMemoryBarriers[i] = pBufferMemoryBarriers[i];
            /* VkBufferMemoryBarrier::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                           internal_pBufferMemoryBarriers[i].buffer);
            internal_pBufferMemoryBarriers[i].buffer = gfxstream_buffer->internal_object;
        }
        std::vector<VkImageMemoryBarrier> internal_pImageMemoryBarriers(imageMemoryBarrierCount);
        for (uint32_t i = 0; i < imageMemoryBarrierCount; ++i) {
            internal_pImageMemoryBarriers[i] = pImageMemoryBarriers[i];
            /* VkImageMemoryBarrier::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                           internal_pImageMemoryBarriers[i].image);
            internal_pImageMemoryBarriers[i].image = gfxstream_image->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkCmdPipelineBarrier(
            vkEnc, gfxstream_commandBuffer->internal_object, srcStageMask, dstStageMask,
            dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
            internal_pBufferMemoryBarriers.data(), imageMemoryBarrierCount,
            internal_pImageMemoryBarriers.data());
    }
}
void gfxstream_vk_CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                uint32_t query, VkQueryControlFlags flags) {
    AEMU_SCOPED_TRACE("vkCmdBeginQuery");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdBeginQuery(gfxstream_commandBuffer->internal_object,
                               gfxstream_queryPool->internal_object, query, flags,
                               true /* do lock */);
    }
}
void gfxstream_vk_CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                              uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdEndQuery");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndQuery(gfxstream_commandBuffer->internal_object,
                             gfxstream_queryPool->internal_object, query, true /* do lock */);
    }
}
void gfxstream_vk_CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                    uint32_t firstQuery, uint32_t queryCount) {
    AEMU_SCOPED_TRACE("vkCmdResetQueryPool");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdResetQueryPool(gfxstream_commandBuffer->internal_object,
                                   gfxstream_queryPool->internal_object, firstQuery, queryCount,
                                   true /* do lock */);
    }
}
void gfxstream_vk_CmdWriteTimestamp(VkCommandBuffer commandBuffer,
                                    VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool,
                                    uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdWriteTimestamp(gfxstream_commandBuffer->internal_object, pipelineStage,
                                   gfxstream_queryPool->internal_object, query, true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                          uint32_t firstQuery, uint32_t queryCount,
                                          VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                          VkDeviceSize stride, VkQueryResultFlags flags) {
    AEMU_SCOPED_TRACE("vkCmdCopyQueryPoolResults");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer, dstBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdCopyQueryPoolResults(gfxstream_commandBuffer->internal_object,
                                         gfxstream_queryPool->internal_object, firstQuery,
                                         queryCount, gfxstream_dstBuffer->internal_object,
                                         dstOffset, stride, flags, true /* do lock */);
    }
}
void gfxstream_vk_CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                   VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
                                   const void* pValues) {
    AEMU_SCOPED_TRACE("vkCmdPushConstants");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_pipeline_layout, gfxstream_layout, layout);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdPushConstants(gfxstream_commandBuffer->internal_object,
                                  gfxstream_layout->internal_object, stageFlags, offset, size,
                                  pValues, true /* do lock */);
    }
}
void gfxstream_vk_CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
    AEMU_SCOPED_TRACE("vkCmdNextSubpass");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdNextSubpass(gfxstream_commandBuffer->internal_object, contents,
                                true /* do lock */);
    }
}
void gfxstream_vk_CmdEndRenderPass(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndRenderPass(gfxstream_commandBuffer->internal_object, true /* do lock */);
    }
}
void gfxstream_vk_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                     const VkCommandBuffer* pCommandBuffers) {
    AEMU_SCOPED_TRACE("vkCmdExecuteCommands");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCommandBuffer> internal_pCommandBuffers(commandBufferCount);
        for (uint32_t i = 0; i < commandBufferCount; ++i) {
            VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_pCommandBuffers,
                           pCommandBuffers[i]);
            internal_pCommandBuffers[i] = gfxstream_pCommandBuffers->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkCmdExecuteCommands(vkEnc, gfxstream_commandBuffer->internal_object,
                                           commandBufferCount, internal_pCommandBuffers.data());
    }
}
#endif
#ifdef VK_VERSION_1_1
VkResult gfxstream_vk_BindBufferMemory2(VkDevice device, uint32_t bindInfoCount,
                                        const VkBindBufferMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindBufferMemory2");
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBindBufferMemoryInfo> internal_pBindInfos(bindInfoCount);
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            internal_pBindInfos[i] = pBindInfos[i];
            /* VkBindBufferMemoryInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pBindInfos[i].buffer);
            internal_pBindInfos[i].buffer = gfxstream_buffer->internal_object;
            /* VkBindBufferMemoryInfo::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                           internal_pBindInfos[i].memory);
            internal_pBindInfos[i].memory = gfxstream_memory->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBindBufferMemory2_VkResult_return =
            resources->on_vkBindBufferMemory2(vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
                                              bindInfoCount, internal_pBindInfos.data());
    }
    return vkBindBufferMemory2_VkResult_return;
}
VkResult gfxstream_vk_BindImageMemory2(VkDevice device, uint32_t bindInfoCount,
                                       const VkBindImageMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindImageMemory2");
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBindImageMemoryInfo> internal_pBindInfos(bindInfoCount);
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            internal_pBindInfos[i] = pBindInfos[i];
            /* VkBindImageMemoryInfo::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pBindInfos[i].image);
            internal_pBindInfos[i].image = gfxstream_image->internal_object;
            /* VkBindImageMemoryInfo::memory */
            if (internal_pBindInfos[i].memory) {
                VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                               internal_pBindInfos[i].memory);
                internal_pBindInfos[i].memory = gfxstream_memory->internal_object;
            }
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBindImageMemory2_VkResult_return =
            resources->on_vkBindImageMemory2(vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
                                             bindInfoCount, internal_pBindInfos.data());
    }
    return vkBindImageMemory2_VkResult_return;
}
void gfxstream_vk_GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex,
                                                   uint32_t localDeviceIndex,
                                                   uint32_t remoteDeviceIndex,
                                                   VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceGroupPeerMemoryFeatures(gfxstream_device->internal_object, heapIndex,
                                                  localDeviceIndex, remoteDeviceIndex,
                                                  pPeerMemoryFeatures, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMask");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDeviceMask(gfxstream_commandBuffer->internal_object, deviceMask,
                                  true /* do lock */);
    }
}
void gfxstream_vk_CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX,
                                  uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX,
                                  uint32_t groupCountY, uint32_t groupCountZ) {
    AEMU_SCOPED_TRACE("vkCmdDispatchBase");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDispatchBase(gfxstream_commandBuffer->internal_object, baseGroupX, baseGroupY,
                                 baseGroupZ, groupCountX, groupCountY, groupCountZ,
                                 true /* do lock */);
    }
}
void gfxstream_vk_GetImageMemoryRequirements2(VkDevice device,
                                              const VkImageMemoryRequirementsInfo2* pInfo,
                                              VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImageMemoryRequirementsInfo2> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkImageMemoryRequirementsInfo2::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pInfo[i].image);
            internal_pInfo[i].image = gfxstream_image->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetImageMemoryRequirements2(vkEnc, gfxstream_device->internal_object,
                                                    internal_pInfo.data(), pMemoryRequirements);
    }
}
void gfxstream_vk_GetBufferMemoryRequirements2(VkDevice device,
                                               const VkBufferMemoryRequirementsInfo2* pInfo,
                                               VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferMemoryRequirementsInfo2> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkBufferMemoryRequirementsInfo2::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pInfo[i].buffer);
            internal_pInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetBufferMemoryRequirements2(vkEnc, gfxstream_device->internal_object,
                                                     internal_pInfo.data(), pMemoryRequirements);
    }
}
void gfxstream_vk_GetImageSparseMemoryRequirements2(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImageSparseMemoryRequirementsInfo2> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkImageSparseMemoryRequirementsInfo2::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pInfo[i].image);
            internal_pInfo[i].image = gfxstream_image->internal_object;
        }
        vkEnc->vkGetImageSparseMemoryRequirements2(
            gfxstream_device->internal_object, internal_pInfo.data(), pSparseMemoryRequirementCount,
            pSparseMemoryRequirements, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
                                             VkPhysicalDeviceFeatures2* pFeatures) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceFeatures2(gfxstream_physicalDevice->internal_object, pFeatures,
                                            true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice,
                                               VkPhysicalDeviceProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceProperties2(gfxstream_physicalDevice->internal_object,
                                              pProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice,
                                                     VkFormat format,
                                                     VkFormatProperties2* pFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceFormatProperties2(gfxstream_physicalDevice->internal_object,
                                                    format, pFormatProperties, true /* do lock */);
    }
}
VkResult gfxstream_vk_GetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2");
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetPhysicalDeviceImageFormatProperties2_VkResult_return =
            resources->on_vkGetPhysicalDeviceImageFormatProperties2(
                vkEnc, VK_SUCCESS, gfxstream_physicalDevice->internal_object, pImageFormatInfo,
                pImageFormatProperties);
    }
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}
void gfxstream_vk_GetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceQueueFamilyProperties2(
            gfxstream_physicalDevice->internal_object, pQueueFamilyPropertyCount,
            pQueueFamilyProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceMemoryProperties2(gfxstream_physicalDevice->internal_object,
                                                    pMemoryProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties2(
            gfxstream_physicalDevice->internal_object, pFormatInfo, pPropertyCount, pProperties,
            true /* do lock */);
    }
}
void gfxstream_vk_TrimCommandPool(VkDevice device, VkCommandPool commandPool,
                                  VkCommandPoolTrimFlags flags) {
    AEMU_SCOPED_TRACE("vkTrimCommandPool");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_command_pool, gfxstream_commandPool, commandPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkTrimCommandPool(gfxstream_device->internal_object,
                                 gfxstream_commandPool->internal_object, flags, true /* do lock */);
    }
}
VkResult gfxstream_vk_CreateSamplerYcbcrConversion(
    VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion");
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateSamplerYcbcrConversion_VkResult_return =
            resources->on_vkCreateSamplerYcbcrConversion(vkEnc, VK_SUCCESS,
                                                         gfxstream_device->internal_object,
                                                         pCreateInfo, pAllocator, pYcbcrConversion);
    }
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}
void gfxstream_vk_DestroySamplerYcbcrConversion(VkDevice device,
                                                VkSamplerYcbcrConversion ycbcrConversion,
                                                const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion");
    if (VK_NULL_HANDLE == ycbcrConversion) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroySamplerYcbcrConversion(vkEnc, gfxstream_device->internal_object,
                                                      ycbcrConversion, pAllocator);
    }
}
VkResult gfxstream_vk_CreateDescriptorUpdateTemplate(
    VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate");
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_descriptor_update_template* gfxstream_pDescriptorUpdateTemplate =
        (gfxstream_vk_descriptor_update_template*)vk_object_zalloc(
            &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_descriptor_update_template),
            VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE);
    vkCreateDescriptorUpdateTemplate_VkResult_return =
        gfxstream_pDescriptorUpdateTemplate ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateDescriptorUpdateTemplate_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDescriptorUpdateTemplateCreateInfo> internal_pCreateInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCreateInfo[i] = pCreateInfo[i];
            /* VkDescriptorUpdateTemplateCreateInfo::descriptorSetLayout */
            if (internal_pCreateInfo[i].descriptorSetLayout) {
                VK_FROM_HANDLE(gfxstream_vk_descriptor_set_layout, gfxstream_descriptorSetLayout,
                               internal_pCreateInfo[i].descriptorSetLayout);
                internal_pCreateInfo[i].descriptorSetLayout =
                    gfxstream_descriptorSetLayout->internal_object;
            }
            /* VkDescriptorUpdateTemplateCreateInfo::pipelineLayout */
            if (internal_pCreateInfo[i].pipelineLayout) {
                VK_FROM_HANDLE(gfxstream_vk_pipeline_layout, gfxstream_pipelineLayout,
                               internal_pCreateInfo[i].pipelineLayout);
                internal_pCreateInfo[i].pipelineLayout = gfxstream_pipelineLayout->internal_object;
            }
        }
        vkCreateDescriptorUpdateTemplate_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplate(
            gfxstream_device->internal_object, internal_pCreateInfo.data(), pAllocator,
            &gfxstream_pDescriptorUpdateTemplate->internal_object, true /* do lock */);
    }
    *pDescriptorUpdateTemplate =
        gfxstream_vk_descriptor_update_template_to_handle(gfxstream_pDescriptorUpdateTemplate);
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}
void gfxstream_vk_DestroyDescriptorUpdateTemplate(
    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate");
    if (VK_NULL_HANDLE == descriptorUpdateTemplate) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_update_template, gfxstream_descriptorUpdateTemplate,
                   descriptorUpdateTemplate);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyDescriptorUpdateTemplate(
            gfxstream_device->internal_object,
            gfxstream_descriptorUpdateTemplate ? gfxstream_descriptorUpdateTemplate->internal_object
                                               : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_descriptorUpdateTemplate);
}
void gfxstream_vk_UpdateDescriptorSetWithTemplate(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_update_template, gfxstream_descriptorUpdateTemplate,
                   descriptorUpdateTemplate);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkUpdateDescriptorSetWithTemplate(
            vkEnc, gfxstream_device->internal_object, descriptorSet,
            gfxstream_descriptorUpdateTemplate->internal_object, pData);
    }
}
void gfxstream_vk_GetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetPhysicalDeviceExternalBufferProperties(
            vkEnc, gfxstream_physicalDevice->internal_object, pExternalBufferInfo,
            pExternalBufferProperties);
    }
}
void gfxstream_vk_GetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFenceProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetPhysicalDeviceExternalFenceProperties(
            vkEnc, gfxstream_physicalDevice->internal_object, pExternalFenceInfo,
            pExternalFenceProperties);
    }
}
void gfxstream_vk_GetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphoreProperties");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceExternalSemaphoreProperties(
            gfxstream_physicalDevice->internal_object, pExternalSemaphoreInfo,
            pExternalSemaphoreProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetDescriptorSetLayoutSupport(VkDevice device,
                                                const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                VkDescriptorSetLayoutSupport* pSupport) {
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDescriptorSetLayoutSupport(gfxstream_device->internal_object, pCreateInfo,
                                               pSupport, true /* do lock */);
    }
}
#endif
#ifdef VK_VERSION_1_2
void gfxstream_vk_CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                       VkDeviceSize offset, VkBuffer countBuffer,
                                       VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                       uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCount");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_countBuffer, countBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDrawIndirectCount(gfxstream_commandBuffer->internal_object,
                                      gfxstream_buffer->internal_object, offset,
                                      gfxstream_countBuffer->internal_object, countBufferOffset,
                                      maxDrawCount, stride, true /* do lock */);
    }
}
void gfxstream_vk_CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                              VkDeviceSize offset, VkBuffer countBuffer,
                                              VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                              uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCount");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_countBuffer, countBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDrawIndexedIndirectCount(
            gfxstream_commandBuffer->internal_object, gfxstream_buffer->internal_object, offset,
            gfxstream_countBuffer->internal_object, countBufferOffset, maxDrawCount, stride,
            true /* do lock */);
    }
}
VkResult gfxstream_vk_CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkRenderPass* pRenderPass) {
    AEMU_SCOPED_TRACE("vkCreateRenderPass2");
    VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_render_pass* gfxstream_pRenderPass =
        (gfxstream_vk_render_pass*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                    sizeof(gfxstream_vk_render_pass),
                                                    VK_OBJECT_TYPE_RENDER_PASS);
    vkCreateRenderPass2_VkResult_return =
        gfxstream_pRenderPass ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateRenderPass2_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateRenderPass2_VkResult_return =
            vkEnc->vkCreateRenderPass2(gfxstream_device->internal_object, pCreateInfo, pAllocator,
                                       &gfxstream_pRenderPass->internal_object, true /* do lock */);
    }
    *pRenderPass = gfxstream_vk_render_pass_to_handle(gfxstream_pRenderPass);
    return vkCreateRenderPass2_VkResult_return;
}
void gfxstream_vk_CmdBeginRenderPass2(VkCommandBuffer commandBuffer,
                                      const VkRenderPassBeginInfo* pRenderPassBegin,
                                      const VkSubpassBeginInfo* pSubpassBeginInfo) {
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkRenderPassBeginInfo> internal_pRenderPassBegin(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pRenderPassBegin[i] = pRenderPassBegin[i];
            /* VkRenderPassBeginInfo::renderPass */
            VK_FROM_HANDLE(gfxstream_vk_render_pass, gfxstream_renderPass,
                           internal_pRenderPassBegin[i].renderPass);
            internal_pRenderPassBegin[i].renderPass = gfxstream_renderPass->internal_object;
            /* VkRenderPassBeginInfo::framebuffer */
            VK_FROM_HANDLE(gfxstream_vk_framebuffer, gfxstream_framebuffer,
                           internal_pRenderPassBegin[i].framebuffer);
            internal_pRenderPassBegin[i].framebuffer = gfxstream_framebuffer->internal_object;
        }
        vkEnc->vkCmdBeginRenderPass2(gfxstream_commandBuffer->internal_object,
                                     internal_pRenderPassBegin.data(), pSubpassBeginInfo,
                                     true /* do lock */);
    }
}
void gfxstream_vk_CmdNextSubpass2(VkCommandBuffer commandBuffer,
                                  const VkSubpassBeginInfo* pSubpassBeginInfo,
                                  const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdNextSubpass2(gfxstream_commandBuffer->internal_object, pSubpassBeginInfo,
                                 pSubpassEndInfo, true /* do lock */);
    }
}
void gfxstream_vk_CmdEndRenderPass2(VkCommandBuffer commandBuffer,
                                    const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndRenderPass2(gfxstream_commandBuffer->internal_object, pSubpassEndInfo,
                                   true /* do lock */);
    }
}
void gfxstream_vk_ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                 uint32_t queryCount) {
    AEMU_SCOPED_TRACE("vkResetQueryPool");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkResetQueryPool(gfxstream_device->internal_object,
                                gfxstream_queryPool->internal_object, firstQuery, queryCount,
                                true /* do lock */);
    }
}
VkResult gfxstream_vk_GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore,
                                               uint64_t* pValue) {
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValue");
    VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_semaphore, gfxstream_semaphore, semaphore);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetSemaphoreCounterValue_VkResult_return = vkEnc->vkGetSemaphoreCounterValue(
            gfxstream_device->internal_object, gfxstream_semaphore->internal_object, pValue,
            true /* do lock */);
    }
    return vkGetSemaphoreCounterValue_VkResult_return;
}
VkResult gfxstream_vk_WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo,
                                     uint64_t timeout) {
    AEMU_SCOPED_TRACE("vkWaitSemaphores");
    VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkSemaphoreWaitInfo> internal_pWaitInfo(1);
        std::vector<std::vector<VkSemaphore>> internal_VkSemaphoreWaitInfo_pSemaphores;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pWaitInfo[i] = pWaitInfo[i];
            /* VkSemaphoreWaitInfo::pSemaphores */
            internal_VkSemaphoreWaitInfo_pSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkSemaphoreWaitInfo_pSemaphores[i] = transformVkSemaphoreList(
                internal_pWaitInfo[i].pSemaphores, internal_pWaitInfo[i].semaphoreCount);
            internal_pWaitInfo[i].pSemaphores = internal_VkSemaphoreWaitInfo_pSemaphores[i].data();
            internal_pWaitInfo[i].semaphoreCount =
                internal_VkSemaphoreWaitInfo_pSemaphores[i].size();
        }
        vkWaitSemaphores_VkResult_return =
            vkEnc->vkWaitSemaphores(gfxstream_device->internal_object, internal_pWaitInfo.data(),
                                    timeout, true /* do lock */);
    }
    return vkWaitSemaphores_VkResult_return;
}
VkResult gfxstream_vk_SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo) {
    AEMU_SCOPED_TRACE("vkSignalSemaphore");
    VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkSemaphoreSignalInfo> internal_pSignalInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pSignalInfo[i] = pSignalInfo[i];
            /* VkSemaphoreSignalInfo::semaphore */
            VK_FROM_HANDLE(gfxstream_vk_semaphore, gfxstream_semaphore,
                           internal_pSignalInfo[i].semaphore);
            internal_pSignalInfo[i].semaphore = gfxstream_semaphore->internal_object;
        }
        vkSignalSemaphore_VkResult_return = vkEnc->vkSignalSemaphore(
            gfxstream_device->internal_object, internal_pSignalInfo.data(), true /* do lock */);
    }
    return vkSignalSemaphore_VkResult_return;
}
VkDeviceAddress gfxstream_vk_GetBufferDeviceAddress(VkDevice device,
                                                    const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddress");
    VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferDeviceAddressInfo> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkBufferDeviceAddressInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pInfo[i].buffer);
            internal_pInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        vkGetBufferDeviceAddress_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddress(
            gfxstream_device->internal_object, internal_pInfo.data(), true /* do lock */);
    }
    return vkGetBufferDeviceAddress_VkDeviceAddress_return;
}
uint64_t gfxstream_vk_GetBufferOpaqueCaptureAddress(VkDevice device,
                                                    const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddress");
    uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferDeviceAddressInfo> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkBufferDeviceAddressInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pInfo[i].buffer);
            internal_pInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        vkGetBufferOpaqueCaptureAddress_uint64_t_return = vkEnc->vkGetBufferOpaqueCaptureAddress(
            gfxstream_device->internal_object, internal_pInfo.data(), true /* do lock */);
    }
    return vkGetBufferOpaqueCaptureAddress_uint64_t_return;
}
uint64_t gfxstream_vk_GetDeviceMemoryOpaqueCaptureAddress(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddress");
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDeviceMemoryOpaqueCaptureAddressInfo> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkDeviceMemoryOpaqueCaptureAddressInfo::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, internal_pInfo[i].memory);
            internal_pInfo[i].memory = gfxstream_memory->internal_object;
        }
        vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return =
            vkEnc->vkGetDeviceMemoryOpaqueCaptureAddress(gfxstream_device->internal_object,
                                                         internal_pInfo.data(), true /* do lock */);
    }
    return vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return;
}
#endif
#ifdef VK_VERSION_1_3
VkResult gfxstream_vk_GetPhysicalDeviceToolProperties(
    VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
    VkPhysicalDeviceToolProperties* pToolProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceToolProperties");
    VkResult vkGetPhysicalDeviceToolProperties_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetPhysicalDeviceToolProperties_VkResult_return =
            vkEnc->vkGetPhysicalDeviceToolProperties(gfxstream_physicalDevice->internal_object,
                                                     pToolCount, pToolProperties,
                                                     true /* do lock */);
    }
    return vkGetPhysicalDeviceToolProperties_VkResult_return;
}
VkResult gfxstream_vk_CreatePrivateDataSlot(VkDevice device,
                                            const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkPrivateDataSlot* pPrivateDataSlot) {
    AEMU_SCOPED_TRACE("vkCreatePrivateDataSlot");
    VkResult vkCreatePrivateDataSlot_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreatePrivateDataSlot_VkResult_return =
            vkEnc->vkCreatePrivateDataSlot(gfxstream_device->internal_object, pCreateInfo,
                                           pAllocator, pPrivateDataSlot, true /* do lock */);
    }
    return vkCreatePrivateDataSlot_VkResult_return;
}
void gfxstream_vk_DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                         const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPrivateDataSlot");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyPrivateDataSlot(gfxstream_device->internal_object, privateDataSlot,
                                        pAllocator, true /* do lock */);
    }
}
VkResult gfxstream_vk_SetPrivateData(VkDevice device, VkObjectType objectType,
                                     uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
                                     uint64_t data) {
    AEMU_SCOPED_TRACE("vkSetPrivateData");
    VkResult vkSetPrivateData_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkSetPrivateData_VkResult_return =
            vkEnc->vkSetPrivateData(gfxstream_device->internal_object, objectType, objectHandle,
                                    privateDataSlot, data, true /* do lock */);
    }
    return vkSetPrivateData_VkResult_return;
}
void gfxstream_vk_GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                 VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    AEMU_SCOPED_TRACE("vkGetPrivateData");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPrivateData(gfxstream_device->internal_object, objectType, objectHandle,
                                privateDataSlot, pData, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                               const VkDependencyInfo* pDependencyInfo) {
    AEMU_SCOPED_TRACE("vkCmdSetEvent2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkDependencyInfo> internal_pDependencyInfo(1);
        std::vector<std::vector<VkBufferMemoryBarrier2>>
            internal_VkDependencyInfo_pBufferMemoryBarriers;
        std::vector<std::vector<VkImageMemoryBarrier2>>
            internal_VkDependencyInfo_pImageMemoryBarriers;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pDependencyInfo[i] = pDependencyInfo[i];
            /* VkDependencyInfo::pBufferMemoryBarriers */
            internal_VkDependencyInfo_pBufferMemoryBarriers.push_back(
                std::vector<VkBufferMemoryBarrier2>());
            internal_VkDependencyInfo_pBufferMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pBufferMemoryBarriers[i][0], 0,
                   sizeof(VkBufferMemoryBarrier2) *
                       internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].bufferMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pBufferMemoryBarriers[j];
                /* VkBufferMemoryBarrier2::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer);
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer =
                    gfxstream_buffer->internal_object;
            }
            internal_pDependencyInfo[i].pBufferMemoryBarriers =
                internal_VkDependencyInfo_pBufferMemoryBarriers[i].data();
            /* VkDependencyInfo::pImageMemoryBarriers */
            internal_VkDependencyInfo_pImageMemoryBarriers.push_back(
                std::vector<VkImageMemoryBarrier2>());
            internal_VkDependencyInfo_pImageMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].imageMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pImageMemoryBarriers[i][0], 0,
                   sizeof(VkImageMemoryBarrier2) *
                       internal_pDependencyInfo[i].imageMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].imageMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pImageMemoryBarriers[j];
                /* VkImageMemoryBarrier2::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image);
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image =
                    gfxstream_image->internal_object;
            }
            internal_pDependencyInfo[i].pImageMemoryBarriers =
                internal_VkDependencyInfo_pImageMemoryBarriers[i].data();
        }
        vkEnc->vkCmdSetEvent2(gfxstream_commandBuffer->internal_object,
                              gfxstream_event->internal_object, internal_pDependencyInfo.data(),
                              true /* do lock */);
    }
}
void gfxstream_vk_CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                 VkPipelineStageFlags2 stageMask) {
    AEMU_SCOPED_TRACE("vkCmdResetEvent2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdResetEvent2(gfxstream_commandBuffer->internal_object,
                                gfxstream_event->internal_object, stageMask, true /* do lock */);
    }
}
void gfxstream_vk_CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                 const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
    AEMU_SCOPED_TRACE("vkCmdWaitEvents2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkEvent> internal_pEvents(eventCount);
        for (uint32_t i = 0; i < eventCount; ++i) {
            VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_pEvents, pEvents[i]);
            internal_pEvents[i] = gfxstream_pEvents->internal_object;
        }
        std::vector<VkDependencyInfo> internal_pDependencyInfos(eventCount);
        std::vector<std::vector<VkBufferMemoryBarrier2>>
            internal_VkDependencyInfo_pBufferMemoryBarriers;
        std::vector<std::vector<VkImageMemoryBarrier2>>
            internal_VkDependencyInfo_pImageMemoryBarriers;
        for (uint32_t i = 0; i < eventCount; ++i) {
            internal_pDependencyInfos[i] = pDependencyInfos[i];
            /* VkDependencyInfo::pBufferMemoryBarriers */
            internal_VkDependencyInfo_pBufferMemoryBarriers.push_back(
                std::vector<VkBufferMemoryBarrier2>());
            internal_VkDependencyInfo_pBufferMemoryBarriers[i].reserve(
                internal_pDependencyInfos[i].bufferMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pBufferMemoryBarriers[i][0], 0,
                   sizeof(VkBufferMemoryBarrier2) *
                       internal_pDependencyInfos[i].bufferMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfos[i].bufferMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j] =
                    internal_pDependencyInfos[i].pBufferMemoryBarriers[j];
                /* VkBufferMemoryBarrier2::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer);
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer =
                    gfxstream_buffer->internal_object;
            }
            internal_pDependencyInfos[i].pBufferMemoryBarriers =
                internal_VkDependencyInfo_pBufferMemoryBarriers[i].data();
            /* VkDependencyInfo::pImageMemoryBarriers */
            internal_VkDependencyInfo_pImageMemoryBarriers.push_back(
                std::vector<VkImageMemoryBarrier2>());
            internal_VkDependencyInfo_pImageMemoryBarriers[i].reserve(
                internal_pDependencyInfos[i].imageMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pImageMemoryBarriers[i][0], 0,
                   sizeof(VkImageMemoryBarrier2) *
                       internal_pDependencyInfos[i].imageMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfos[i].imageMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j] =
                    internal_pDependencyInfos[i].pImageMemoryBarriers[j];
                /* VkImageMemoryBarrier2::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image);
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image =
                    gfxstream_image->internal_object;
            }
            internal_pDependencyInfos[i].pImageMemoryBarriers =
                internal_VkDependencyInfo_pImageMemoryBarriers[i].data();
        }
        vkEnc->vkCmdWaitEvents2(gfxstream_commandBuffer->internal_object, eventCount,
                                internal_pEvents.data(), internal_pDependencyInfos.data(),
                                true /* do lock */);
    }
}
void gfxstream_vk_CmdPipelineBarrier2(VkCommandBuffer commandBuffer,
                                      const VkDependencyInfo* pDependencyInfo) {
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkDependencyInfo> internal_pDependencyInfo(1);
        std::vector<std::vector<VkBufferMemoryBarrier2>>
            internal_VkDependencyInfo_pBufferMemoryBarriers;
        std::vector<std::vector<VkImageMemoryBarrier2>>
            internal_VkDependencyInfo_pImageMemoryBarriers;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pDependencyInfo[i] = pDependencyInfo[i];
            /* VkDependencyInfo::pBufferMemoryBarriers */
            internal_VkDependencyInfo_pBufferMemoryBarriers.push_back(
                std::vector<VkBufferMemoryBarrier2>());
            internal_VkDependencyInfo_pBufferMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pBufferMemoryBarriers[i][0], 0,
                   sizeof(VkBufferMemoryBarrier2) *
                       internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].bufferMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pBufferMemoryBarriers[j];
                /* VkBufferMemoryBarrier2::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer);
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer =
                    gfxstream_buffer->internal_object;
            }
            internal_pDependencyInfo[i].pBufferMemoryBarriers =
                internal_VkDependencyInfo_pBufferMemoryBarriers[i].data();
            /* VkDependencyInfo::pImageMemoryBarriers */
            internal_VkDependencyInfo_pImageMemoryBarriers.push_back(
                std::vector<VkImageMemoryBarrier2>());
            internal_VkDependencyInfo_pImageMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].imageMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pImageMemoryBarriers[i][0], 0,
                   sizeof(VkImageMemoryBarrier2) *
                       internal_pDependencyInfo[i].imageMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].imageMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pImageMemoryBarriers[j];
                /* VkImageMemoryBarrier2::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image);
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image =
                    gfxstream_image->internal_object;
            }
            internal_pDependencyInfo[i].pImageMemoryBarriers =
                internal_VkDependencyInfo_pImageMemoryBarriers[i].data();
        }
        vkEnc->vkCmdPipelineBarrier2(gfxstream_commandBuffer->internal_object,
                                     internal_pDependencyInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                     VkQueryPool queryPool, uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdWriteTimestamp2(gfxstream_commandBuffer->internal_object, stage,
                                    gfxstream_queryPool->internal_object, query,
                                    true /* do lock */);
    }
}
VkResult gfxstream_vk_QueueSubmit2(VkQueue queue, uint32_t submitCount,
                                   const VkSubmitInfo2* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmit2");
    VkResult vkQueueSubmit2_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSubmitInfo2> internal_pSubmits(submitCount);
        std::vector<std::vector<VkSemaphoreSubmitInfo>> internal_VkSubmitInfo2_pWaitSemaphoreInfos;
        std::vector<std::vector<VkCommandBufferSubmitInfo>>
            internal_VkSubmitInfo2_pCommandBufferInfos;
        std::vector<std::vector<VkSemaphoreSubmitInfo>>
            internal_VkSubmitInfo2_pSignalSemaphoreInfos;
        for (uint32_t i = 0; i < submitCount; ++i) {
            internal_pSubmits[i] = pSubmits[i];
            /* VkSubmitInfo2::pWaitSemaphoreInfos */
            internal_VkSubmitInfo2_pWaitSemaphoreInfos.push_back(
                std::vector<VkSemaphoreSubmitInfo>());
            internal_VkSubmitInfo2_pWaitSemaphoreInfos[i] =
                transformVkSemaphoreSubmitInfoList(internal_pSubmits[i].pWaitSemaphoreInfos,
                                                   internal_pSubmits[i].waitSemaphoreInfoCount);
            internal_pSubmits[i].pWaitSemaphoreInfos =
                internal_VkSubmitInfo2_pWaitSemaphoreInfos[i].data();
            internal_pSubmits[i].waitSemaphoreInfoCount =
                internal_VkSubmitInfo2_pWaitSemaphoreInfos[i].size();
            /* VkSubmitInfo2::pCommandBufferInfos */
            internal_VkSubmitInfo2_pCommandBufferInfos.push_back(
                std::vector<VkCommandBufferSubmitInfo>());
            internal_VkSubmitInfo2_pCommandBufferInfos[i].reserve(
                internal_pSubmits[i].commandBufferInfoCount);
            memset(&internal_VkSubmitInfo2_pCommandBufferInfos[i][0], 0,
                   sizeof(VkCommandBufferSubmitInfo) * internal_pSubmits[i].commandBufferInfoCount);
            for (uint32_t j = 0; j < internal_pSubmits[i].commandBufferInfoCount; ++j) {
                internal_VkSubmitInfo2_pCommandBufferInfos[i][j] =
                    internal_pSubmits[i].pCommandBufferInfos[j];
                /* VkCommandBufferSubmitInfo::commandBuffer */
                VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer,
                               internal_VkSubmitInfo2_pCommandBufferInfos[i][j].commandBuffer);
                internal_VkSubmitInfo2_pCommandBufferInfos[i][j].commandBuffer =
                    gfxstream_commandBuffer->internal_object;
            }
            internal_pSubmits[i].pCommandBufferInfos =
                internal_VkSubmitInfo2_pCommandBufferInfos[i].data();
            /* VkSubmitInfo2::pSignalSemaphoreInfos */
            internal_VkSubmitInfo2_pSignalSemaphoreInfos.push_back(
                std::vector<VkSemaphoreSubmitInfo>());
            internal_VkSubmitInfo2_pSignalSemaphoreInfos[i] =
                transformVkSemaphoreSubmitInfoList(internal_pSubmits[i].pSignalSemaphoreInfos,
                                                   internal_pSubmits[i].signalSemaphoreInfoCount);
            internal_pSubmits[i].pSignalSemaphoreInfos =
                internal_VkSubmitInfo2_pSignalSemaphoreInfos[i].data();
            internal_pSubmits[i].signalSemaphoreInfoCount =
                internal_VkSubmitInfo2_pSignalSemaphoreInfos[i].size();
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkQueueSubmit2_VkResult_return = resources->on_vkQueueSubmit2(
            vkEnc, VK_SUCCESS, gfxstream_queue->internal_object, submitCount,
            internal_pSubmits.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE);
    }
    return vkQueueSubmit2_VkResult_return;
}
void gfxstream_vk_CmdCopyBuffer2(VkCommandBuffer commandBuffer,
                                 const VkCopyBufferInfo2* pCopyBufferInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyBufferInfo2> internal_pCopyBufferInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyBufferInfo[i] = pCopyBufferInfo[i];
            /* VkCopyBufferInfo2::srcBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_srcBuffer,
                           internal_pCopyBufferInfo[i].srcBuffer);
            internal_pCopyBufferInfo[i].srcBuffer = gfxstream_srcBuffer->internal_object;
            /* VkCopyBufferInfo2::dstBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer,
                           internal_pCopyBufferInfo[i].dstBuffer);
            internal_pCopyBufferInfo[i].dstBuffer = gfxstream_dstBuffer->internal_object;
        }
        vkEnc->vkCmdCopyBuffer2(gfxstream_commandBuffer->internal_object,
                                internal_pCopyBufferInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyImage2(VkCommandBuffer commandBuffer,
                                const VkCopyImageInfo2* pCopyImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyImage2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyImageInfo2> internal_pCopyImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyImageInfo[i] = pCopyImageInfo[i];
            /* VkCopyImageInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pCopyImageInfo[i].srcImage);
            internal_pCopyImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkCopyImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pCopyImageInfo[i].dstImage);
            internal_pCopyImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdCopyImage2(gfxstream_commandBuffer->internal_object,
                               internal_pCopyImageInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
                                        const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyBufferToImageInfo2> internal_pCopyBufferToImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyBufferToImageInfo[i] = pCopyBufferToImageInfo[i];
            /* VkCopyBufferToImageInfo2::srcBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_srcBuffer,
                           internal_pCopyBufferToImageInfo[i].srcBuffer);
            internal_pCopyBufferToImageInfo[i].srcBuffer = gfxstream_srcBuffer->internal_object;
            /* VkCopyBufferToImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pCopyBufferToImageInfo[i].dstImage);
            internal_pCopyBufferToImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdCopyBufferToImage2(gfxstream_commandBuffer->internal_object,
                                       internal_pCopyBufferToImageInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
                                        const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyImageToBufferInfo2> internal_pCopyImageToBufferInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyImageToBufferInfo[i] = pCopyImageToBufferInfo[i];
            /* VkCopyImageToBufferInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pCopyImageToBufferInfo[i].srcImage);
            internal_pCopyImageToBufferInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkCopyImageToBufferInfo2::dstBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer,
                           internal_pCopyImageToBufferInfo[i].dstBuffer);
            internal_pCopyImageToBufferInfo[i].dstBuffer = gfxstream_dstBuffer->internal_object;
        }
        vkEnc->vkCmdCopyImageToBuffer2(gfxstream_commandBuffer->internal_object,
                                       internal_pCopyImageToBufferInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdBlitImage2(VkCommandBuffer commandBuffer,
                                const VkBlitImageInfo2* pBlitImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdBlitImage2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBlitImageInfo2> internal_pBlitImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pBlitImageInfo[i] = pBlitImageInfo[i];
            /* VkBlitImageInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pBlitImageInfo[i].srcImage);
            internal_pBlitImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkBlitImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pBlitImageInfo[i].dstImage);
            internal_pBlitImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdBlitImage2(gfxstream_commandBuffer->internal_object,
                               internal_pBlitImageInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdResolveImage2(VkCommandBuffer commandBuffer,
                                   const VkResolveImageInfo2* pResolveImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdResolveImage2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkResolveImageInfo2> internal_pResolveImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pResolveImageInfo[i] = pResolveImageInfo[i];
            /* VkResolveImageInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pResolveImageInfo[i].srcImage);
            internal_pResolveImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkResolveImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pResolveImageInfo[i].dstImage);
            internal_pResolveImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdResolveImage2(gfxstream_commandBuffer->internal_object,
                                  internal_pResolveImageInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdBeginRendering(VkCommandBuffer commandBuffer,
                                    const VkRenderingInfo* pRenderingInfo) {
    AEMU_SCOPED_TRACE("vkCmdBeginRendering");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkRenderingInfo> internal_pRenderingInfo(1);
        std::vector<std::vector<VkRenderingAttachmentInfo>>
            internal_VkRenderingInfo_pColorAttachments;
        std::vector<VkRenderingAttachmentInfo> internal_VkRenderingInfo_pDepthAttachment;
        std::vector<VkRenderingAttachmentInfo> internal_VkRenderingInfo_pStencilAttachment;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pRenderingInfo[i] = pRenderingInfo[i];
            /* VkRenderingInfo::pColorAttachments */
            internal_VkRenderingInfo_pColorAttachments.push_back(
                std::vector<VkRenderingAttachmentInfo>());
            internal_VkRenderingInfo_pColorAttachments[i].reserve(
                internal_pRenderingInfo[i].colorAttachmentCount);
            memset(&internal_VkRenderingInfo_pColorAttachments[i][0], 0,
                   sizeof(VkRenderingAttachmentInfo) *
                       internal_pRenderingInfo[i].colorAttachmentCount);
            for (uint32_t j = 0; j < internal_pRenderingInfo[i].colorAttachmentCount; ++j) {
                internal_VkRenderingInfo_pColorAttachments[i][j] =
                    internal_pRenderingInfo[i].pColorAttachments[j];
                /* VkRenderingAttachmentInfo::imageView */
                if (internal_VkRenderingInfo_pColorAttachments[i][j].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_VkRenderingInfo_pColorAttachments[i][j].imageView);
                    internal_VkRenderingInfo_pColorAttachments[i][j].imageView =
                        gfxstream_imageView->internal_object;
                }
                /* VkRenderingAttachmentInfo::resolveImageView */
                if (internal_VkRenderingInfo_pColorAttachments[i][j].resolveImageView) {
                    VK_FROM_HANDLE(
                        gfxstream_vk_image_view, gfxstream_resolveImageView,
                        internal_VkRenderingInfo_pColorAttachments[i][j].resolveImageView);
                    internal_VkRenderingInfo_pColorAttachments[i][j].resolveImageView =
                        gfxstream_resolveImageView->internal_object;
                }
            }
            internal_pRenderingInfo[i].pColorAttachments =
                internal_VkRenderingInfo_pColorAttachments[i].data();
            /* VkRenderingInfo::pDepthAttachment */
            if (internal_pRenderingInfo[i].pDepthAttachment) {
                internal_VkRenderingInfo_pDepthAttachment[i] =
                    internal_pRenderingInfo[i].pDepthAttachment[0];
                /* VkRenderingAttachmentInfo::imageView */
                if (internal_VkRenderingInfo_pDepthAttachment[i].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_VkRenderingInfo_pDepthAttachment[i].imageView);
                    internal_VkRenderingInfo_pDepthAttachment[i].imageView =
                        gfxstream_imageView->internal_object;
                }
                /* VkRenderingAttachmentInfo::resolveImageView */
                if (internal_VkRenderingInfo_pDepthAttachment[i].resolveImageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_resolveImageView,
                                   internal_VkRenderingInfo_pDepthAttachment[i].resolveImageView);
                    internal_VkRenderingInfo_pDepthAttachment[i].resolveImageView =
                        gfxstream_resolveImageView->internal_object;
                }
                internal_pRenderingInfo[i].pDepthAttachment =
                    &internal_VkRenderingInfo_pDepthAttachment[i];
            }
            /* VkRenderingInfo::pStencilAttachment */
            if (internal_pRenderingInfo[i].pStencilAttachment) {
                internal_VkRenderingInfo_pStencilAttachment[i] =
                    internal_pRenderingInfo[i].pStencilAttachment[0];
                /* VkRenderingAttachmentInfo::imageView */
                if (internal_VkRenderingInfo_pStencilAttachment[i].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_VkRenderingInfo_pStencilAttachment[i].imageView);
                    internal_VkRenderingInfo_pStencilAttachment[i].imageView =
                        gfxstream_imageView->internal_object;
                }
                /* VkRenderingAttachmentInfo::resolveImageView */
                if (internal_VkRenderingInfo_pStencilAttachment[i].resolveImageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_resolveImageView,
                                   internal_VkRenderingInfo_pStencilAttachment[i].resolveImageView);
                    internal_VkRenderingInfo_pStencilAttachment[i].resolveImageView =
                        gfxstream_resolveImageView->internal_object;
                }
                internal_pRenderingInfo[i].pStencilAttachment =
                    &internal_VkRenderingInfo_pStencilAttachment[i];
            }
        }
        vkEnc->vkCmdBeginRendering(gfxstream_commandBuffer->internal_object,
                                   internal_pRenderingInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdEndRendering(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkCmdEndRendering");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndRendering(gfxstream_commandBuffer->internal_object, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    AEMU_SCOPED_TRACE("vkCmdSetCullMode");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetCullMode(gfxstream_commandBuffer->internal_object, cullMode,
                                true /* do lock */);
    }
}
void gfxstream_vk_CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    AEMU_SCOPED_TRACE("vkCmdSetFrontFace");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetFrontFace(gfxstream_commandBuffer->internal_object, frontFace,
                                 true /* do lock */);
    }
}
void gfxstream_vk_CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer,
                                          VkPrimitiveTopology primitiveTopology) {
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveTopology");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetPrimitiveTopology(gfxstream_commandBuffer->internal_object,
                                         primitiveTopology, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                          const VkViewport* pViewports) {
    AEMU_SCOPED_TRACE("vkCmdSetViewportWithCount");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetViewportWithCount(gfxstream_commandBuffer->internal_object, viewportCount,
                                         pViewports, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                         const VkRect2D* pScissors) {
    AEMU_SCOPED_TRACE("vkCmdSetScissorWithCount");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetScissorWithCount(gfxstream_commandBuffer->internal_object, scissorCount,
                                        pScissors, true /* do lock */);
    }
}
void gfxstream_vk_CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                        uint32_t bindingCount, const VkBuffer* pBuffers,
                                        const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                        const VkDeviceSize* pStrides) {
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers2");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBuffer> internal_pBuffers(bindingCount);
        for (uint32_t i = 0; i < bindingCount; ++i) {
            if (pBuffers) {
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_pBuffers, pBuffers[i]);
                internal_pBuffers[i] = gfxstream_pBuffers->internal_object;
            }
        }
        vkEnc->vkCmdBindVertexBuffers2(gfxstream_commandBuffer->internal_object, firstBinding,
                                       bindingCount, internal_pBuffers.data(), pOffsets, pSizes,
                                       pStrides, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthTestEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthTestEnable(gfxstream_commandBuffer->internal_object, depthTestEnable,
                                       true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthWriteEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthWriteEnable(gfxstream_commandBuffer->internal_object, depthWriteEnable,
                                        true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthCompareOp");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthCompareOp(gfxstream_commandBuffer->internal_object, depthCompareOp,
                                      true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer,
                                              VkBool32 depthBoundsTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBoundsTestEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthBoundsTestEnable(gfxstream_commandBuffer->internal_object,
                                             depthBoundsTestEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilTestEnable(VkCommandBuffer commandBuffer,
                                          VkBool32 stencilTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilTestEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilTestEnable(gfxstream_commandBuffer->internal_object,
                                         stencilTestEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                  VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
                                  VkCompareOp compareOp) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilOp");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilOp(gfxstream_commandBuffer->internal_object, faceMask, failOp, passOp,
                                 depthFailOp, compareOp, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer,
                                                VkBool32 rasterizerDiscardEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetRasterizerDiscardEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetRasterizerDiscardEnable(gfxstream_commandBuffer->internal_object,
                                               rasterizerDiscardEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBiasEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthBiasEnable(gfxstream_commandBuffer->internal_object, depthBiasEnable,
                                       true /* do lock */);
    }
}
void gfxstream_vk_CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer,
                                               VkBool32 primitiveRestartEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveRestartEnable");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetPrimitiveRestartEnable(gfxstream_commandBuffer->internal_object,
                                              primitiveRestartEnable, true /* do lock */);
    }
}
void gfxstream_vk_GetDeviceBufferMemoryRequirements(VkDevice device,
                                                    const VkDeviceBufferMemoryRequirements* pInfo,
                                                    VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceBufferMemoryRequirements");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceBufferMemoryRequirements(gfxstream_device->internal_object, pInfo,
                                                   pMemoryRequirements, true /* do lock */);
    }
}
void gfxstream_vk_GetDeviceImageMemoryRequirements(VkDevice device,
                                                   const VkDeviceImageMemoryRequirements* pInfo,
                                                   VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageMemoryRequirements");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceImageMemoryRequirements(gfxstream_device->internal_object, pInfo,
                                                  pMemoryRequirements, true /* do lock */);
    }
}
void gfxstream_vk_GetDeviceImageSparseMemoryRequirements(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageSparseMemoryRequirements");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceImageSparseMemoryRequirements(
            gfxstream_device->internal_object, pInfo, pSparseMemoryRequirementCount,
            pSparseMemoryRequirements, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_surface
#endif
#ifdef VK_KHR_swapchain
#endif
#ifdef VK_KHR_xcb_surface
#endif
#ifdef VK_KHR_android_surface
VkResult gfxstream_vk_CreateAndroidSurfaceKHR(VkInstance instance,
                                              const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator,
                                              VkSurfaceKHR* pSurface) {
    AEMU_SCOPED_TRACE("vkCreateAndroidSurfaceKHR");
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_instance, gfxstream_instance, instance);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateAndroidSurfaceKHR_VkResult_return =
            vkEnc->vkCreateAndroidSurfaceKHR(gfxstream_instance->internal_object, pCreateInfo,
                                             pAllocator, pSurface, true /* do lock */);
    }
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_win32_surface
#endif
#ifdef VK_KHR_dynamic_rendering
void gfxstream_vk_CmdBeginRenderingKHR(VkCommandBuffer commandBuffer,
                                       const VkRenderingInfo* pRenderingInfo) {
    AEMU_SCOPED_TRACE("vkCmdBeginRenderingKHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkRenderingInfo> internal_pRenderingInfo(1);
        std::vector<std::vector<VkRenderingAttachmentInfo>>
            internal_VkRenderingInfo_pColorAttachments;
        std::vector<VkRenderingAttachmentInfo> internal_VkRenderingInfo_pDepthAttachment;
        std::vector<VkRenderingAttachmentInfo> internal_VkRenderingInfo_pStencilAttachment;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pRenderingInfo[i] = pRenderingInfo[i];
            /* VkRenderingInfo::pColorAttachments */
            internal_VkRenderingInfo_pColorAttachments.push_back(
                std::vector<VkRenderingAttachmentInfo>());
            internal_VkRenderingInfo_pColorAttachments[i].reserve(
                internal_pRenderingInfo[i].colorAttachmentCount);
            memset(&internal_VkRenderingInfo_pColorAttachments[i][0], 0,
                   sizeof(VkRenderingAttachmentInfo) *
                       internal_pRenderingInfo[i].colorAttachmentCount);
            for (uint32_t j = 0; j < internal_pRenderingInfo[i].colorAttachmentCount; ++j) {
                internal_VkRenderingInfo_pColorAttachments[i][j] =
                    internal_pRenderingInfo[i].pColorAttachments[j];
                /* VkRenderingAttachmentInfo::imageView */
                if (internal_VkRenderingInfo_pColorAttachments[i][j].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_VkRenderingInfo_pColorAttachments[i][j].imageView);
                    internal_VkRenderingInfo_pColorAttachments[i][j].imageView =
                        gfxstream_imageView->internal_object;
                }
                /* VkRenderingAttachmentInfo::resolveImageView */
                if (internal_VkRenderingInfo_pColorAttachments[i][j].resolveImageView) {
                    VK_FROM_HANDLE(
                        gfxstream_vk_image_view, gfxstream_resolveImageView,
                        internal_VkRenderingInfo_pColorAttachments[i][j].resolveImageView);
                    internal_VkRenderingInfo_pColorAttachments[i][j].resolveImageView =
                        gfxstream_resolveImageView->internal_object;
                }
            }
            internal_pRenderingInfo[i].pColorAttachments =
                internal_VkRenderingInfo_pColorAttachments[i].data();
            /* VkRenderingInfo::pDepthAttachment */
            if (internal_pRenderingInfo[i].pDepthAttachment) {
                internal_VkRenderingInfo_pDepthAttachment[i] =
                    internal_pRenderingInfo[i].pDepthAttachment[0];
                /* VkRenderingAttachmentInfo::imageView */
                if (internal_VkRenderingInfo_pDepthAttachment[i].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_VkRenderingInfo_pDepthAttachment[i].imageView);
                    internal_VkRenderingInfo_pDepthAttachment[i].imageView =
                        gfxstream_imageView->internal_object;
                }
                /* VkRenderingAttachmentInfo::resolveImageView */
                if (internal_VkRenderingInfo_pDepthAttachment[i].resolveImageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_resolveImageView,
                                   internal_VkRenderingInfo_pDepthAttachment[i].resolveImageView);
                    internal_VkRenderingInfo_pDepthAttachment[i].resolveImageView =
                        gfxstream_resolveImageView->internal_object;
                }
                internal_pRenderingInfo[i].pDepthAttachment =
                    &internal_VkRenderingInfo_pDepthAttachment[i];
            }
            /* VkRenderingInfo::pStencilAttachment */
            if (internal_pRenderingInfo[i].pStencilAttachment) {
                internal_VkRenderingInfo_pStencilAttachment[i] =
                    internal_pRenderingInfo[i].pStencilAttachment[0];
                /* VkRenderingAttachmentInfo::imageView */
                if (internal_VkRenderingInfo_pStencilAttachment[i].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_VkRenderingInfo_pStencilAttachment[i].imageView);
                    internal_VkRenderingInfo_pStencilAttachment[i].imageView =
                        gfxstream_imageView->internal_object;
                }
                /* VkRenderingAttachmentInfo::resolveImageView */
                if (internal_VkRenderingInfo_pStencilAttachment[i].resolveImageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_resolveImageView,
                                   internal_VkRenderingInfo_pStencilAttachment[i].resolveImageView);
                    internal_VkRenderingInfo_pStencilAttachment[i].resolveImageView =
                        gfxstream_resolveImageView->internal_object;
                }
                internal_pRenderingInfo[i].pStencilAttachment =
                    &internal_VkRenderingInfo_pStencilAttachment[i];
            }
        }
        vkEnc->vkCmdBeginRenderingKHR(gfxstream_commandBuffer->internal_object,
                                      internal_pRenderingInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdEndRenderingKHR(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderingKHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndRenderingKHR(gfxstream_commandBuffer->internal_object, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void gfxstream_vk_GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice,
                                                VkPhysicalDeviceFeatures2* pFeatures) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2KHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceFeatures2KHR(gfxstream_physicalDevice->internal_object, pFeatures,
                                               true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice,
                                                  VkPhysicalDeviceProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2KHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceProperties2KHR(gfxstream_physicalDevice->internal_object,
                                                 pProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice,
                                                        VkFormat format,
                                                        VkFormatProperties2* pFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2KHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceFormatProperties2KHR(gfxstream_physicalDevice->internal_object,
                                                       format, pFormatProperties,
                                                       true /* do lock */);
    }
}
VkResult gfxstream_vk_GetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2KHR");
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return =
            resources->on_vkGetPhysicalDeviceImageFormatProperties2KHR(
                vkEnc, VK_SUCCESS, gfxstream_physicalDevice->internal_object, pImageFormatInfo,
                pImageFormatProperties);
    }
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}
void gfxstream_vk_GetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2KHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceQueueFamilyProperties2KHR(
            gfxstream_physicalDevice->internal_object, pQueueFamilyPropertyCount,
            pQueueFamilyProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2KHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceMemoryProperties2KHR(gfxstream_physicalDevice->internal_object,
                                                       pMemoryProperties, true /* do lock */);
    }
}
void gfxstream_vk_GetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
            gfxstream_physicalDevice->internal_object, pFormatInfo, pPropertyCount, pProperties,
            true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_maintenance1
void gfxstream_vk_TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool,
                                     VkCommandPoolTrimFlags flags) {
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_command_pool, gfxstream_commandPool, commandPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkTrimCommandPoolKHR(gfxstream_device->internal_object,
                                    gfxstream_commandPool->internal_object, flags,
                                    true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_external_memory_capabilities
void gfxstream_vk_GetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferPropertiesKHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
            vkEnc, gfxstream_physicalDevice->internal_object, pExternalBufferInfo,
            pExternalBufferProperties);
    }
}
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
#endif
#ifdef VK_KHR_external_memory_fd
VkResult gfxstream_vk_GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo,
                                     int* pFd) {
    AEMU_SCOPED_TRACE("vkGetMemoryFdKHR");
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkMemoryGetFdInfoKHR> internal_pGetFdInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pGetFdInfo[i] = pGetFdInfo[i];
            /* VkMemoryGetFdInfoKHR::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                           internal_pGetFdInfo[i].memory);
            internal_pGetFdInfo[i].memory = gfxstream_memory->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetMemoryFdKHR_VkResult_return = resources->on_vkGetMemoryFdKHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, internal_pGetFdInfo.data(), pFd);
    }
    return vkGetMemoryFdKHR_VkResult_return;
}
VkResult gfxstream_vk_GetMemoryFdPropertiesKHR(VkDevice device,
                                               VkExternalMemoryHandleTypeFlagBits handleType,
                                               int fd,
                                               VkMemoryFdPropertiesKHR* pMemoryFdProperties) {
    AEMU_SCOPED_TRACE("vkGetMemoryFdPropertiesKHR");
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetMemoryFdPropertiesKHR_VkResult_return = resources->on_vkGetMemoryFdPropertiesKHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, handleType, fd,
            pMemoryFdProperties);
    }
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void gfxstream_vk_GetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
            gfxstream_physicalDevice->internal_object, pExternalSemaphoreInfo,
            pExternalSemaphoreProperties, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
#endif
#ifdef VK_KHR_external_semaphore_fd
VkResult gfxstream_vk_ImportSemaphoreFdKHR(
    VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR");
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImportSemaphoreFdInfoKHR> internal_pImportSemaphoreFdInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pImportSemaphoreFdInfo[i] = pImportSemaphoreFdInfo[i];
            /* VkImportSemaphoreFdInfoKHR::semaphore */
            VK_FROM_HANDLE(gfxstream_vk_semaphore, gfxstream_semaphore,
                           internal_pImportSemaphoreFdInfo[i].semaphore);
            internal_pImportSemaphoreFdInfo[i].semaphore = gfxstream_semaphore->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkImportSemaphoreFdKHR_VkResult_return = resources->on_vkImportSemaphoreFdKHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
            internal_pImportSemaphoreFdInfo.data());
    }
    return vkImportSemaphoreFdKHR_VkResult_return;
}
VkResult gfxstream_vk_GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
                                        int* pFd) {
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR");
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkSemaphoreGetFdInfoKHR> internal_pGetFdInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pGetFdInfo[i] = pGetFdInfo[i];
            /* VkSemaphoreGetFdInfoKHR::semaphore */
            VK_FROM_HANDLE(gfxstream_vk_semaphore, gfxstream_semaphore,
                           internal_pGetFdInfo[i].semaphore);
            internal_pGetFdInfo[i].semaphore = gfxstream_semaphore->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetSemaphoreFdKHR_VkResult_return = resources->on_vkGetSemaphoreFdKHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, internal_pGetFdInfo.data(), pFd);
    }
    return vkGetSemaphoreFdKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
VkResult gfxstream_vk_CreateDescriptorUpdateTemplateKHR(
    VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR");
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_descriptor_update_template* gfxstream_pDescriptorUpdateTemplate =
        (gfxstream_vk_descriptor_update_template*)vk_object_zalloc(
            &gfxstream_device->vk, pAllocator, sizeof(gfxstream_vk_descriptor_update_template),
            VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE);
    vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
        gfxstream_pDescriptorUpdateTemplate ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateDescriptorUpdateTemplateKHR_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDescriptorUpdateTemplateCreateInfo> internal_pCreateInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCreateInfo[i] = pCreateInfo[i];
            /* VkDescriptorUpdateTemplateCreateInfo::descriptorSetLayout */
            if (internal_pCreateInfo[i].descriptorSetLayout) {
                VK_FROM_HANDLE(gfxstream_vk_descriptor_set_layout, gfxstream_descriptorSetLayout,
                               internal_pCreateInfo[i].descriptorSetLayout);
                internal_pCreateInfo[i].descriptorSetLayout =
                    gfxstream_descriptorSetLayout->internal_object;
            }
            /* VkDescriptorUpdateTemplateCreateInfo::pipelineLayout */
            if (internal_pCreateInfo[i].pipelineLayout) {
                VK_FROM_HANDLE(gfxstream_vk_pipeline_layout, gfxstream_pipelineLayout,
                               internal_pCreateInfo[i].pipelineLayout);
                internal_pCreateInfo[i].pipelineLayout = gfxstream_pipelineLayout->internal_object;
            }
        }
        vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
            vkEnc->vkCreateDescriptorUpdateTemplateKHR(
                gfxstream_device->internal_object, internal_pCreateInfo.data(), pAllocator,
                &gfxstream_pDescriptorUpdateTemplate->internal_object, true /* do lock */);
    }
    *pDescriptorUpdateTemplate =
        gfxstream_vk_descriptor_update_template_to_handle(gfxstream_pDescriptorUpdateTemplate);
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}
void gfxstream_vk_DestroyDescriptorUpdateTemplateKHR(
    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR");
    if (VK_NULL_HANDLE == descriptorUpdateTemplate) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_update_template, gfxstream_descriptorUpdateTemplate,
                   descriptorUpdateTemplate);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyDescriptorUpdateTemplateKHR(
            gfxstream_device->internal_object,
            gfxstream_descriptorUpdateTemplate ? gfxstream_descriptorUpdateTemplate->internal_object
                                               : VK_NULL_HANDLE,
            pAllocator, true /* do lock */);
    }
    vk_object_free(&gfxstream_device->vk, pAllocator, (void*)gfxstream_descriptorUpdateTemplate);
}
void gfxstream_vk_UpdateDescriptorSetWithTemplateKHR(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_update_template, gfxstream_descriptorUpdateTemplate,
                   descriptorUpdateTemplate);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkUpdateDescriptorSetWithTemplateKHR(
            vkEnc, gfxstream_device->internal_object, descriptorSet,
            gfxstream_descriptorUpdateTemplate->internal_object, pData);
    }
}
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
VkResult gfxstream_vk_CreateRenderPass2KHR(VkDevice device,
                                           const VkRenderPassCreateInfo2* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkRenderPass* pRenderPass) {
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR");
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_render_pass* gfxstream_pRenderPass =
        (gfxstream_vk_render_pass*)vk_object_zalloc(&gfxstream_device->vk, pAllocator,
                                                    sizeof(gfxstream_vk_render_pass),
                                                    VK_OBJECT_TYPE_RENDER_PASS);
    vkCreateRenderPass2KHR_VkResult_return =
        gfxstream_pRenderPass ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateRenderPass2KHR_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateRenderPass2KHR_VkResult_return = vkEnc->vkCreateRenderPass2KHR(
            gfxstream_device->internal_object, pCreateInfo, pAllocator,
            &gfxstream_pRenderPass->internal_object, true /* do lock */);
    }
    *pRenderPass = gfxstream_vk_render_pass_to_handle(gfxstream_pRenderPass);
    return vkCreateRenderPass2KHR_VkResult_return;
}
void gfxstream_vk_CmdNextSubpass2KHR(VkCommandBuffer commandBuffer,
                                     const VkSubpassBeginInfo* pSubpassBeginInfo,
                                     const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdNextSubpass2KHR(gfxstream_commandBuffer->internal_object, pSubpassBeginInfo,
                                    pSubpassEndInfo, true /* do lock */);
    }
}
void gfxstream_vk_CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer,
                                       const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndRenderPass2KHR(gfxstream_commandBuffer->internal_object, pSubpassEndInfo,
                                      true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_external_fence_capabilities
void gfxstream_vk_GetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFencePropertiesKHR");
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetPhysicalDeviceExternalFencePropertiesKHR(
            vkEnc, gfxstream_physicalDevice->internal_object, pExternalFenceInfo,
            pExternalFenceProperties);
    }
}
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_fd
VkResult gfxstream_vk_ImportFenceFdKHR(VkDevice device,
                                       const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR");
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImportFenceFdInfoKHR> internal_pImportFenceFdInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pImportFenceFdInfo[i] = pImportFenceFdInfo[i];
            /* VkImportFenceFdInfoKHR::fence */
            VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence,
                           internal_pImportFenceFdInfo[i].fence);
            internal_pImportFenceFdInfo[i].fence = gfxstream_fence->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkImportFenceFdKHR_VkResult_return =
            resources->on_vkImportFenceFdKHR(vkEnc, VK_SUCCESS, gfxstream_device->internal_object,
                                             internal_pImportFenceFdInfo.data());
    }
    return vkImportFenceFdKHR_VkResult_return;
}
VkResult gfxstream_vk_GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo,
                                    int* pFd) {
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR");
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkFenceGetFdInfoKHR> internal_pGetFdInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pGetFdInfo[i] = pGetFdInfo[i];
            /* VkFenceGetFdInfoKHR::fence */
            VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, internal_pGetFdInfo[i].fence);
            internal_pGetFdInfo[i].fence = gfxstream_fence->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetFenceFdKHR_VkResult_return = resources->on_vkGetFenceFdKHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, internal_pGetFdInfo.data(), pFd);
    }
    return vkGetFenceFdKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_get_memory_requirements2
void gfxstream_vk_GetImageMemoryRequirements2KHR(VkDevice device,
                                                 const VkImageMemoryRequirementsInfo2* pInfo,
                                                 VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImageMemoryRequirementsInfo2> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkImageMemoryRequirementsInfo2::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pInfo[i].image);
            internal_pInfo[i].image = gfxstream_image->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetImageMemoryRequirements2KHR(vkEnc, gfxstream_device->internal_object,
                                                       internal_pInfo.data(), pMemoryRequirements);
    }
}
void gfxstream_vk_GetBufferMemoryRequirements2KHR(VkDevice device,
                                                  const VkBufferMemoryRequirementsInfo2* pInfo,
                                                  VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferMemoryRequirementsInfo2> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkBufferMemoryRequirementsInfo2::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pInfo[i].buffer);
            internal_pInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkGetBufferMemoryRequirements2KHR(vkEnc, gfxstream_device->internal_object,
                                                        internal_pInfo.data(), pMemoryRequirements);
    }
}
void gfxstream_vk_GetImageSparseMemoryRequirements2KHR(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkImageSparseMemoryRequirementsInfo2> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkImageSparseMemoryRequirementsInfo2::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pInfo[i].image);
            internal_pInfo[i].image = gfxstream_image->internal_object;
        }
        vkEnc->vkGetImageSparseMemoryRequirements2KHR(
            gfxstream_device->internal_object, internal_pInfo.data(), pSparseMemoryRequirementCount,
            pSparseMemoryRequirements, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult gfxstream_vk_CreateSamplerYcbcrConversionKHR(
    VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR");
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkCreateSamplerYcbcrConversionKHR_VkResult_return =
            resources->on_vkCreateSamplerYcbcrConversionKHR(
                vkEnc, VK_SUCCESS, gfxstream_device->internal_object, pCreateInfo, pAllocator,
                pYcbcrConversion);
    }
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}
void gfxstream_vk_DestroySamplerYcbcrConversionKHR(VkDevice device,
                                                   VkSamplerYcbcrConversion ycbcrConversion,
                                                   const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR");
    if (VK_NULL_HANDLE == ycbcrConversion) {
        return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        resources->on_vkDestroySamplerYcbcrConversionKHR(vkEnc, gfxstream_device->internal_object,
                                                         ycbcrConversion, pAllocator);
    }
}
#endif
#ifdef VK_KHR_bind_memory2
VkResult gfxstream_vk_BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                           const VkBindBufferMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR");
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBindBufferMemoryInfo> internal_pBindInfos(bindInfoCount);
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            internal_pBindInfos[i] = pBindInfos[i];
            /* VkBindBufferMemoryInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pBindInfos[i].buffer);
            internal_pBindInfos[i].buffer = gfxstream_buffer->internal_object;
            /* VkBindBufferMemoryInfo::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                           internal_pBindInfos[i].memory);
            internal_pBindInfos[i].memory = gfxstream_memory->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBindBufferMemory2KHR_VkResult_return = resources->on_vkBindBufferMemory2KHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, bindInfoCount,
            internal_pBindInfos.data());
    }
    return vkBindBufferMemory2KHR_VkResult_return;
}
VkResult gfxstream_vk_BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                          const VkBindImageMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR");
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBindImageMemoryInfo> internal_pBindInfos(bindInfoCount);
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            internal_pBindInfos[i] = pBindInfos[i];
            /* VkBindImageMemoryInfo::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pBindInfos[i].image);
            internal_pBindInfos[i].image = gfxstream_image->internal_object;
            /* VkBindImageMemoryInfo::memory */
            if (internal_pBindInfos[i].memory) {
                VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                               internal_pBindInfos[i].memory);
                internal_pBindInfos[i].memory = gfxstream_memory->internal_object;
            }
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkBindImageMemory2KHR_VkResult_return = resources->on_vkBindImageMemory2KHR(
            vkEnc, VK_SUCCESS, gfxstream_device->internal_object, bindInfoCount,
            internal_pBindInfos.data());
    }
    return vkBindImageMemory2KHR_VkResult_return;
}
#endif
#ifdef VK_KHR_maintenance3
void gfxstream_vk_GetDescriptorSetLayoutSupportKHR(
    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDescriptorSetLayoutSupportKHR(gfxstream_device->internal_object, pCreateInfo,
                                                  pSupport, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_buffer_device_address
VkDeviceAddress gfxstream_vk_GetBufferDeviceAddressKHR(VkDevice device,
                                                       const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressKHR");
    VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferDeviceAddressInfo> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkBufferDeviceAddressInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pInfo[i].buffer);
            internal_pInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddressKHR(
            gfxstream_device->internal_object, internal_pInfo.data(), true /* do lock */);
    }
    return vkGetBufferDeviceAddressKHR_VkDeviceAddress_return;
}
uint64_t gfxstream_vk_GetBufferOpaqueCaptureAddressKHR(VkDevice device,
                                                       const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddressKHR");
    uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkBufferDeviceAddressInfo> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkBufferDeviceAddressInfo::buffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, internal_pInfo[i].buffer);
            internal_pInfo[i].buffer = gfxstream_buffer->internal_object;
        }
        vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return =
            vkEnc->vkGetBufferOpaqueCaptureAddressKHR(gfxstream_device->internal_object,
                                                      internal_pInfo.data(), true /* do lock */);
    }
    return vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return;
}
uint64_t gfxstream_vk_GetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddressKHR");
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDeviceMemoryOpaqueCaptureAddressInfo> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkDeviceMemoryOpaqueCaptureAddressInfo::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, internal_pInfo[i].memory);
            internal_pInfo[i].memory = gfxstream_memory->internal_object;
        }
        vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return =
            vkEnc->vkGetDeviceMemoryOpaqueCaptureAddressKHR(
                gfxstream_device->internal_object, internal_pInfo.data(), true /* do lock */);
    }
    return vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return;
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
VkResult gfxstream_vk_GetPipelineExecutablePropertiesKHR(
    VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPipelineExecutablePropertiesKHR");
    VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkPipelineInfoKHR> internal_pPipelineInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pPipelineInfo[i] = pPipelineInfo[i];
            /* VkPipelineInfoKHR::pipeline */
            VK_FROM_HANDLE(gfxstream_vk_pipeline, gfxstream_pipeline,
                           internal_pPipelineInfo[i].pipeline);
            internal_pPipelineInfo[i].pipeline = gfxstream_pipeline->internal_object;
        }
        vkGetPipelineExecutablePropertiesKHR_VkResult_return =
            vkEnc->vkGetPipelineExecutablePropertiesKHR(
                gfxstream_device->internal_object, internal_pPipelineInfo.data(), pExecutableCount,
                pProperties, true /* do lock */);
    }
    return vkGetPipelineExecutablePropertiesKHR_VkResult_return;
}
VkResult gfxstream_vk_GetPipelineExecutableStatisticsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics) {
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableStatisticsKHR");
    VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkPipelineExecutableInfoKHR> internal_pExecutableInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pExecutableInfo[i] = pExecutableInfo[i];
            /* VkPipelineExecutableInfoKHR::pipeline */
            VK_FROM_HANDLE(gfxstream_vk_pipeline, gfxstream_pipeline,
                           internal_pExecutableInfo[i].pipeline);
            internal_pExecutableInfo[i].pipeline = gfxstream_pipeline->internal_object;
        }
        vkGetPipelineExecutableStatisticsKHR_VkResult_return =
            vkEnc->vkGetPipelineExecutableStatisticsKHR(
                gfxstream_device->internal_object, internal_pExecutableInfo.data(), pStatisticCount,
                pStatistics, true /* do lock */);
    }
    return vkGetPipelineExecutableStatisticsKHR_VkResult_return;
}
VkResult gfxstream_vk_GetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableInternalRepresentationsKHR");
    VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkPipelineExecutableInfoKHR> internal_pExecutableInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pExecutableInfo[i] = pExecutableInfo[i];
            /* VkPipelineExecutableInfoKHR::pipeline */
            VK_FROM_HANDLE(gfxstream_vk_pipeline, gfxstream_pipeline,
                           internal_pExecutableInfo[i].pipeline);
            internal_pExecutableInfo[i].pipeline = gfxstream_pipeline->internal_object;
        }
        vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return =
            vkEnc->vkGetPipelineExecutableInternalRepresentationsKHR(
                gfxstream_device->internal_object, internal_pExecutableInfo.data(),
                pInternalRepresentationCount, pInternalRepresentations, true /* do lock */);
    }
    return vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_shader_integer_dot_product
#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_synchronization2
void gfxstream_vk_CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                  const VkDependencyInfo* pDependencyInfo) {
    AEMU_SCOPED_TRACE("vkCmdSetEvent2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkDependencyInfo> internal_pDependencyInfo(1);
        std::vector<std::vector<VkBufferMemoryBarrier2>>
            internal_VkDependencyInfo_pBufferMemoryBarriers;
        std::vector<std::vector<VkImageMemoryBarrier2>>
            internal_VkDependencyInfo_pImageMemoryBarriers;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pDependencyInfo[i] = pDependencyInfo[i];
            /* VkDependencyInfo::pBufferMemoryBarriers */
            internal_VkDependencyInfo_pBufferMemoryBarriers.push_back(
                std::vector<VkBufferMemoryBarrier2>());
            internal_VkDependencyInfo_pBufferMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pBufferMemoryBarriers[i][0], 0,
                   sizeof(VkBufferMemoryBarrier2) *
                       internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].bufferMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pBufferMemoryBarriers[j];
                /* VkBufferMemoryBarrier2::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer);
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer =
                    gfxstream_buffer->internal_object;
            }
            internal_pDependencyInfo[i].pBufferMemoryBarriers =
                internal_VkDependencyInfo_pBufferMemoryBarriers[i].data();
            /* VkDependencyInfo::pImageMemoryBarriers */
            internal_VkDependencyInfo_pImageMemoryBarriers.push_back(
                std::vector<VkImageMemoryBarrier2>());
            internal_VkDependencyInfo_pImageMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].imageMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pImageMemoryBarriers[i][0], 0,
                   sizeof(VkImageMemoryBarrier2) *
                       internal_pDependencyInfo[i].imageMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].imageMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pImageMemoryBarriers[j];
                /* VkImageMemoryBarrier2::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image);
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image =
                    gfxstream_image->internal_object;
            }
            internal_pDependencyInfo[i].pImageMemoryBarriers =
                internal_VkDependencyInfo_pImageMemoryBarriers[i].data();
        }
        vkEnc->vkCmdSetEvent2KHR(gfxstream_commandBuffer->internal_object,
                                 gfxstream_event->internal_object, internal_pDependencyInfo.data(),
                                 true /* do lock */);
    }
}
void gfxstream_vk_CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                    VkPipelineStageFlags2 stageMask) {
    AEMU_SCOPED_TRACE("vkCmdResetEvent2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_event, event);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdResetEvent2KHR(gfxstream_commandBuffer->internal_object,
                                   gfxstream_event->internal_object, stageMask, true /* do lock */);
    }
}
void gfxstream_vk_CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                    const VkEvent* pEvents,
                                    const VkDependencyInfo* pDependencyInfos) {
    AEMU_SCOPED_TRACE("vkCmdWaitEvents2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkEvent> internal_pEvents(eventCount);
        for (uint32_t i = 0; i < eventCount; ++i) {
            VK_FROM_HANDLE(gfxstream_vk_event, gfxstream_pEvents, pEvents[i]);
            internal_pEvents[i] = gfxstream_pEvents->internal_object;
        }
        std::vector<VkDependencyInfo> internal_pDependencyInfos(eventCount);
        std::vector<std::vector<VkBufferMemoryBarrier2>>
            internal_VkDependencyInfo_pBufferMemoryBarriers;
        std::vector<std::vector<VkImageMemoryBarrier2>>
            internal_VkDependencyInfo_pImageMemoryBarriers;
        for (uint32_t i = 0; i < eventCount; ++i) {
            internal_pDependencyInfos[i] = pDependencyInfos[i];
            /* VkDependencyInfo::pBufferMemoryBarriers */
            internal_VkDependencyInfo_pBufferMemoryBarriers.push_back(
                std::vector<VkBufferMemoryBarrier2>());
            internal_VkDependencyInfo_pBufferMemoryBarriers[i].reserve(
                internal_pDependencyInfos[i].bufferMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pBufferMemoryBarriers[i][0], 0,
                   sizeof(VkBufferMemoryBarrier2) *
                       internal_pDependencyInfos[i].bufferMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfos[i].bufferMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j] =
                    internal_pDependencyInfos[i].pBufferMemoryBarriers[j];
                /* VkBufferMemoryBarrier2::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer);
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer =
                    gfxstream_buffer->internal_object;
            }
            internal_pDependencyInfos[i].pBufferMemoryBarriers =
                internal_VkDependencyInfo_pBufferMemoryBarriers[i].data();
            /* VkDependencyInfo::pImageMemoryBarriers */
            internal_VkDependencyInfo_pImageMemoryBarriers.push_back(
                std::vector<VkImageMemoryBarrier2>());
            internal_VkDependencyInfo_pImageMemoryBarriers[i].reserve(
                internal_pDependencyInfos[i].imageMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pImageMemoryBarriers[i][0], 0,
                   sizeof(VkImageMemoryBarrier2) *
                       internal_pDependencyInfos[i].imageMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfos[i].imageMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j] =
                    internal_pDependencyInfos[i].pImageMemoryBarriers[j];
                /* VkImageMemoryBarrier2::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image);
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image =
                    gfxstream_image->internal_object;
            }
            internal_pDependencyInfos[i].pImageMemoryBarriers =
                internal_VkDependencyInfo_pImageMemoryBarriers[i].data();
        }
        vkEnc->vkCmdWaitEvents2KHR(gfxstream_commandBuffer->internal_object, eventCount,
                                   internal_pEvents.data(), internal_pDependencyInfos.data(),
                                   true /* do lock */);
    }
}
void gfxstream_vk_CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer,
                                         const VkDependencyInfo* pDependencyInfo) {
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkDependencyInfo> internal_pDependencyInfo(1);
        std::vector<std::vector<VkBufferMemoryBarrier2>>
            internal_VkDependencyInfo_pBufferMemoryBarriers;
        std::vector<std::vector<VkImageMemoryBarrier2>>
            internal_VkDependencyInfo_pImageMemoryBarriers;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pDependencyInfo[i] = pDependencyInfo[i];
            /* VkDependencyInfo::pBufferMemoryBarriers */
            internal_VkDependencyInfo_pBufferMemoryBarriers.push_back(
                std::vector<VkBufferMemoryBarrier2>());
            internal_VkDependencyInfo_pBufferMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pBufferMemoryBarriers[i][0], 0,
                   sizeof(VkBufferMemoryBarrier2) *
                       internal_pDependencyInfo[i].bufferMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].bufferMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pBufferMemoryBarriers[j];
                /* VkBufferMemoryBarrier2::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer);
                internal_VkDependencyInfo_pBufferMemoryBarriers[i][j].buffer =
                    gfxstream_buffer->internal_object;
            }
            internal_pDependencyInfo[i].pBufferMemoryBarriers =
                internal_VkDependencyInfo_pBufferMemoryBarriers[i].data();
            /* VkDependencyInfo::pImageMemoryBarriers */
            internal_VkDependencyInfo_pImageMemoryBarriers.push_back(
                std::vector<VkImageMemoryBarrier2>());
            internal_VkDependencyInfo_pImageMemoryBarriers[i].reserve(
                internal_pDependencyInfo[i].imageMemoryBarrierCount);
            memset(&internal_VkDependencyInfo_pImageMemoryBarriers[i][0], 0,
                   sizeof(VkImageMemoryBarrier2) *
                       internal_pDependencyInfo[i].imageMemoryBarrierCount);
            for (uint32_t j = 0; j < internal_pDependencyInfo[i].imageMemoryBarrierCount; ++j) {
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j] =
                    internal_pDependencyInfo[i].pImageMemoryBarriers[j];
                /* VkImageMemoryBarrier2::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image);
                internal_VkDependencyInfo_pImageMemoryBarriers[i][j].image =
                    gfxstream_image->internal_object;
            }
            internal_pDependencyInfo[i].pImageMemoryBarriers =
                internal_VkDependencyInfo_pImageMemoryBarriers[i].data();
        }
        vkEnc->vkCmdPipelineBarrier2KHR(gfxstream_commandBuffer->internal_object,
                                        internal_pDependencyInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                        VkQueryPool queryPool, uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdWriteTimestamp2KHR(gfxstream_commandBuffer->internal_object, stage,
                                       gfxstream_queryPool->internal_object, query,
                                       true /* do lock */);
    }
}
VkResult gfxstream_vk_QueueSubmit2KHR(VkQueue queue, uint32_t submitCount,
                                      const VkSubmitInfo2* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmit2KHR");
    VkResult vkQueueSubmit2KHR_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSubmitInfo2> internal_pSubmits(submitCount);
        std::vector<std::vector<VkSemaphoreSubmitInfo>> internal_VkSubmitInfo2_pWaitSemaphoreInfos;
        std::vector<std::vector<VkCommandBufferSubmitInfo>>
            internal_VkSubmitInfo2_pCommandBufferInfos;
        std::vector<std::vector<VkSemaphoreSubmitInfo>>
            internal_VkSubmitInfo2_pSignalSemaphoreInfos;
        for (uint32_t i = 0; i < submitCount; ++i) {
            internal_pSubmits[i] = pSubmits[i];
            /* VkSubmitInfo2::pWaitSemaphoreInfos */
            internal_VkSubmitInfo2_pWaitSemaphoreInfos.push_back(
                std::vector<VkSemaphoreSubmitInfo>());
            internal_VkSubmitInfo2_pWaitSemaphoreInfos[i] =
                transformVkSemaphoreSubmitInfoList(internal_pSubmits[i].pWaitSemaphoreInfos,
                                                   internal_pSubmits[i].waitSemaphoreInfoCount);
            internal_pSubmits[i].pWaitSemaphoreInfos =
                internal_VkSubmitInfo2_pWaitSemaphoreInfos[i].data();
            internal_pSubmits[i].waitSemaphoreInfoCount =
                internal_VkSubmitInfo2_pWaitSemaphoreInfos[i].size();
            /* VkSubmitInfo2::pCommandBufferInfos */
            internal_VkSubmitInfo2_pCommandBufferInfos.push_back(
                std::vector<VkCommandBufferSubmitInfo>());
            internal_VkSubmitInfo2_pCommandBufferInfos[i].reserve(
                internal_pSubmits[i].commandBufferInfoCount);
            memset(&internal_VkSubmitInfo2_pCommandBufferInfos[i][0], 0,
                   sizeof(VkCommandBufferSubmitInfo) * internal_pSubmits[i].commandBufferInfoCount);
            for (uint32_t j = 0; j < internal_pSubmits[i].commandBufferInfoCount; ++j) {
                internal_VkSubmitInfo2_pCommandBufferInfos[i][j] =
                    internal_pSubmits[i].pCommandBufferInfos[j];
                /* VkCommandBufferSubmitInfo::commandBuffer */
                VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer,
                               internal_VkSubmitInfo2_pCommandBufferInfos[i][j].commandBuffer);
                internal_VkSubmitInfo2_pCommandBufferInfos[i][j].commandBuffer =
                    gfxstream_commandBuffer->internal_object;
            }
            internal_pSubmits[i].pCommandBufferInfos =
                internal_VkSubmitInfo2_pCommandBufferInfos[i].data();
            /* VkSubmitInfo2::pSignalSemaphoreInfos */
            internal_VkSubmitInfo2_pSignalSemaphoreInfos.push_back(
                std::vector<VkSemaphoreSubmitInfo>());
            internal_VkSubmitInfo2_pSignalSemaphoreInfos[i] =
                transformVkSemaphoreSubmitInfoList(internal_pSubmits[i].pSignalSemaphoreInfos,
                                                   internal_pSubmits[i].signalSemaphoreInfoCount);
            internal_pSubmits[i].pSignalSemaphoreInfos =
                internal_VkSubmitInfo2_pSignalSemaphoreInfos[i].data();
            internal_pSubmits[i].signalSemaphoreInfoCount =
                internal_VkSubmitInfo2_pSignalSemaphoreInfos[i].size();
        }
        vkQueueSubmit2KHR_VkResult_return = vkEnc->vkQueueSubmit2KHR(
            gfxstream_queue->internal_object, submitCount, internal_pSubmits.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
            true /* do lock */);
    }
    return vkQueueSubmit2KHR_VkResult_return;
}
void gfxstream_vk_CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer,
                                           VkPipelineStageFlags2 stage, VkBuffer dstBuffer,
                                           VkDeviceSize dstOffset, uint32_t marker) {
    AEMU_SCOPED_TRACE("vkCmdWriteBufferMarker2AMD");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer, dstBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdWriteBufferMarker2AMD(gfxstream_commandBuffer->internal_object, stage,
                                          gfxstream_dstBuffer->internal_object, dstOffset, marker,
                                          true /* do lock */);
    }
}
void gfxstream_vk_GetQueueCheckpointData2NV(VkQueue queue, uint32_t* pCheckpointDataCount,
                                            VkCheckpointData2NV* pCheckpointData) {
    AEMU_SCOPED_TRACE("vkGetQueueCheckpointData2NV");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        vkEnc->vkGetQueueCheckpointData2NV(gfxstream_queue->internal_object, pCheckpointDataCount,
                                           pCheckpointData, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_zero_initialize_workgroup_memory
#endif
#ifdef VK_KHR_copy_commands2
void gfxstream_vk_CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer,
                                    const VkCopyBufferInfo2* pCopyBufferInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyBufferInfo2> internal_pCopyBufferInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyBufferInfo[i] = pCopyBufferInfo[i];
            /* VkCopyBufferInfo2::srcBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_srcBuffer,
                           internal_pCopyBufferInfo[i].srcBuffer);
            internal_pCopyBufferInfo[i].srcBuffer = gfxstream_srcBuffer->internal_object;
            /* VkCopyBufferInfo2::dstBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer,
                           internal_pCopyBufferInfo[i].dstBuffer);
            internal_pCopyBufferInfo[i].dstBuffer = gfxstream_dstBuffer->internal_object;
        }
        vkEnc->vkCmdCopyBuffer2KHR(gfxstream_commandBuffer->internal_object,
                                   internal_pCopyBufferInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyImage2KHR(VkCommandBuffer commandBuffer,
                                   const VkCopyImageInfo2* pCopyImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyImage2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyImageInfo2> internal_pCopyImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyImageInfo[i] = pCopyImageInfo[i];
            /* VkCopyImageInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pCopyImageInfo[i].srcImage);
            internal_pCopyImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkCopyImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pCopyImageInfo[i].dstImage);
            internal_pCopyImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdCopyImage2KHR(gfxstream_commandBuffer->internal_object,
                                  internal_pCopyImageInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer,
                                           const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyBufferToImageInfo2> internal_pCopyBufferToImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyBufferToImageInfo[i] = pCopyBufferToImageInfo[i];
            /* VkCopyBufferToImageInfo2::srcBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_srcBuffer,
                           internal_pCopyBufferToImageInfo[i].srcBuffer);
            internal_pCopyBufferToImageInfo[i].srcBuffer = gfxstream_srcBuffer->internal_object;
            /* VkCopyBufferToImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pCopyBufferToImageInfo[i].dstImage);
            internal_pCopyBufferToImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdCopyBufferToImage2KHR(gfxstream_commandBuffer->internal_object,
                                          internal_pCopyBufferToImageInfo.data(),
                                          true /* do lock */);
    }
}
void gfxstream_vk_CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer,
                                           const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCopyImageToBufferInfo2> internal_pCopyImageToBufferInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyImageToBufferInfo[i] = pCopyImageToBufferInfo[i];
            /* VkCopyImageToBufferInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pCopyImageToBufferInfo[i].srcImage);
            internal_pCopyImageToBufferInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkCopyImageToBufferInfo2::dstBuffer */
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_dstBuffer,
                           internal_pCopyImageToBufferInfo[i].dstBuffer);
            internal_pCopyImageToBufferInfo[i].dstBuffer = gfxstream_dstBuffer->internal_object;
        }
        vkEnc->vkCmdCopyImageToBuffer2KHR(gfxstream_commandBuffer->internal_object,
                                          internal_pCopyImageToBufferInfo.data(),
                                          true /* do lock */);
    }
}
void gfxstream_vk_CmdBlitImage2KHR(VkCommandBuffer commandBuffer,
                                   const VkBlitImageInfo2* pBlitImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdBlitImage2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBlitImageInfo2> internal_pBlitImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pBlitImageInfo[i] = pBlitImageInfo[i];
            /* VkBlitImageInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pBlitImageInfo[i].srcImage);
            internal_pBlitImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkBlitImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pBlitImageInfo[i].dstImage);
            internal_pBlitImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdBlitImage2KHR(gfxstream_commandBuffer->internal_object,
                                  internal_pBlitImageInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_CmdResolveImage2KHR(VkCommandBuffer commandBuffer,
                                      const VkResolveImageInfo2* pResolveImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdResolveImage2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkResolveImageInfo2> internal_pResolveImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pResolveImageInfo[i] = pResolveImageInfo[i];
            /* VkResolveImageInfo2::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pResolveImageInfo[i].srcImage);
            internal_pResolveImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkResolveImageInfo2::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pResolveImageInfo[i].dstImage);
            internal_pResolveImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkEnc->vkCmdResolveImage2KHR(gfxstream_commandBuffer->internal_object,
                                     internal_pResolveImageInfo.data(), true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_format_feature_flags2
#endif
#ifdef VK_KHR_maintenance4
void gfxstream_vk_GetDeviceBufferMemoryRequirementsKHR(
    VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceBufferMemoryRequirementsKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceBufferMemoryRequirementsKHR(gfxstream_device->internal_object, pInfo,
                                                      pMemoryRequirements, true /* do lock */);
    }
}
void gfxstream_vk_GetDeviceImageMemoryRequirementsKHR(VkDevice device,
                                                      const VkDeviceImageMemoryRequirements* pInfo,
                                                      VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageMemoryRequirementsKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceImageMemoryRequirementsKHR(gfxstream_device->internal_object, pInfo,
                                                     pMemoryRequirements, true /* do lock */);
    }
}
void gfxstream_vk_GetDeviceImageSparseMemoryRequirementsKHR(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageSparseMemoryRequirementsKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceImageSparseMemoryRequirementsKHR(
            gfxstream_device->internal_object, pInfo, pSparseMemoryRequirementCount,
            pSparseMemoryRequirements, true /* do lock */);
    }
}
#endif
#ifdef VK_KHR_maintenance5
void gfxstream_vk_CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                         VkDeviceSize offset, VkDeviceSize size,
                                         VkIndexType indexType) {
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer2KHR");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer, buffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdBindIndexBuffer2KHR(gfxstream_commandBuffer->internal_object,
                                        gfxstream_buffer->internal_object, offset, size, indexType,
                                        true /* do lock */);
    }
}
void gfxstream_vk_GetRenderingAreaGranularityKHR(VkDevice device,
                                                 const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
                                                 VkExtent2D* pGranularity) {
    AEMU_SCOPED_TRACE("vkGetRenderingAreaGranularityKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetRenderingAreaGranularityKHR(gfxstream_device->internal_object,
                                                pRenderingAreaInfo, pGranularity,
                                                true /* do lock */);
    }
}
void gfxstream_vk_GetDeviceImageSubresourceLayoutKHR(VkDevice device,
                                                     const VkDeviceImageSubresourceInfoKHR* pInfo,
                                                     VkSubresourceLayout2KHR* pLayout) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageSubresourceLayoutKHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetDeviceImageSubresourceLayoutKHR(gfxstream_device->internal_object, pInfo,
                                                    pLayout, true /* do lock */);
    }
}
void gfxstream_vk_GetImageSubresourceLayout2KHR(VkDevice device, VkImage image,
                                                const VkImageSubresource2KHR* pSubresource,
                                                VkSubresourceLayout2KHR* pLayout) {
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout2KHR");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetImageSubresourceLayout2KHR(gfxstream_device->internal_object,
                                               gfxstream_image->internal_object, pSubresource,
                                               pLayout, true /* do lock */);
    }
}
#endif
#ifdef VK_ANDROID_native_buffer
VkResult gfxstream_vk_GetSwapchainGrallocUsageANDROID(VkDevice device, VkFormat format,
                                                      VkImageUsageFlags imageUsage,
                                                      int* grallocUsage) {
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID");
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetSwapchainGrallocUsageANDROID_VkResult_return =
            vkEnc->vkGetSwapchainGrallocUsageANDROID(gfxstream_device->internal_object, format,
                                                     imageUsage, grallocUsage, true /* do lock */);
    }
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}
VkResult gfxstream_vk_AcquireImageANDROID(VkDevice device, VkImage image, int nativeFenceFd,
                                          VkSemaphore semaphore, VkFence fence) {
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID");
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    VK_FROM_HANDLE(gfxstream_vk_semaphore, gfxstream_semaphore, semaphore);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkAcquireImageANDROID_VkResult_return = vkEnc->vkAcquireImageANDROID(
            gfxstream_device->internal_object, gfxstream_image->internal_object, nativeFenceFd,
            gfxstream_semaphore ? gfxstream_semaphore->internal_object : VK_NULL_HANDLE,
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
            true /* do lock */);
    }
    return vkAcquireImageANDROID_VkResult_return;
}
VkResult gfxstream_vk_QueueSignalReleaseImageANDROID(VkQueue queue, uint32_t waitSemaphoreCount,
                                                     const VkSemaphore* pWaitSemaphores,
                                                     VkImage image, int* pNativeFenceFd) {
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROID");
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSemaphore> internal_pWaitSemaphores(waitSemaphoreCount);
        internal_pWaitSemaphores = transformVkSemaphoreList(pWaitSemaphores, waitSemaphoreCount);
        pWaitSemaphores = internal_pWaitSemaphores.data();
        waitSemaphoreCount = internal_pWaitSemaphores.size();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkQueueSignalReleaseImageANDROID_VkResult_return =
            resources->on_vkQueueSignalReleaseImageANDROID(
                vkEnc, VK_SUCCESS, gfxstream_queue->internal_object, waitSemaphoreCount,
                internal_pWaitSemaphores.data(), gfxstream_image->internal_object, pNativeFenceFd);
    }
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}
VkResult gfxstream_vk_GetSwapchainGrallocUsage2ANDROID(
    VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
    VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
    uint64_t* grallocProducerUsage) {
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsage2ANDROID");
    VkResult vkGetSwapchainGrallocUsage2ANDROID_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetSwapchainGrallocUsage2ANDROID_VkResult_return =
            vkEnc->vkGetSwapchainGrallocUsage2ANDROID(
                gfxstream_device->internal_object, format, imageUsage, swapchainImageUsage,
                grallocConsumerUsage, grallocProducerUsage, true /* do lock */);
    }
    return vkGetSwapchainGrallocUsage2ANDROID_VkResult_return;
}
#endif
#ifdef VK_EXT_transform_feedback
void gfxstream_vk_CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer,
                                                     uint32_t firstBinding, uint32_t bindingCount,
                                                     const VkBuffer* pBuffers,
                                                     const VkDeviceSize* pOffsets,
                                                     const VkDeviceSize* pSizes) {
    AEMU_SCOPED_TRACE("vkCmdBindTransformFeedbackBuffersEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBuffer> internal_pBuffers(bindingCount);
        for (uint32_t i = 0; i < bindingCount; ++i) {
            VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_pBuffers, pBuffers[i]);
            internal_pBuffers[i] = gfxstream_pBuffers->internal_object;
        }
        vkEnc->vkCmdBindTransformFeedbackBuffersEXT(
            gfxstream_commandBuffer->internal_object, firstBinding, bindingCount,
            internal_pBuffers.data(), pOffsets, pSizes, true /* do lock */);
    }
}
void gfxstream_vk_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer,
                                               uint32_t firstCounterBuffer,
                                               uint32_t counterBufferCount,
                                               const VkBuffer* pCounterBuffers,
                                               const VkDeviceSize* pCounterBufferOffsets) {
    AEMU_SCOPED_TRACE("vkCmdBeginTransformFeedbackEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBuffer> internal_pCounterBuffers(counterBufferCount);
        for (uint32_t i = 0; i < counterBufferCount; ++i) {
            if (pCounterBuffers) {
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_pCounterBuffers, pCounterBuffers[i]);
                internal_pCounterBuffers[i] = gfxstream_pCounterBuffers->internal_object;
            }
        }
        vkEnc->vkCmdBeginTransformFeedbackEXT(
            gfxstream_commandBuffer->internal_object, firstCounterBuffer, counterBufferCount,
            internal_pCounterBuffers.data(), pCounterBufferOffsets, true /* do lock */);
    }
}
void gfxstream_vk_CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer,
                                             uint32_t firstCounterBuffer,
                                             uint32_t counterBufferCount,
                                             const VkBuffer* pCounterBuffers,
                                             const VkDeviceSize* pCounterBufferOffsets) {
    AEMU_SCOPED_TRACE("vkCmdEndTransformFeedbackEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBuffer> internal_pCounterBuffers(counterBufferCount);
        for (uint32_t i = 0; i < counterBufferCount; ++i) {
            if (pCounterBuffers) {
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_pCounterBuffers, pCounterBuffers[i]);
                internal_pCounterBuffers[i] = gfxstream_pCounterBuffers->internal_object;
            }
        }
        vkEnc->vkCmdEndTransformFeedbackEXT(
            gfxstream_commandBuffer->internal_object, firstCounterBuffer, counterBufferCount,
            internal_pCounterBuffers.data(), pCounterBufferOffsets, true /* do lock */);
    }
}
void gfxstream_vk_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                          uint32_t query, VkQueryControlFlags flags,
                                          uint32_t index) {
    AEMU_SCOPED_TRACE("vkCmdBeginQueryIndexedEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdBeginQueryIndexedEXT(gfxstream_commandBuffer->internal_object,
                                         gfxstream_queryPool->internal_object, query, flags, index,
                                         true /* do lock */);
    }
}
void gfxstream_vk_CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                        uint32_t query, uint32_t index) {
    AEMU_SCOPED_TRACE("vkCmdEndQueryIndexedEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_query_pool, gfxstream_queryPool, queryPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdEndQueryIndexedEXT(gfxstream_commandBuffer->internal_object,
                                       gfxstream_queryPool->internal_object, query, index,
                                       true /* do lock */);
    }
}
void gfxstream_vk_CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount,
                                              uint32_t firstInstance, VkBuffer counterBuffer,
                                              VkDeviceSize counterBufferOffset,
                                              uint32_t counterOffset, uint32_t vertexStride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectByteCountEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_counterBuffer, counterBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdDrawIndirectByteCountEXT(
            gfxstream_commandBuffer->internal_object, instanceCount, firstInstance,
            gfxstream_counterBuffer->internal_object, counterBufferOffset, counterOffset,
            vertexStride, true /* do lock */);
    }
}
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
#endif
#ifdef VK_EXT_depth_clip_enable
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
VkResult gfxstream_vk_GetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device, const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties) {
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID");
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return =
            resources->on_vkGetAndroidHardwareBufferPropertiesANDROID(
                vkEnc, VK_SUCCESS, gfxstream_device->internal_object, buffer, pProperties);
    }
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}
VkResult gfxstream_vk_GetMemoryAndroidHardwareBufferANDROID(
    VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer) {
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID");
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkMemoryGetAndroidHardwareBufferInfoANDROID> internal_pInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pInfo[i] = pInfo[i];
            /* VkMemoryGetAndroidHardwareBufferInfoANDROID::memory */
            VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, internal_pInfo[i].memory);
            internal_pInfo[i].memory = gfxstream_memory->internal_object;
        }
        auto resources = gfxstream::vk::ResourceTracker::get();
        vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return =
            resources->on_vkGetMemoryAndroidHardwareBufferANDROID(vkEnc, VK_SUCCESS,
                                                                  gfxstream_device->internal_object,
                                                                  internal_pInfo.data(), pBuffer);
    }
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}
#endif
#ifdef VK_EXT_inline_uniform_block
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_EXT_pipeline_creation_feedback
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_EXT_metal_surface
#endif
#ifdef VK_EXT_fragment_density_map
#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_EXT_tooling_info
VkResult gfxstream_vk_GetPhysicalDeviceToolPropertiesEXT(
    VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
    VkPhysicalDeviceToolProperties* pToolProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceToolPropertiesEXT");
    VkResult vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_physical_device, gfxstream_physicalDevice, physicalDevice);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return =
            vkEnc->vkGetPhysicalDeviceToolPropertiesEXT(gfxstream_physicalDevice->internal_object,
                                                        pToolCount, pToolProperties,
                                                        true /* do lock */);
    }
    return vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_validation_features
#endif
#ifdef VK_EXT_provoking_vertex
#endif
#ifdef VK_EXT_line_rasterization
void gfxstream_vk_CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                       uint16_t lineStipplePattern) {
    AEMU_SCOPED_TRACE("vkCmdSetLineStippleEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetLineStippleEXT(gfxstream_commandBuffer->internal_object, lineStippleFactor,
                                      lineStipplePattern, true /* do lock */);
    }
}
#endif
#ifdef VK_EXT_index_type_uint8
#endif
#ifdef VK_EXT_extended_dynamic_state
void gfxstream_vk_CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    AEMU_SCOPED_TRACE("vkCmdSetCullModeEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetCullModeEXT(gfxstream_commandBuffer->internal_object, cullMode,
                                   true /* do lock */);
    }
}
void gfxstream_vk_CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    AEMU_SCOPED_TRACE("vkCmdSetFrontFaceEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetFrontFaceEXT(gfxstream_commandBuffer->internal_object, frontFace,
                                    true /* do lock */);
    }
}
void gfxstream_vk_CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer,
                                             VkPrimitiveTopology primitiveTopology) {
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveTopologyEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetPrimitiveTopologyEXT(gfxstream_commandBuffer->internal_object,
                                            primitiveTopology, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                             const VkViewport* pViewports) {
    AEMU_SCOPED_TRACE("vkCmdSetViewportWithCountEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetViewportWithCountEXT(gfxstream_commandBuffer->internal_object, viewportCount,
                                            pViewports, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                            const VkRect2D* pScissors) {
    AEMU_SCOPED_TRACE("vkCmdSetScissorWithCountEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetScissorWithCountEXT(gfxstream_commandBuffer->internal_object, scissorCount,
                                           pScissors, true /* do lock */);
    }
}
void gfxstream_vk_CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                           uint32_t bindingCount, const VkBuffer* pBuffers,
                                           const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                           const VkDeviceSize* pStrides) {
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers2EXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkBuffer> internal_pBuffers(bindingCount);
        for (uint32_t i = 0; i < bindingCount; ++i) {
            if (pBuffers) {
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_pBuffers, pBuffers[i]);
                internal_pBuffers[i] = gfxstream_pBuffers->internal_object;
            }
        }
        vkEnc->vkCmdBindVertexBuffers2EXT(gfxstream_commandBuffer->internal_object, firstBinding,
                                          bindingCount, internal_pBuffers.data(), pOffsets, pSizes,
                                          pStrides, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer,
                                           VkBool32 depthTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthTestEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthTestEnableEXT(gfxstream_commandBuffer->internal_object, depthTestEnable,
                                          true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer,
                                            VkBool32 depthWriteEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthWriteEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthWriteEnableEXT(gfxstream_commandBuffer->internal_object,
                                           depthWriteEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer,
                                          VkCompareOp depthCompareOp) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthCompareOpEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthCompareOpEXT(gfxstream_commandBuffer->internal_object, depthCompareOp,
                                         true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer,
                                                 VkBool32 depthBoundsTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBoundsTestEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthBoundsTestEnableEXT(gfxstream_commandBuffer->internal_object,
                                                depthBoundsTestEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer,
                                             VkBool32 stencilTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilTestEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilTestEnableEXT(gfxstream_commandBuffer->internal_object,
                                            stencilTestEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                     VkStencilOp failOp, VkStencilOp passOp,
                                     VkStencilOp depthFailOp, VkCompareOp compareOp) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilOpEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetStencilOpEXT(gfxstream_commandBuffer->internal_object, faceMask, failOp,
                                    passOp, depthFailOp, compareOp, true /* do lock */);
    }
}
#endif
#ifdef VK_EXT_host_image_copy
VkResult gfxstream_vk_CopyMemoryToImageEXT(
    VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo) {
    AEMU_SCOPED_TRACE("vkCopyMemoryToImageEXT");
    VkResult vkCopyMemoryToImageEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkCopyMemoryToImageInfoEXT> internal_pCopyMemoryToImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyMemoryToImageInfo[i] = pCopyMemoryToImageInfo[i];
            /* VkCopyMemoryToImageInfoEXT::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pCopyMemoryToImageInfo[i].dstImage);
            internal_pCopyMemoryToImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkCopyMemoryToImageEXT_VkResult_return = vkEnc->vkCopyMemoryToImageEXT(
            gfxstream_device->internal_object, internal_pCopyMemoryToImageInfo.data(),
            true /* do lock */);
    }
    return vkCopyMemoryToImageEXT_VkResult_return;
}
VkResult gfxstream_vk_CopyImageToMemoryEXT(
    VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo) {
    AEMU_SCOPED_TRACE("vkCopyImageToMemoryEXT");
    VkResult vkCopyImageToMemoryEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkCopyImageToMemoryInfoEXT> internal_pCopyImageToMemoryInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyImageToMemoryInfo[i] = pCopyImageToMemoryInfo[i];
            /* VkCopyImageToMemoryInfoEXT::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pCopyImageToMemoryInfo[i].srcImage);
            internal_pCopyImageToMemoryInfo[i].srcImage = gfxstream_srcImage->internal_object;
        }
        vkCopyImageToMemoryEXT_VkResult_return = vkEnc->vkCopyImageToMemoryEXT(
            gfxstream_device->internal_object, internal_pCopyImageToMemoryInfo.data(),
            true /* do lock */);
    }
    return vkCopyImageToMemoryEXT_VkResult_return;
}
VkResult gfxstream_vk_CopyImageToImageEXT(VkDevice device,
                                          const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo) {
    AEMU_SCOPED_TRACE("vkCopyImageToImageEXT");
    VkResult vkCopyImageToImageEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkCopyImageToImageInfoEXT> internal_pCopyImageToImageInfo(1);
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pCopyImageToImageInfo[i] = pCopyImageToImageInfo[i];
            /* VkCopyImageToImageInfoEXT::srcImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_srcImage,
                           internal_pCopyImageToImageInfo[i].srcImage);
            internal_pCopyImageToImageInfo[i].srcImage = gfxstream_srcImage->internal_object;
            /* VkCopyImageToImageInfoEXT::dstImage */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_dstImage,
                           internal_pCopyImageToImageInfo[i].dstImage);
            internal_pCopyImageToImageInfo[i].dstImage = gfxstream_dstImage->internal_object;
        }
        vkCopyImageToImageEXT_VkResult_return =
            vkEnc->vkCopyImageToImageEXT(gfxstream_device->internal_object,
                                         internal_pCopyImageToImageInfo.data(), true /* do lock */);
    }
    return vkCopyImageToImageEXT_VkResult_return;
}
VkResult gfxstream_vk_TransitionImageLayoutEXT(
    VkDevice device, uint32_t transitionCount,
    const VkHostImageLayoutTransitionInfoEXT* pTransitions) {
    AEMU_SCOPED_TRACE("vkTransitionImageLayoutEXT");
    VkResult vkTransitionImageLayoutEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkHostImageLayoutTransitionInfoEXT> internal_pTransitions(transitionCount);
        for (uint32_t i = 0; i < transitionCount; ++i) {
            internal_pTransitions[i] = pTransitions[i];
            /* VkHostImageLayoutTransitionInfoEXT::image */
            VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, internal_pTransitions[i].image);
            internal_pTransitions[i].image = gfxstream_image->internal_object;
        }
        vkTransitionImageLayoutEXT_VkResult_return =
            vkEnc->vkTransitionImageLayoutEXT(gfxstream_device->internal_object, transitionCount,
                                              internal_pTransitions.data(), true /* do lock */);
    }
    return vkTransitionImageLayoutEXT_VkResult_return;
}
void gfxstream_vk_GetImageSubresourceLayout2EXT(VkDevice device, VkImage image,
                                                const VkImageSubresource2KHR* pSubresource,
                                                VkSubresourceLayout2KHR* pLayout) {
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout2EXT");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetImageSubresourceLayout2EXT(gfxstream_device->internal_object,
                                               gfxstream_image->internal_object, pSubresource,
                                               pLayout, true /* do lock */);
    }
}
#endif
#ifdef VK_EXT_swapchain_maintenance1
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
#endif
#ifdef VK_EXT_texel_buffer_alignment
#endif
#ifdef VK_EXT_device_memory_report
#endif
#ifdef VK_EXT_robustness2
#endif
#ifdef VK_EXT_custom_border_color
#endif
#ifdef VK_EXT_private_data
VkResult gfxstream_vk_CreatePrivateDataSlotEXT(VkDevice device,
                                               const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                               const VkAllocationCallbacks* pAllocator,
                                               VkPrivateDataSlot* pPrivateDataSlot) {
    AEMU_SCOPED_TRACE("vkCreatePrivateDataSlotEXT");
    VkResult vkCreatePrivateDataSlotEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreatePrivateDataSlotEXT_VkResult_return =
            vkEnc->vkCreatePrivateDataSlotEXT(gfxstream_device->internal_object, pCreateInfo,
                                              pAllocator, pPrivateDataSlot, true /* do lock */);
    }
    return vkCreatePrivateDataSlotEXT_VkResult_return;
}
void gfxstream_vk_DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                            const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPrivateDataSlotEXT");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkDestroyPrivateDataSlotEXT(gfxstream_device->internal_object, privateDataSlot,
                                           pAllocator, true /* do lock */);
    }
}
VkResult gfxstream_vk_SetPrivateDataEXT(VkDevice device, VkObjectType objectType,
                                        uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
                                        uint64_t data) {
    AEMU_SCOPED_TRACE("vkSetPrivateDataEXT");
    VkResult vkSetPrivateDataEXT_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkSetPrivateDataEXT_VkResult_return =
            vkEnc->vkSetPrivateDataEXT(gfxstream_device->internal_object, objectType, objectHandle,
                                       privateDataSlot, data, true /* do lock */);
    }
    return vkSetPrivateDataEXT_VkResult_return;
}
void gfxstream_vk_GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                    VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    AEMU_SCOPED_TRACE("vkGetPrivateDataEXT");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetPrivateDataEXT(gfxstream_device->internal_object, objectType, objectHandle,
                                   privateDataSlot, pData, true /* do lock */);
    }
}
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
#endif
#ifdef VK_EXT_graphics_pipeline_library
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_image_compression_control
#endif
#ifdef VK_EXT_4444_formats
#endif
#ifdef VK_EXT_primitive_topology_list_restart
#endif
#ifdef VK_EXT_extended_dynamic_state2
void gfxstream_vk_CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer,
                                              uint32_t patchControlPoints) {
    AEMU_SCOPED_TRACE("vkCmdSetPatchControlPointsEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetPatchControlPointsEXT(gfxstream_commandBuffer->internal_object,
                                             patchControlPoints, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer,
                                                   VkBool32 rasterizerDiscardEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetRasterizerDiscardEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetRasterizerDiscardEnableEXT(gfxstream_commandBuffer->internal_object,
                                                  rasterizerDiscardEnable, true /* do lock */);
    }
}
void gfxstream_vk_CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer,
                                           VkBool32 depthBiasEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBiasEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetDepthBiasEnableEXT(gfxstream_commandBuffer->internal_object, depthBiasEnable,
                                          true /* do lock */);
    }
}
void gfxstream_vk_CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
    AEMU_SCOPED_TRACE("vkCmdSetLogicOpEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetLogicOpEXT(gfxstream_commandBuffer->internal_object, logicOp,
                                  true /* do lock */);
    }
}
void gfxstream_vk_CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer,
                                                  VkBool32 primitiveRestartEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveRestartEnableEXT");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCmdSetPrimitiveRestartEnableEXT(gfxstream_commandBuffer->internal_object,
                                                 primitiveRestartEnable, true /* do lock */);
    }
}
#endif
#ifdef VK_GOOGLE_gfxstream
VkResult gfxstream_vk_MapMemoryIntoAddressSpaceGOOGLE(VkDevice device, VkDeviceMemory memory,
                                                      uint64_t* pAddress) {
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE");
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return =
            vkEnc->vkMapMemoryIntoAddressSpaceGOOGLE(gfxstream_device->internal_object,
                                                     gfxstream_memory->internal_object, pAddress,
                                                     true /* do lock */);
    }
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}
void gfxstream_vk_UpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
    uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_update_template, gfxstream_descriptorUpdateTemplate,
                   descriptorUpdateTemplate);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDescriptorImageInfo> internal_pImageInfos(imageInfoCount);
        for (uint32_t i = 0; i < imageInfoCount; ++i) {
            if (pImageInfos) {
                internal_pImageInfos[i] = pImageInfos[i];
                /* VkDescriptorImageInfo::imageView */
                if (internal_pImageInfos[i].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_pImageInfos[i].imageView);
                    internal_pImageInfos[i].imageView = gfxstream_imageView->internal_object;
                }
            }
        }
        std::vector<VkDescriptorBufferInfo> internal_pBufferInfos(bufferInfoCount);
        for (uint32_t i = 0; i < bufferInfoCount; ++i) {
            if (pBufferInfos) {
                internal_pBufferInfos[i] = pBufferInfos[i];
                /* VkDescriptorBufferInfo::buffer */
                if (internal_pBufferInfos[i].buffer) {
                    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                                   internal_pBufferInfos[i].buffer);
                    internal_pBufferInfos[i].buffer = gfxstream_buffer->internal_object;
                }
            }
        }
        std::vector<VkBufferView> internal_pBufferViews(bufferViewCount);
        for (uint32_t i = 0; i < bufferViewCount; ++i) {
            if (pBufferViews) {
                VK_FROM_HANDLE(gfxstream_vk_buffer_view, gfxstream_pBufferViews, pBufferViews[i]);
                internal_pBufferViews[i] = gfxstream_pBufferViews->internal_object;
            }
        }
        vkEnc->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
            gfxstream_device->internal_object, descriptorSet,
            gfxstream_descriptorUpdateTemplate->internal_object, imageInfoCount, bufferInfoCount,
            bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices,
            pBufferViewEntryIndices, internal_pImageInfos.data(), internal_pBufferInfos.data(),
            internal_pBufferViews.data(), true /* do lock */);
    }
}
void gfxstream_vk_BeginCommandBufferAsyncGOOGLE(VkCommandBuffer commandBuffer,
                                                const VkCommandBufferBeginInfo* pBeginInfo) {
    AEMU_SCOPED_TRACE("vkBeginCommandBufferAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        std::vector<VkCommandBufferBeginInfo> internal_pBeginInfo(1);
        std::vector<VkCommandBufferInheritanceInfo>
            internal_VkCommandBufferBeginInfo_pInheritanceInfo;
        for (uint32_t i = 0; i < 1; ++i) {
            internal_pBeginInfo[i] = pBeginInfo[i];
            /* VkCommandBufferBeginInfo::pInheritanceInfo */
            if (internal_pBeginInfo[i].pInheritanceInfo) {
                internal_VkCommandBufferBeginInfo_pInheritanceInfo[i] =
                    internal_pBeginInfo[i].pInheritanceInfo[0];
                /* VkCommandBufferInheritanceInfo::renderPass */
                if (internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].renderPass) {
                    VK_FROM_HANDLE(
                        gfxstream_vk_render_pass, gfxstream_renderPass,
                        internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].renderPass);
                    internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].renderPass =
                        gfxstream_renderPass->internal_object;
                }
                /* VkCommandBufferInheritanceInfo::framebuffer */
                if (internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].framebuffer) {
                    VK_FROM_HANDLE(
                        gfxstream_vk_framebuffer, gfxstream_framebuffer,
                        internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].framebuffer);
                    internal_VkCommandBufferBeginInfo_pInheritanceInfo[i].framebuffer =
                        gfxstream_framebuffer->internal_object;
                }
                internal_pBeginInfo[i].pInheritanceInfo =
                    &internal_VkCommandBufferBeginInfo_pInheritanceInfo[i];
            }
        }
        vkEnc->vkBeginCommandBufferAsyncGOOGLE(gfxstream_commandBuffer->internal_object,
                                               internal_pBeginInfo.data(), true /* do lock */);
    }
}
void gfxstream_vk_EndCommandBufferAsyncGOOGLE(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkEndCommandBufferAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkEndCommandBufferAsyncGOOGLE(gfxstream_commandBuffer->internal_object,
                                             true /* do lock */);
    }
}
void gfxstream_vk_ResetCommandBufferAsyncGOOGLE(VkCommandBuffer commandBuffer,
                                                VkCommandBufferResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetCommandBufferAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkResetCommandBufferAsyncGOOGLE(gfxstream_commandBuffer->internal_object, flags,
                                               true /* do lock */);
    }
}
void gfxstream_vk_CommandBufferHostSyncGOOGLE(VkCommandBuffer commandBuffer, uint32_t needHostSync,
                                              uint32_t sequenceNumber) {
    AEMU_SCOPED_TRACE("vkCommandBufferHostSyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getCommandBufferEncoder(
            gfxstream_commandBuffer->internal_object);
        vkEnc->vkCommandBufferHostSyncGOOGLE(gfxstream_commandBuffer->internal_object, needHostSync,
                                             sequenceNumber, true /* do lock */);
    }
}
VkResult gfxstream_vk_CreateImageWithRequirementsGOOGLE(VkDevice device,
                                                        const VkImageCreateInfo* pCreateInfo,
                                                        const VkAllocationCallbacks* pAllocator,
                                                        VkImage* pImage,
                                                        VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE");
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_image* gfxstream_pImage = (struct gfxstream_vk_image*)vk_image_create(
        (vk_device*)gfxstream_device, pCreateInfo, pAllocator, sizeof(struct gfxstream_vk_image));
    vkCreateImageWithRequirementsGOOGLE_VkResult_return =
        gfxstream_pImage ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateImageWithRequirementsGOOGLE_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateImageWithRequirementsGOOGLE_VkResult_return =
            vkEnc->vkCreateImageWithRequirementsGOOGLE(
                gfxstream_device->internal_object, pCreateInfo, pAllocator,
                &gfxstream_pImage->internal_object, pMemoryRequirements, true /* do lock */);
    }
    *pImage = gfxstream_vk_image_to_handle(gfxstream_pImage);
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}
VkResult gfxstream_vk_CreateBufferWithRequirementsGOOGLE(
    VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE");
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    struct gfxstream_vk_buffer* gfxstream_pBuffer = (struct gfxstream_vk_buffer*)vk_buffer_create(
        (vk_device*)gfxstream_device, pCreateInfo, pAllocator, sizeof(struct gfxstream_vk_buffer));
    vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
        gfxstream_pBuffer ? VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
    if (VK_SUCCESS == vkCreateBufferWithRequirementsGOOGLE_VkResult_return) {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
            vkEnc->vkCreateBufferWithRequirementsGOOGLE(
                gfxstream_device->internal_object, pCreateInfo, pAllocator,
                &gfxstream_pBuffer->internal_object, pMemoryRequirements, true /* do lock */);
    }
    *pBuffer = gfxstream_vk_buffer_to_handle(gfxstream_pBuffer);
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}
VkResult gfxstream_vk_GetMemoryHostAddressInfoGOOGLE(VkDevice device, VkDeviceMemory memory,
                                                     uint64_t* pAddress, uint64_t* pSize,
                                                     uint64_t* pHostmemId) {
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE");
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = vkEnc->vkGetMemoryHostAddressInfoGOOGLE(
            gfxstream_device->internal_object, gfxstream_memory->internal_object, pAddress, pSize,
            pHostmemId, true /* do lock */);
    }
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}
VkResult gfxstream_vk_FreeMemorySyncGOOGLE(VkDevice device, VkDeviceMemory memory,
                                           const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE");
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    if (VK_NULL_HANDLE == memory) {
        return vkFreeMemorySyncGOOGLE_VkResult_return;
    }
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkFreeMemorySyncGOOGLE_VkResult_return = vkEnc->vkFreeMemorySyncGOOGLE(
            gfxstream_device->internal_object,
            gfxstream_memory ? gfxstream_memory->internal_object : VK_NULL_HANDLE, pAllocator,
            true /* do lock */);
    }
    vk_device_memory_destroy(&gfxstream_device->vk, pAllocator, &gfxstream_memory->vk);
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}
void gfxstream_vk_QueueHostSyncGOOGLE(VkQueue queue, uint32_t needHostSync,
                                      uint32_t sequenceNumber) {
    AEMU_SCOPED_TRACE("vkQueueHostSyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        vkEnc->vkQueueHostSyncGOOGLE(gfxstream_queue->internal_object, needHostSync, sequenceNumber,
                                     true /* do lock */);
    }
}
void gfxstream_vk_QueueSubmitAsyncGOOGLE(VkQueue queue, uint32_t submitCount,
                                         const VkSubmitInfo* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmitAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSubmitInfo> internal_pSubmits(submitCount);
        std::vector<std::vector<VkSemaphore>> internal_VkSubmitInfo_pWaitSemaphores;
        std::vector<std::vector<VkCommandBuffer>> internal_VkSubmitInfo_pCommandBuffers;
        std::vector<std::vector<VkSemaphore>> internal_VkSubmitInfo_pSignalSemaphores;
        for (uint32_t i = 0; i < submitCount; ++i) {
            internal_pSubmits[i] = pSubmits[i];
            /* VkSubmitInfo::pWaitSemaphores */
            internal_VkSubmitInfo_pWaitSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkSubmitInfo_pWaitSemaphores[i] = transformVkSemaphoreList(
                internal_pSubmits[i].pWaitSemaphores, internal_pSubmits[i].waitSemaphoreCount);
            internal_pSubmits[i].pWaitSemaphores = internal_VkSubmitInfo_pWaitSemaphores[i].data();
            internal_pSubmits[i].waitSemaphoreCount =
                internal_VkSubmitInfo_pWaitSemaphores[i].size();
            /* VkSubmitInfo::pCommandBuffers */
            internal_VkSubmitInfo_pCommandBuffers.push_back(std::vector<VkCommandBuffer>());
            internal_VkSubmitInfo_pCommandBuffers[i].reserve(
                internal_pSubmits[i].commandBufferCount);
            memset(&internal_VkSubmitInfo_pCommandBuffers[i][0], 0,
                   sizeof(VkCommandBuffer) * internal_pSubmits[i].commandBufferCount);
            for (uint32_t j = 0; j < internal_pSubmits[i].commandBufferCount; ++j) {
                VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_pCommandBuffers,
                               internal_pSubmits[i].pCommandBuffers[j]);
                internal_VkSubmitInfo_pCommandBuffers[i][j] =
                    gfxstream_pCommandBuffers->internal_object;
            }
            internal_pSubmits[i].pCommandBuffers = internal_VkSubmitInfo_pCommandBuffers[i].data();
            /* VkSubmitInfo::pSignalSemaphores */
            internal_VkSubmitInfo_pSignalSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkSubmitInfo_pSignalSemaphores[i] = transformVkSemaphoreList(
                internal_pSubmits[i].pSignalSemaphores, internal_pSubmits[i].signalSemaphoreCount);
            internal_pSubmits[i].pSignalSemaphores =
                internal_VkSubmitInfo_pSignalSemaphores[i].data();
            internal_pSubmits[i].signalSemaphoreCount =
                internal_VkSubmitInfo_pSignalSemaphores[i].size();
        }
        vkEnc->vkQueueSubmitAsyncGOOGLE(
            gfxstream_queue->internal_object, submitCount, internal_pSubmits.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
            true /* do lock */);
    }
}
void gfxstream_vk_QueueWaitIdleAsyncGOOGLE(VkQueue queue) {
    AEMU_SCOPED_TRACE("vkQueueWaitIdleAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        vkEnc->vkQueueWaitIdleAsyncGOOGLE(gfxstream_queue->internal_object, true /* do lock */);
    }
}
void gfxstream_vk_QueueBindSparseAsyncGOOGLE(VkQueue queue, uint32_t bindInfoCount,
                                             const VkBindSparseInfo* pBindInfo, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueBindSparseAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkBindSparseInfo> internal_pBindInfo(bindInfoCount);
        std::vector<std::vector<VkSemaphore>> internal_VkBindSparseInfo_pWaitSemaphores;
        std::vector<std::vector<VkSparseBufferMemoryBindInfo>>
            internal_VkBindSparseInfo_pBufferBinds;
        std::vector<std::vector<VkSparseMemoryBind>> internal_VkSparseBufferMemoryBindInfo_pBinds;
        std::vector<std::vector<VkSparseImageOpaqueMemoryBindInfo>>
            internal_VkBindSparseInfo_pImageOpaqueBinds;
        std::vector<std::vector<VkSparseMemoryBind>>
            internal_VkSparseImageOpaqueMemoryBindInfo_pBinds;
        std::vector<std::vector<VkSparseImageMemoryBindInfo>> internal_VkBindSparseInfo_pImageBinds;
        std::vector<std::vector<VkSparseImageMemoryBind>>
            internal_VkSparseImageMemoryBindInfo_pBinds;
        std::vector<std::vector<VkSemaphore>> internal_VkBindSparseInfo_pSignalSemaphores;
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            internal_pBindInfo[i] = pBindInfo[i];
            /* VkBindSparseInfo::pWaitSemaphores */
            internal_VkBindSparseInfo_pWaitSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkBindSparseInfo_pWaitSemaphores[i] = transformVkSemaphoreList(
                internal_pBindInfo[i].pWaitSemaphores, internal_pBindInfo[i].waitSemaphoreCount);
            internal_pBindInfo[i].pWaitSemaphores =
                internal_VkBindSparseInfo_pWaitSemaphores[i].data();
            internal_pBindInfo[i].waitSemaphoreCount =
                internal_VkBindSparseInfo_pWaitSemaphores[i].size();
            /* VkBindSparseInfo::pBufferBinds */
            internal_VkBindSparseInfo_pBufferBinds.push_back(
                std::vector<VkSparseBufferMemoryBindInfo>());
            internal_VkBindSparseInfo_pBufferBinds[i].reserve(
                internal_pBindInfo[i].bufferBindCount);
            memset(&internal_VkBindSparseInfo_pBufferBinds[i][0], 0,
                   sizeof(VkSparseBufferMemoryBindInfo) * internal_pBindInfo[i].bufferBindCount);
            for (uint32_t j = 0; j < internal_pBindInfo[i].bufferBindCount; ++j) {
                internal_VkBindSparseInfo_pBufferBinds[i][j] =
                    internal_pBindInfo[i].pBufferBinds[j];
                /* VkSparseBufferMemoryBindInfo::buffer */
                VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                               internal_VkBindSparseInfo_pBufferBinds[i][j].buffer);
                internal_VkBindSparseInfo_pBufferBinds[i][j].buffer =
                    gfxstream_buffer->internal_object;
                /* VkSparseBufferMemoryBindInfo::pBinds */
                internal_VkSparseBufferMemoryBindInfo_pBinds.push_back(
                    std::vector<VkSparseMemoryBind>());
                internal_VkSparseBufferMemoryBindInfo_pBinds[j].reserve(
                    internal_VkBindSparseInfo_pBufferBinds[i][j].bindCount);
                memset(&internal_VkSparseBufferMemoryBindInfo_pBinds[j][0], 0,
                       sizeof(VkSparseMemoryBind) *
                           internal_VkBindSparseInfo_pBufferBinds[i][j].bindCount);
                for (uint32_t k = 0; k < internal_VkBindSparseInfo_pBufferBinds[i][j].bindCount;
                     ++k) {
                    internal_VkSparseBufferMemoryBindInfo_pBinds[j][k] =
                        internal_VkBindSparseInfo_pBufferBinds[i][j].pBinds[k];
                    /* VkSparseMemoryBind::memory */
                    if (internal_VkSparseBufferMemoryBindInfo_pBinds[j][k].memory) {
                        VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                                       internal_VkSparseBufferMemoryBindInfo_pBinds[j][k].memory);
                        internal_VkSparseBufferMemoryBindInfo_pBinds[j][k].memory =
                            gfxstream_memory->internal_object;
                    }
                }
                internal_VkBindSparseInfo_pBufferBinds[i][j].pBinds =
                    internal_VkSparseBufferMemoryBindInfo_pBinds[j].data();
            }
            internal_pBindInfo[i].pBufferBinds = internal_VkBindSparseInfo_pBufferBinds[i].data();
            /* VkBindSparseInfo::pImageOpaqueBinds */
            internal_VkBindSparseInfo_pImageOpaqueBinds.push_back(
                std::vector<VkSparseImageOpaqueMemoryBindInfo>());
            internal_VkBindSparseInfo_pImageOpaqueBinds[i].reserve(
                internal_pBindInfo[i].imageOpaqueBindCount);
            memset(&internal_VkBindSparseInfo_pImageOpaqueBinds[i][0], 0,
                   sizeof(VkSparseImageOpaqueMemoryBindInfo) *
                       internal_pBindInfo[i].imageOpaqueBindCount);
            for (uint32_t j = 0; j < internal_pBindInfo[i].imageOpaqueBindCount; ++j) {
                internal_VkBindSparseInfo_pImageOpaqueBinds[i][j] =
                    internal_pBindInfo[i].pImageOpaqueBinds[j];
                /* VkSparseImageOpaqueMemoryBindInfo::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].image);
                internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].image =
                    gfxstream_image->internal_object;
                /* VkSparseImageOpaqueMemoryBindInfo::pBinds */
                internal_VkSparseImageOpaqueMemoryBindInfo_pBinds.push_back(
                    std::vector<VkSparseMemoryBind>());
                internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j].reserve(
                    internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].bindCount);
                memset(&internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][0], 0,
                       sizeof(VkSparseMemoryBind) *
                           internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].bindCount);
                for (uint32_t l = 0;
                     l < internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].bindCount; ++l) {
                    internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l] =
                        internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].pBinds[l];
                    /* VkSparseMemoryBind::memory */
                    if (internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l].memory) {
                        VK_FROM_HANDLE(
                            gfxstream_vk_device_memory, gfxstream_memory,
                            internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l].memory);
                        internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j][l].memory =
                            gfxstream_memory->internal_object;
                    }
                }
                internal_VkBindSparseInfo_pImageOpaqueBinds[i][j].pBinds =
                    internal_VkSparseImageOpaqueMemoryBindInfo_pBinds[j].data();
            }
            internal_pBindInfo[i].pImageOpaqueBinds =
                internal_VkBindSparseInfo_pImageOpaqueBinds[i].data();
            /* VkBindSparseInfo::pImageBinds */
            internal_VkBindSparseInfo_pImageBinds.push_back(
                std::vector<VkSparseImageMemoryBindInfo>());
            internal_VkBindSparseInfo_pImageBinds[i].reserve(internal_pBindInfo[i].imageBindCount);
            memset(&internal_VkBindSparseInfo_pImageBinds[i][0], 0,
                   sizeof(VkSparseImageMemoryBindInfo) * internal_pBindInfo[i].imageBindCount);
            for (uint32_t j = 0; j < internal_pBindInfo[i].imageBindCount; ++j) {
                internal_VkBindSparseInfo_pImageBinds[i][j] = internal_pBindInfo[i].pImageBinds[j];
                /* VkSparseImageMemoryBindInfo::image */
                VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image,
                               internal_VkBindSparseInfo_pImageBinds[i][j].image);
                internal_VkBindSparseInfo_pImageBinds[i][j].image =
                    gfxstream_image->internal_object;
                /* VkSparseImageMemoryBindInfo::pBinds */
                internal_VkSparseImageMemoryBindInfo_pBinds.push_back(
                    std::vector<VkSparseImageMemoryBind>());
                internal_VkSparseImageMemoryBindInfo_pBinds[j].reserve(
                    internal_VkBindSparseInfo_pImageBinds[i][j].bindCount);
                memset(&internal_VkSparseImageMemoryBindInfo_pBinds[j][0], 0,
                       sizeof(VkSparseImageMemoryBind) *
                           internal_VkBindSparseInfo_pImageBinds[i][j].bindCount);
                for (uint32_t m = 0; m < internal_VkBindSparseInfo_pImageBinds[i][j].bindCount;
                     ++m) {
                    internal_VkSparseImageMemoryBindInfo_pBinds[j][m] =
                        internal_VkBindSparseInfo_pImageBinds[i][j].pBinds[m];
                    /* VkSparseImageMemoryBind::memory */
                    if (internal_VkSparseImageMemoryBindInfo_pBinds[j][m].memory) {
                        VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory,
                                       internal_VkSparseImageMemoryBindInfo_pBinds[j][m].memory);
                        internal_VkSparseImageMemoryBindInfo_pBinds[j][m].memory =
                            gfxstream_memory->internal_object;
                    }
                }
                internal_VkBindSparseInfo_pImageBinds[i][j].pBinds =
                    internal_VkSparseImageMemoryBindInfo_pBinds[j].data();
            }
            internal_pBindInfo[i].pImageBinds = internal_VkBindSparseInfo_pImageBinds[i].data();
            /* VkBindSparseInfo::pSignalSemaphores */
            internal_VkBindSparseInfo_pSignalSemaphores.push_back(std::vector<VkSemaphore>());
            internal_VkBindSparseInfo_pSignalSemaphores[i] =
                transformVkSemaphoreList(internal_pBindInfo[i].pSignalSemaphores,
                                         internal_pBindInfo[i].signalSemaphoreCount);
            internal_pBindInfo[i].pSignalSemaphores =
                internal_VkBindSparseInfo_pSignalSemaphores[i].data();
            internal_pBindInfo[i].signalSemaphoreCount =
                internal_VkBindSparseInfo_pSignalSemaphores[i].size();
        }
        vkEnc->vkQueueBindSparseAsyncGOOGLE(
            gfxstream_queue->internal_object, bindInfoCount, internal_pBindInfo.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
            true /* do lock */);
    }
}
void gfxstream_vk_GetLinearImageLayoutGOOGLE(VkDevice device, VkFormat format,
                                             VkDeviceSize* pOffset,
                                             VkDeviceSize* pRowPitchAlignment) {
    AEMU_SCOPED_TRACE("vkGetLinearImageLayoutGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetLinearImageLayoutGOOGLE(gfxstream_device->internal_object, format, pOffset,
                                            pRowPitchAlignment, true /* do lock */);
    }
}
void gfxstream_vk_GetLinearImageLayout2GOOGLE(VkDevice device, const VkImageCreateInfo* pCreateInfo,
                                              VkDeviceSize* pOffset,
                                              VkDeviceSize* pRowPitchAlignment) {
    AEMU_SCOPED_TRACE("vkGetLinearImageLayout2GOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkGetLinearImageLayout2GOOGLE(gfxstream_device->internal_object, pCreateInfo,
                                             pOffset, pRowPitchAlignment, true /* do lock */);
    }
}
void gfxstream_vk_QueueFlushCommandsGOOGLE(VkQueue queue, VkCommandBuffer commandBuffer,
                                           VkDeviceSize dataSize, const void* pData) {
    AEMU_SCOPED_TRACE("vkQueueFlushCommandsGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        vkEnc->vkQueueFlushCommandsGOOGLE(gfxstream_queue->internal_object,
                                          gfxstream_commandBuffer->internal_object, dataSize, pData,
                                          true /* do lock */);
    }
}
void gfxstream_vk_CollectDescriptorPoolIdsGOOGLE(VkDevice device, VkDescriptorPool descriptorPool,
                                                 uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
    AEMU_SCOPED_TRACE("vkCollectDescriptorPoolIdsGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_pool, gfxstream_descriptorPool, descriptorPool);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkEnc->vkCollectDescriptorPoolIdsGOOGLE(gfxstream_device->internal_object,
                                                gfxstream_descriptorPool->internal_object,
                                                pPoolIdCount, pPoolIds, true /* do lock */);
    }
}
void gfxstream_vk_QueueSignalReleaseImageANDROIDAsyncGOOGLE(VkQueue queue,
                                                            uint32_t waitSemaphoreCount,
                                                            const VkSemaphore* pWaitSemaphores,
                                                            VkImage image) {
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROIDAsyncGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_image, gfxstream_image, image);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSemaphore> internal_pWaitSemaphores(waitSemaphoreCount);
        internal_pWaitSemaphores = transformVkSemaphoreList(pWaitSemaphores, waitSemaphoreCount);
        pWaitSemaphores = internal_pWaitSemaphores.data();
        waitSemaphoreCount = internal_pWaitSemaphores.size();
        vkEnc->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
            gfxstream_queue->internal_object, waitSemaphoreCount, internal_pWaitSemaphores.data(),
            gfxstream_image->internal_object, true /* do lock */);
    }
}
void gfxstream_vk_QueueFlushCommandsFromAuxMemoryGOOGLE(VkQueue queue,
                                                        VkCommandBuffer commandBuffer,
                                                        VkDeviceMemory deviceMemory,
                                                        VkDeviceSize dataOffset,
                                                        VkDeviceSize dataSize) {
    AEMU_SCOPED_TRACE("vkQueueFlushCommandsFromAuxMemoryGOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer, commandBuffer);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_deviceMemory, deviceMemory);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        vkEnc->vkQueueFlushCommandsFromAuxMemoryGOOGLE(
            gfxstream_queue->internal_object, gfxstream_commandBuffer->internal_object,
            gfxstream_deviceMemory->internal_object, dataOffset, dataSize, true /* do lock */);
    }
}
VkResult gfxstream_vk_GetBlobGOOGLE(VkDevice device, VkDeviceMemory memory) {
    AEMU_SCOPED_TRACE("vkGetBlobGOOGLE");
    VkResult vkGetBlobGOOGLE_VkResult_return = (VkResult)0;
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_device_memory, gfxstream_memory, memory);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        vkGetBlobGOOGLE_VkResult_return =
            vkEnc->vkGetBlobGOOGLE(gfxstream_device->internal_object,
                                   gfxstream_memory->internal_object, true /* do lock */);
    }
    return vkGetBlobGOOGLE_VkResult_return;
}
void gfxstream_vk_UpdateDescriptorSetWithTemplateSized2GOOGLE(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
    uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
    const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
    const uint8_t* pInlineUniformBlockData) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSized2GOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_device, gfxstream_device, device);
    VK_FROM_HANDLE(gfxstream_vk_descriptor_update_template, gfxstream_descriptorUpdateTemplate,
                   descriptorUpdateTemplate);
    {
        auto vkEnc = gfxstream::vk::ResourceTracker::getThreadLocalEncoder();
        std::vector<VkDescriptorImageInfo> internal_pImageInfos(imageInfoCount);
        for (uint32_t i = 0; i < imageInfoCount; ++i) {
            if (pImageInfos) {
                internal_pImageInfos[i] = pImageInfos[i];
                /* VkDescriptorImageInfo::imageView */
                if (internal_pImageInfos[i].imageView) {
                    VK_FROM_HANDLE(gfxstream_vk_image_view, gfxstream_imageView,
                                   internal_pImageInfos[i].imageView);
                    internal_pImageInfos[i].imageView = gfxstream_imageView->internal_object;
                }
            }
        }
        std::vector<VkDescriptorBufferInfo> internal_pBufferInfos(bufferInfoCount);
        for (uint32_t i = 0; i < bufferInfoCount; ++i) {
            if (pBufferInfos) {
                internal_pBufferInfos[i] = pBufferInfos[i];
                /* VkDescriptorBufferInfo::buffer */
                if (internal_pBufferInfos[i].buffer) {
                    VK_FROM_HANDLE(gfxstream_vk_buffer, gfxstream_buffer,
                                   internal_pBufferInfos[i].buffer);
                    internal_pBufferInfos[i].buffer = gfxstream_buffer->internal_object;
                }
            }
        }
        std::vector<VkBufferView> internal_pBufferViews(bufferViewCount);
        for (uint32_t i = 0; i < bufferViewCount; ++i) {
            if (pBufferViews) {
                VK_FROM_HANDLE(gfxstream_vk_buffer_view, gfxstream_pBufferViews, pBufferViews[i]);
                internal_pBufferViews[i] = gfxstream_pBufferViews->internal_object;
            }
        }
        vkEnc->vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
            gfxstream_device->internal_object, descriptorSet,
            gfxstream_descriptorUpdateTemplate->internal_object, imageInfoCount, bufferInfoCount,
            bufferViewCount, inlineUniformBlockCount, pImageInfoEntryIndices,
            pBufferInfoEntryIndices, pBufferViewEntryIndices, internal_pImageInfos.data(),
            internal_pBufferInfos.data(), internal_pBufferViews.data(), pInlineUniformBlockData,
            true /* do lock */);
    }
}
void gfxstream_vk_QueueSubmitAsync2GOOGLE(VkQueue queue, uint32_t submitCount,
                                          const VkSubmitInfo2* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmitAsync2GOOGLE");
    VK_FROM_HANDLE(gfxstream_vk_queue, gfxstream_queue, queue);
    VK_FROM_HANDLE(gfxstream_vk_fence, gfxstream_fence, fence);
    {
        auto vkEnc =
            gfxstream::vk::ResourceTracker::getQueueEncoder(gfxstream_queue->internal_object);
        std::vector<VkSubmitInfo2> internal_pSubmits(submitCount);
        std::vector<std::vector<VkSemaphoreSubmitInfo>> internal_VkSubmitInfo2_pWaitSemaphoreInfos;
        std::vector<std::vector<VkCommandBufferSubmitInfo>>
            internal_VkSubmitInfo2_pCommandBufferInfos;
        std::vector<std::vector<VkSemaphoreSubmitInfo>>
            internal_VkSubmitInfo2_pSignalSemaphoreInfos;
        for (uint32_t i = 0; i < submitCount; ++i) {
            internal_pSubmits[i] = pSubmits[i];
            /* VkSubmitInfo2::pWaitSemaphoreInfos */
            internal_VkSubmitInfo2_pWaitSemaphoreInfos.push_back(
                std::vector<VkSemaphoreSubmitInfo>());
            internal_VkSubmitInfo2_pWaitSemaphoreInfos[i] =
                transformVkSemaphoreSubmitInfoList(internal_pSubmits[i].pWaitSemaphoreInfos,
                                                   internal_pSubmits[i].waitSemaphoreInfoCount);
            internal_pSubmits[i].pWaitSemaphoreInfos =
                internal_VkSubmitInfo2_pWaitSemaphoreInfos[i].data();
            internal_pSubmits[i].waitSemaphoreInfoCount =
                internal_VkSubmitInfo2_pWaitSemaphoreInfos[i].size();
            /* VkSubmitInfo2::pCommandBufferInfos */
            internal_VkSubmitInfo2_pCommandBufferInfos.push_back(
                std::vector<VkCommandBufferSubmitInfo>());
            internal_VkSubmitInfo2_pCommandBufferInfos[i].reserve(
                internal_pSubmits[i].commandBufferInfoCount);
            memset(&internal_VkSubmitInfo2_pCommandBufferInfos[i][0], 0,
                   sizeof(VkCommandBufferSubmitInfo) * internal_pSubmits[i].commandBufferInfoCount);
            for (uint32_t j = 0; j < internal_pSubmits[i].commandBufferInfoCount; ++j) {
                internal_VkSubmitInfo2_pCommandBufferInfos[i][j] =
                    internal_pSubmits[i].pCommandBufferInfos[j];
                /* VkCommandBufferSubmitInfo::commandBuffer */
                VK_FROM_HANDLE(gfxstream_vk_command_buffer, gfxstream_commandBuffer,
                               internal_VkSubmitInfo2_pCommandBufferInfos[i][j].commandBuffer);
                internal_VkSubmitInfo2_pCommandBufferInfos[i][j].commandBuffer =
                    gfxstream_commandBuffer->internal_object;
            }
            internal_pSubmits[i].pCommandBufferInfos =
                internal_VkSubmitInfo2_pCommandBufferInfos[i].data();
            /* VkSubmitInfo2::pSignalSemaphoreInfos */
            internal_VkSubmitInfo2_pSignalSemaphoreInfos.push_back(
                std::vector<VkSemaphoreSubmitInfo>());
            internal_VkSubmitInfo2_pSignalSemaphoreInfos[i] =
                transformVkSemaphoreSubmitInfoList(internal_pSubmits[i].pSignalSemaphoreInfos,
                                                   internal_pSubmits[i].signalSemaphoreInfoCount);
            internal_pSubmits[i].pSignalSemaphoreInfos =
                internal_VkSubmitInfo2_pSignalSemaphoreInfos[i].data();
            internal_pSubmits[i].signalSemaphoreInfoCount =
                internal_VkSubmitInfo2_pSignalSemaphoreInfos[i].size();
        }
        vkEnc->vkQueueSubmitAsync2GOOGLE(
            gfxstream_queue->internal_object, submitCount, internal_pSubmits.data(),
            gfxstream_fence ? gfxstream_fence->internal_object : VK_NULL_HANDLE,
            true /* do lock */);
    }
}
#endif
#ifdef VK_EXT_load_store_op_none
#endif
#ifdef VK_EXT_image_compression_control_swapchain
#endif
#ifdef VK_QNX_external_memory_screen_buffer
#endif
