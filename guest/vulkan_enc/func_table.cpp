// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module func_table
//
// (impl) generated by codegen/vulkan/scripts/genvk.py -registry codegen/vulkan/xml/vk.xml
// -registryGfxstream codegen/vulkan/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
//
// Please do not modify directly;
// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
// VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
//
// python3 $VULKAN_REGISTRY_SCRIPTS_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o
// $CEREAL_OUTPUT_DIR
//

#include "func_table.h"

#include <log/log.h>

#include <cstring>

#include "../OpenglSystemCommon/HostConnection.h"
#include "ResourceTracker.h"
#include "VkEncoder.h"
#include "goldfish_vk_private_defs.h"

// Stuff we are not going to use but if included,
// will cause compile errors. These are Android Vulkan
// required extensions, but the approach will be to
// implement them completely on the guest side.
#undef VK_KHR_android_surface
#if defined(LINUX_GUEST_BUILD)
#undef VK_ANDROID_native_buffer
#endif

namespace gfxstream {
namespace vk {

static void sOnInvalidDynamicallyCheckedCall(const char* apiname, const char* neededFeature) {
    ALOGE("invalid call to %s: %s not supported", apiname, neededFeature);
    abort();
}
#ifdef VK_VERSION_1_0
static VkResult entry_vkCreateInstance(const VkInstanceCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkInstance* pInstance) {
    AEMU_SCOPED_TRACE("vkCreateInstance");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    vkCreateInstance_VkResult_return =
        vkEnc->vkCreateInstance(pCreateInfo, pAllocator, pInstance, true /* do lock */);
    return vkCreateInstance_VkResult_return;
}
static void entry_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyInstance");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyInstance(instance, pAllocator, true /* do lock */);
}
static VkResult entry_vkEnumeratePhysicalDevices(VkInstance instance,
                                                 uint32_t* pPhysicalDeviceCount,
                                                 VkPhysicalDevice* pPhysicalDevices) {
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDevices");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEnumeratePhysicalDevices_VkResult_return = resources->on_vkEnumeratePhysicalDevices(
        vkEnc, VK_SUCCESS, instance, pPhysicalDeviceCount, pPhysicalDevices);
    return vkEnumeratePhysicalDevices_VkResult_return;
}
static void entry_vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceFeatures* pFeatures) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice,
                                                      VkFormat format,
                                                      VkFormatProperties* pFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties,
                                               true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling,
    VkImageUsageFlags usage, VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceImageFormatProperties_VkResult_return =
        vkEnc->vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage,
                                                        flags, pImageFormatProperties,
                                                        true /* do lock */);
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}
static void entry_vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice,
                                                VkPhysicalDeviceProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceProperties(physicalDevice, pProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount,
                                                    pQueueFamilyProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties,
                                               true /* do lock */);
}
static PFN_vkVoidFunction entry_vkGetInstanceProcAddr(VkInstance instance, const char* pName) {
    AEMU_SCOPED_TRACE("vkGetInstanceProcAddr");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    vkGetInstanceProcAddr_PFN_vkVoidFunction_return =
        vkEnc->vkGetInstanceProcAddr(instance, pName, true /* do lock */);
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}
static PFN_vkVoidFunction entry_vkGetDeviceProcAddr(VkDevice device, const char* pName) {
    AEMU_SCOPED_TRACE("vkGetDeviceProcAddr");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    vkGetDeviceProcAddr_PFN_vkVoidFunction_return =
        vkEnc->vkGetDeviceProcAddr(device, pName, true /* do lock */);
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}
static VkResult entry_vkCreateDevice(VkPhysicalDevice physicalDevice,
                                     const VkDeviceCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
    AEMU_SCOPED_TRACE("vkCreateDevice");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    vkCreateDevice_VkResult_return =
        vkEnc->vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice, true /* do lock */);
    return vkCreateDevice_VkResult_return;
}
static void entry_vkDestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDevice");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDevice(device, pAllocator, true /* do lock */);
}
static VkResult entry_vkEnumerateInstanceExtensionProperties(const char* pLayerName,
                                                             uint32_t* pPropertyCount,
                                                             VkExtensionProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkEnumerateInstanceExtensionProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEnumerateInstanceExtensionProperties_VkResult_return =
        resources->on_vkEnumerateInstanceExtensionProperties(vkEnc, VK_SUCCESS, pLayerName,
                                                             pPropertyCount, pProperties);
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}
static VkResult entry_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice,
                                                           const char* pLayerName,
                                                           uint32_t* pPropertyCount,
                                                           VkExtensionProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkEnumerateDeviceExtensionProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEnumerateDeviceExtensionProperties_VkResult_return =
        resources->on_vkEnumerateDeviceExtensionProperties(vkEnc, VK_SUCCESS, physicalDevice,
                                                           pLayerName, pPropertyCount, pProperties);
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}
static VkResult entry_vkEnumerateInstanceLayerProperties(uint32_t* pPropertyCount,
                                                         VkLayerProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkEnumerateInstanceLayerProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    vkEnumerateInstanceLayerProperties_VkResult_return =
        vkEnc->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties, true /* do lock */);
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}
static VkResult entry_vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice,
                                                       uint32_t* pPropertyCount,
                                                       VkLayerProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkEnumerateDeviceLayerProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    vkEnumerateDeviceLayerProperties_VkResult_return = vkEnc->vkEnumerateDeviceLayerProperties(
        physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}
static void entry_vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex,
                                   VkQueue* pQueue) {
    AEMU_SCOPED_TRACE("vkGetDeviceQueue");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue, true /* do lock */);
}
static VkResult entry_vkQueueSubmit(VkQueue queue, uint32_t submitCount,
                                    const VkSubmitInfo* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmit");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkQueueSubmit_VkResult_return =
        resources->on_vkQueueSubmit(vkEnc, VK_SUCCESS, queue, submitCount, pSubmits, fence);
    return vkQueueSubmit_VkResult_return;
}
static VkResult entry_vkQueueWaitIdle(VkQueue queue) {
    AEMU_SCOPED_TRACE("vkQueueWaitIdle");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkQueueWaitIdle_VkResult_return = resources->on_vkQueueWaitIdle(vkEnc, VK_SUCCESS, queue);
    return vkQueueWaitIdle_VkResult_return;
}
static VkResult entry_vkDeviceWaitIdle(VkDevice device) {
    AEMU_SCOPED_TRACE("vkDeviceWaitIdle");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    vkDeviceWaitIdle_VkResult_return = vkEnc->vkDeviceWaitIdle(device, true /* do lock */);
    return vkDeviceWaitIdle_VkResult_return;
}
static VkResult entry_vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkDeviceMemory* pMemory) {
    AEMU_SCOPED_TRACE("vkAllocateMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkAllocateMemory_VkResult_return = resources->on_vkAllocateMemory(
        vkEnc, VK_SUCCESS, device, pAllocateInfo, pAllocator, pMemory);
    return vkAllocateMemory_VkResult_return;
}
static void entry_vkFreeMemory(VkDevice device, VkDeviceMemory memory,
                               const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkFreeMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkFreeMemory(vkEnc, device, memory, pAllocator);
}
static VkResult entry_vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset,
                                  VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
    AEMU_SCOPED_TRACE("vkMapMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    vkMapMemory_VkResult_return =
        vkEnc->vkMapMemory(device, memory, offset, size, flags, ppData, true /* do lock */);
    return vkMapMemory_VkResult_return;
}
static void entry_vkUnmapMemory(VkDevice device, VkDeviceMemory memory) {
    AEMU_SCOPED_TRACE("vkUnmapMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUnmapMemory(device, memory, true /* do lock */);
}
static VkResult entry_vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                const VkMappedMemoryRange* pMemoryRanges) {
    AEMU_SCOPED_TRACE("vkFlushMappedMemoryRanges");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    vkFlushMappedMemoryRanges_VkResult_return = vkEnc->vkFlushMappedMemoryRanges(
        device, memoryRangeCount, pMemoryRanges, true /* do lock */);
    return vkFlushMappedMemoryRanges_VkResult_return;
}
static VkResult entry_vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                     const VkMappedMemoryRange* pMemoryRanges) {
    AEMU_SCOPED_TRACE("vkInvalidateMappedMemoryRanges");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    vkInvalidateMappedMemoryRanges_VkResult_return = vkEnc->vkInvalidateMappedMemoryRanges(
        device, memoryRangeCount, pMemoryRanges, true /* do lock */);
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}
static void entry_vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory,
                                              VkDeviceSize* pCommittedMemoryInBytes) {
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryCommitment");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes, true /* do lock */);
}
static VkResult entry_vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
                                         VkDeviceSize memoryOffset) {
    AEMU_SCOPED_TRACE("vkBindBufferMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindBufferMemory_VkResult_return =
        resources->on_vkBindBufferMemory(vkEnc, VK_SUCCESS, device, buffer, memory, memoryOffset);
    return vkBindBufferMemory_VkResult_return;
}
static VkResult entry_vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory,
                                        VkDeviceSize memoryOffset) {
    AEMU_SCOPED_TRACE("vkBindImageMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindImageMemory_VkResult_return =
        resources->on_vkBindImageMemory(vkEnc, VK_SUCCESS, device, image, memory, memoryOffset);
    return vkBindImageMemory_VkResult_return;
}
static void entry_vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer,
                                                VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetBufferMemoryRequirements(vkEnc, device, buffer, pMemoryRequirements);
}
static void entry_vkGetImageMemoryRequirements(VkDevice device, VkImage image,
                                               VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetImageMemoryRequirements(vkEnc, device, image, pMemoryRequirements);
}
static void entry_vkGetImageSparseMemoryRequirements(
    VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount,
                                              pSparseMemoryRequirements, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
    VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples,
                                                          usage, tiling, pPropertyCount,
                                                          pProperties, true /* do lock */);
}
static VkResult entry_vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount,
                                        const VkBindSparseInfo* pBindInfo, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueBindSparse");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    vkQueueBindSparse_VkResult_return =
        vkEnc->vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence, true /* do lock */);
    return vkQueueBindSparse_VkResult_return;
}
static VkResult entry_vkCreateFence(VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
    AEMU_SCOPED_TRACE("vkCreateFence");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateFence_VkResult_return =
        resources->on_vkCreateFence(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pFence);
    return vkCreateFence_VkResult_return;
}
static void entry_vkDestroyFence(VkDevice device, VkFence fence,
                                 const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyFence");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyFence(device, fence, pAllocator, true /* do lock */);
}
static VkResult entry_vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences) {
    AEMU_SCOPED_TRACE("vkResetFences");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkResetFences_VkResult_return =
        resources->on_vkResetFences(vkEnc, VK_SUCCESS, device, fenceCount, pFences);
    return vkResetFences_VkResult_return;
}
static VkResult entry_vkGetFenceStatus(VkDevice device, VkFence fence) {
    AEMU_SCOPED_TRACE("vkGetFenceStatus");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    vkGetFenceStatus_VkResult_return = vkEnc->vkGetFenceStatus(device, fence, true /* do lock */);
    return vkGetFenceStatus_VkResult_return;
}
static VkResult entry_vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences,
                                      VkBool32 waitAll, uint64_t timeout) {
    AEMU_SCOPED_TRACE("vkWaitForFences");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkWaitForFences_VkResult_return = resources->on_vkWaitForFences(
        vkEnc, VK_SUCCESS, device, fenceCount, pFences, waitAll, timeout);
    return vkWaitForFences_VkResult_return;
}
static VkResult entry_vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkSemaphore* pSemaphore) {
    AEMU_SCOPED_TRACE("vkCreateSemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSemaphore_VkResult_return = resources->on_vkCreateSemaphore(
        vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pSemaphore);
    return vkCreateSemaphore_VkResult_return;
}
static void entry_vkDestroySemaphore(VkDevice device, VkSemaphore semaphore,
                                     const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroySemaphore(vkEnc, device, semaphore, pAllocator);
}
static VkResult entry_vkCreateEvent(VkDevice device, const VkEventCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
    AEMU_SCOPED_TRACE("vkCreateEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    vkCreateEvent_VkResult_return =
        vkEnc->vkCreateEvent(device, pCreateInfo, pAllocator, pEvent, true /* do lock */);
    return vkCreateEvent_VkResult_return;
}
static void entry_vkDestroyEvent(VkDevice device, VkEvent event,
                                 const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyEvent(device, event, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetEventStatus(VkDevice device, VkEvent event) {
    AEMU_SCOPED_TRACE("vkGetEventStatus");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    vkGetEventStatus_VkResult_return = vkEnc->vkGetEventStatus(device, event, true /* do lock */);
    return vkGetEventStatus_VkResult_return;
}
static VkResult entry_vkSetEvent(VkDevice device, VkEvent event) {
    AEMU_SCOPED_TRACE("vkSetEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    vkSetEvent_VkResult_return = vkEnc->vkSetEvent(device, event, true /* do lock */);
    return vkSetEvent_VkResult_return;
}
static VkResult entry_vkResetEvent(VkDevice device, VkEvent event) {
    AEMU_SCOPED_TRACE("vkResetEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    vkResetEvent_VkResult_return = vkEnc->vkResetEvent(device, event, true /* do lock */);
    return vkResetEvent_VkResult_return;
}
static VkResult entry_vkCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkQueryPool* pQueryPool) {
    AEMU_SCOPED_TRACE("vkCreateQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    vkCreateQueryPool_VkResult_return =
        vkEnc->vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool, true /* do lock */);
    return vkCreateQueryPool_VkResult_return;
}
static void entry_vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool,
                                     const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyQueryPool(device, queryPool, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool,
                                            uint32_t firstQuery, uint32_t queryCount,
                                            size_t dataSize, void* pData, VkDeviceSize stride,
                                            VkQueryResultFlags flags) {
    AEMU_SCOPED_TRACE("vkGetQueryPoolResults");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    vkGetQueryPoolResults_VkResult_return =
        vkEnc->vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData,
                                     stride, flags, true /* do lock */);
    return vkGetQueryPoolResults_VkResult_return;
}
static VkResult entry_vkCreateBuffer(VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
    AEMU_SCOPED_TRACE("vkCreateBuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateBuffer_VkResult_return =
        resources->on_vkCreateBuffer(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pBuffer);
    return vkCreateBuffer_VkResult_return;
}
static void entry_vkDestroyBuffer(VkDevice device, VkBuffer buffer,
                                  const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyBuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyBuffer(vkEnc, device, buffer, pAllocator);
}
static VkResult entry_vkCreateBufferView(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkBufferView* pView) {
    AEMU_SCOPED_TRACE("vkCreateBufferView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    vkCreateBufferView_VkResult_return =
        vkEnc->vkCreateBufferView(device, pCreateInfo, pAllocator, pView, true /* do lock */);
    return vkCreateBufferView_VkResult_return;
}
static void entry_vkDestroyBufferView(VkDevice device, VkBufferView bufferView,
                                      const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyBufferView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyBufferView(device, bufferView, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateImage(VkDevice device, const VkImageCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
    AEMU_SCOPED_TRACE("vkCreateImage");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateImage_VkResult_return =
        resources->on_vkCreateImage(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pImage);
    return vkCreateImage_VkResult_return;
}
static void entry_vkDestroyImage(VkDevice device, VkImage image,
                                 const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyImage");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyImage(vkEnc, device, image, pAllocator);
}
static void entry_vkGetImageSubresourceLayout(VkDevice device, VkImage image,
                                              const VkImageSubresource* pSubresource,
                                              VkSubresourceLayout* pLayout) {
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSubresourceLayout(device, image, pSubresource, pLayout, true /* do lock */);
}
static VkResult entry_vkCreateImageView(VkDevice device, const VkImageViewCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkImageView* pView) {
    AEMU_SCOPED_TRACE("vkCreateImageView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateImageView_VkResult_return =
        resources->on_vkCreateImageView(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pView);
    return vkCreateImageView_VkResult_return;
}
static void entry_vkDestroyImageView(VkDevice device, VkImageView imageView,
                                     const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyImageView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyImageView(device, imageView, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateShaderModule(VkDevice device,
                                           const VkShaderModuleCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkShaderModule* pShaderModule) {
    AEMU_SCOPED_TRACE("vkCreateShaderModule");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    vkCreateShaderModule_VkResult_return = vkEnc->vkCreateShaderModule(
        device, pCreateInfo, pAllocator, pShaderModule, true /* do lock */);
    return vkCreateShaderModule_VkResult_return;
}
static void entry_vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule,
                                        const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyShaderModule");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyShaderModule(device, shaderModule, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreatePipelineCache(VkDevice device,
                                            const VkPipelineCacheCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkPipelineCache* pPipelineCache) {
    AEMU_SCOPED_TRACE("vkCreatePipelineCache");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    vkCreatePipelineCache_VkResult_return = vkEnc->vkCreatePipelineCache(
        device, pCreateInfo, pAllocator, pPipelineCache, true /* do lock */);
    return vkCreatePipelineCache_VkResult_return;
}
static void entry_vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache,
                                         const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPipelineCache");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPipelineCache(device, pipelineCache, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache,
                                             size_t* pDataSize, void* pData) {
    AEMU_SCOPED_TRACE("vkGetPipelineCacheData");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    vkGetPipelineCacheData_VkResult_return =
        vkEnc->vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData, true /* do lock */);
    return vkGetPipelineCacheData_VkResult_return;
}
static VkResult entry_vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache,
                                            uint32_t srcCacheCount,
                                            const VkPipelineCache* pSrcCaches) {
    AEMU_SCOPED_TRACE("vkMergePipelineCaches");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    vkMergePipelineCaches_VkResult_return = vkEnc->vkMergePipelineCaches(
        device, dstCache, srcCacheCount, pSrcCaches, true /* do lock */);
    return vkMergePipelineCaches_VkResult_return;
}
static VkResult entry_vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache,
                                                uint32_t createInfoCount,
                                                const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                                const VkAllocationCallbacks* pAllocator,
                                                VkPipeline* pPipelines) {
    AEMU_SCOPED_TRACE("vkCreateGraphicsPipelines");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateGraphicsPipelines_VkResult_return = resources->on_vkCreateGraphicsPipelines(
        vkEnc, VK_SUCCESS, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
        pPipelines);
    return vkCreateGraphicsPipelines_VkResult_return;
}
static VkResult entry_vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache,
                                               uint32_t createInfoCount,
                                               const VkComputePipelineCreateInfo* pCreateInfos,
                                               const VkAllocationCallbacks* pAllocator,
                                               VkPipeline* pPipelines) {
    AEMU_SCOPED_TRACE("vkCreateComputePipelines");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    vkCreateComputePipelines_VkResult_return =
        vkEnc->vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos,
                                        pAllocator, pPipelines, true /* do lock */);
    return vkCreateComputePipelines_VkResult_return;
}
static void entry_vkDestroyPipeline(VkDevice device, VkPipeline pipeline,
                                    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPipeline");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPipeline(device, pipeline, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreatePipelineLayout(VkDevice device,
                                             const VkPipelineLayoutCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkPipelineLayout* pPipelineLayout) {
    AEMU_SCOPED_TRACE("vkCreatePipelineLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    vkCreatePipelineLayout_VkResult_return = vkEnc->vkCreatePipelineLayout(
        device, pCreateInfo, pAllocator, pPipelineLayout, true /* do lock */);
    return vkCreatePipelineLayout_VkResult_return;
}
static void entry_vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout,
                                          const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPipelineLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPipelineLayout(device, pipelineLayout, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateSampler(VkDevice device, const VkSamplerCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkSampler* pSampler) {
    AEMU_SCOPED_TRACE("vkCreateSampler");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSampler_VkResult_return =
        resources->on_vkCreateSampler(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pSampler);
    return vkCreateSampler_VkResult_return;
}
static void entry_vkDestroySampler(VkDevice device, VkSampler sampler,
                                   const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySampler");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroySampler(device, sampler, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateDescriptorSetLayout(
    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorSetLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateDescriptorSetLayout_VkResult_return = resources->on_vkCreateDescriptorSetLayout(
        vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pSetLayout);
    return vkCreateDescriptorSetLayout_VkResult_return;
}
static void entry_vkDestroyDescriptorSetLayout(VkDevice device,
                                               VkDescriptorSetLayout descriptorSetLayout,
                                               const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorSetLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyDescriptorSetLayout(vkEnc, device, descriptorSetLayout, pAllocator);
}
static VkResult entry_vkCreateDescriptorPool(VkDevice device,
                                             const VkDescriptorPoolCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkDescriptorPool* pDescriptorPool) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateDescriptorPool_VkResult_return = resources->on_vkCreateDescriptorPool(
        vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pDescriptorPool);
    return vkCreateDescriptorPool_VkResult_return;
}
static void entry_vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                          const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyDescriptorPool(vkEnc, device, descriptorPool, pAllocator);
}
static VkResult entry_vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                            VkDescriptorPoolResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetDescriptorPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkResetDescriptorPool_VkResult_return =
        resources->on_vkResetDescriptorPool(vkEnc, VK_SUCCESS, device, descriptorPool, flags);
    return vkResetDescriptorPool_VkResult_return;
}
static VkResult entry_vkAllocateDescriptorSets(VkDevice device,
                                               const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                               VkDescriptorSet* pDescriptorSets) {
    AEMU_SCOPED_TRACE("vkAllocateDescriptorSets");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkAllocateDescriptorSets_VkResult_return = resources->on_vkAllocateDescriptorSets(
        vkEnc, VK_SUCCESS, device, pAllocateInfo, pDescriptorSets);
    return vkAllocateDescriptorSets_VkResult_return;
}
static VkResult entry_vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool,
                                           uint32_t descriptorSetCount,
                                           const VkDescriptorSet* pDescriptorSets) {
    AEMU_SCOPED_TRACE("vkFreeDescriptorSets");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkFreeDescriptorSets_VkResult_return = resources->on_vkFreeDescriptorSets(
        vkEnc, VK_SUCCESS, device, descriptorPool, descriptorSetCount, pDescriptorSets);
    return vkFreeDescriptorSets_VkResult_return;
}
static void entry_vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount,
                                         const VkWriteDescriptorSet* pDescriptorWrites,
                                         uint32_t descriptorCopyCount,
                                         const VkCopyDescriptorSet* pDescriptorCopies) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSets");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkUpdateDescriptorSets(vkEnc, device, descriptorWriteCount, pDescriptorWrites,
                                         descriptorCopyCount, pDescriptorCopies);
}
static VkResult entry_vkCreateFramebuffer(VkDevice device,
                                          const VkFramebufferCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkFramebuffer* pFramebuffer) {
    AEMU_SCOPED_TRACE("vkCreateFramebuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    vkCreateFramebuffer_VkResult_return = vkEnc->vkCreateFramebuffer(
        device, pCreateInfo, pAllocator, pFramebuffer, true /* do lock */);
    return vkCreateFramebuffer_VkResult_return;
}
static void entry_vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer,
                                       const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyFramebuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyFramebuffer(device, framebuffer, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkRenderPass* pRenderPass) {
    AEMU_SCOPED_TRACE("vkCreateRenderPass");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    vkCreateRenderPass_VkResult_return =
        vkEnc->vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass_VkResult_return;
}
static void entry_vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass,
                                      const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyRenderPass");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyRenderPass(device, renderPass, pAllocator, true /* do lock */);
}
static void entry_vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass,
                                             VkExtent2D* pGranularity) {
    AEMU_SCOPED_TRACE("vkGetRenderAreaGranularity");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetRenderAreaGranularity(device, renderPass, pGranularity, true /* do lock */);
}
static VkResult entry_vkCreateCommandPool(VkDevice device,
                                          const VkCommandPoolCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkCommandPool* pCommandPool) {
    AEMU_SCOPED_TRACE("vkCreateCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    vkCreateCommandPool_VkResult_return = vkEnc->vkCreateCommandPool(
        device, pCreateInfo, pAllocator, pCommandPool, true /* do lock */);
    return vkCreateCommandPool_VkResult_return;
}
static void entry_vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool,
                                       const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyCommandPool(device, commandPool, pAllocator, true /* do lock */);
}
static VkResult entry_vkResetCommandPool(VkDevice device, VkCommandPool commandPool,
                                         VkCommandPoolResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    vkResetCommandPool_VkResult_return =
        vkEnc->vkResetCommandPool(device, commandPool, flags, true /* do lock */);
    if (vkResetCommandPool_VkResult_return == VK_SUCCESS) {
        ResourceTracker::get()->resetCommandPoolStagingInfo(commandPool);
    }
    return vkResetCommandPool_VkResult_return;
}
static VkResult entry_vkAllocateCommandBuffers(VkDevice device,
                                               const VkCommandBufferAllocateInfo* pAllocateInfo,
                                               VkCommandBuffer* pCommandBuffers) {
    AEMU_SCOPED_TRACE("vkAllocateCommandBuffers");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkAllocateCommandBuffers_VkResult_return = resources->on_vkAllocateCommandBuffers(
        vkEnc, VK_SUCCESS, device, pAllocateInfo, pCommandBuffers);
    if (vkAllocateCommandBuffers_VkResult_return == VK_SUCCESS) {
        ResourceTracker::get()->addToCommandPool(
            pAllocateInfo->commandPool, pAllocateInfo->commandBufferCount, pCommandBuffers);
    }
    return vkAllocateCommandBuffers_VkResult_return;
}
static void entry_vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool,
                                       uint32_t commandBufferCount,
                                       const VkCommandBuffer* pCommandBuffers) {
    AEMU_SCOPED_TRACE("vkFreeCommandBuffers");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers,
                                true /* do lock */);
}
static VkResult entry_vkBeginCommandBuffer(VkCommandBuffer commandBuffer,
                                           const VkCommandBufferBeginInfo* pBeginInfo) {
    AEMU_SCOPED_TRACE("vkBeginCommandBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBeginCommandBuffer_VkResult_return =
        resources->on_vkBeginCommandBuffer(vkEnc, VK_SUCCESS, commandBuffer, pBeginInfo);
    return vkBeginCommandBuffer_VkResult_return;
}
static VkResult entry_vkEndCommandBuffer(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkEndCommandBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEndCommandBuffer_VkResult_return =
        resources->on_vkEndCommandBuffer(vkEnc, VK_SUCCESS, commandBuffer);
    return vkEndCommandBuffer_VkResult_return;
}
static VkResult entry_vkResetCommandBuffer(VkCommandBuffer commandBuffer,
                                           VkCommandBufferResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetCommandBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkResetCommandBuffer_VkResult_return =
        resources->on_vkResetCommandBuffer(vkEnc, VK_SUCCESS, commandBuffer, flags);
    return vkResetCommandBuffer_VkResult_return;
}
static void entry_vkCmdBindPipeline(VkCommandBuffer commandBuffer,
                                    VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    AEMU_SCOPED_TRACE("vkCmdBindPipeline");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline, true /* do lock */);
}
static void entry_vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                   uint32_t viewportCount, const VkViewport* pViewports) {
    AEMU_SCOPED_TRACE("vkCmdSetViewport");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports,
                            true /* do lock */);
}
static void entry_vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor,
                                  uint32_t scissorCount, const VkRect2D* pScissors) {
    AEMU_SCOPED_TRACE("vkCmdSetScissor");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors,
                           true /* do lock */);
}
static void entry_vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
    AEMU_SCOPED_TRACE("vkCmdSetLineWidth");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetLineWidth(commandBuffer, lineWidth, true /* do lock */);
}
static void entry_vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor,
                                    float depthBiasClamp, float depthBiasSlopeFactor) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBias");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp,
                             depthBiasSlopeFactor, true /* do lock */);
}
static void entry_vkCmdSetBlendConstants(VkCommandBuffer commandBuffer,
                                         const float blendConstants[4]) {
    AEMU_SCOPED_TRACE("vkCmdSetBlendConstants");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetBlendConstants(commandBuffer, blendConstants, true /* do lock */);
}
static void entry_vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds,
                                      float maxDepthBounds) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBounds");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds, true /* do lock */);
}
static void entry_vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer,
                                             VkStencilFaceFlags faceMask, uint32_t compareMask) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilCompareMask");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask, true /* do lock */);
}
static void entry_vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer,
                                           VkStencilFaceFlags faceMask, uint32_t writeMask) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilWriteMask");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask, true /* do lock */);
}
static void entry_vkCmdSetStencilReference(VkCommandBuffer commandBuffer,
                                           VkStencilFaceFlags faceMask, uint32_t reference) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilReference");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilReference(commandBuffer, faceMask, reference, true /* do lock */);
}
static void entry_vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
    uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
    AEMU_SCOPED_TRACE("vkCmdBindDescriptorSets");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    auto resources = ResourceTracker::get();
    resources->on_vkCmdBindDescriptorSets(vkEnc, commandBuffer, pipelineBindPoint, layout, firstSet,
                                          descriptorSetCount, pDescriptorSets, dynamicOffsetCount,
                                          pDynamicOffsets);
}
static void entry_vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                       VkDeviceSize offset, VkIndexType indexType) {
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType, true /* do lock */);
}
static void entry_vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                         uint32_t bindingCount, const VkBuffer* pBuffers,
                                         const VkDeviceSize* pOffsets) {
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets,
                                  true /* do lock */);
}
static void entry_vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount,
                            uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
    AEMU_SCOPED_TRACE("vkCmdDraw");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance,
                     true /* do lock */);
}
static void entry_vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount,
                                   uint32_t instanceCount, uint32_t firstIndex,
                                   int32_t vertexOffset, uint32_t firstInstance) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndexed");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset,
                            firstInstance, true /* do lock */);
}
static void entry_vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                    VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndirect");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                           VkDeviceSize offset, uint32_t drawCount,
                                           uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirect");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride,
                                    true /* do lock */);
}
static void entry_vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX,
                                uint32_t groupCountY, uint32_t groupCountZ) {
    AEMU_SCOPED_TRACE("vkCmdDispatch");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ, true /* do lock */);
}
static void entry_vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                        VkDeviceSize offset) {
    AEMU_SCOPED_TRACE("vkCmdDispatchIndirect");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatchIndirect(commandBuffer, buffer, offset, true /* do lock */);
}
static void entry_vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                  VkBuffer dstBuffer, uint32_t regionCount,
                                  const VkBufferCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions,
                           true /* do lock */);
}
static void entry_vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                 VkImageLayout srcImageLayout, VkImage dstImage,
                                 VkImageLayout dstImageLayout, uint32_t regionCount,
                                 const VkImageCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout,
                          regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                 VkImageLayout srcImageLayout, VkImage dstImage,
                                 VkImageLayout dstImageLayout, uint32_t regionCount,
                                 const VkImageBlit* pRegions, VkFilter filter) {
    AEMU_SCOPED_TRACE("vkCmdBlitImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout,
                          regionCount, pRegions, filter, true /* do lock */);
}
static void entry_vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                         VkImage dstImage, VkImageLayout dstImageLayout,
                                         uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount,
                                  pRegions, true /* do lock */);
}
static void entry_vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage,
                                         VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                         uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount,
                                  pRegions, true /* do lock */);
}
static void entry_vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                    VkDeviceSize dstOffset, VkDeviceSize dataSize,
                                    const void* pData) {
    AEMU_SCOPED_TRACE("vkCmdUpdateBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData,
                             true /* do lock */);
}
static void entry_vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                  VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    AEMU_SCOPED_TRACE("vkCmdFillBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data, true /* do lock */);
}
static void entry_vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image,
                                       VkImageLayout imageLayout, const VkClearColorValue* pColor,
                                       uint32_t rangeCount,
                                       const VkImageSubresourceRange* pRanges) {
    AEMU_SCOPED_TRACE("vkCmdClearColorImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges,
                                true /* do lock */);
}
static void entry_vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image,
                                              VkImageLayout imageLayout,
                                              const VkClearDepthStencilValue* pDepthStencil,
                                              uint32_t rangeCount,
                                              const VkImageSubresourceRange* pRanges) {
    AEMU_SCOPED_TRACE("vkCmdClearDepthStencilImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount,
                                       pRanges, true /* do lock */);
}
static void entry_vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                        const VkClearAttachment* pAttachments, uint32_t rectCount,
                                        const VkClearRect* pRects) {
    AEMU_SCOPED_TRACE("vkCmdClearAttachments");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects,
                                 true /* do lock */);
}
static void entry_vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                    VkImageLayout srcImageLayout, VkImage dstImage,
                                    VkImageLayout dstImageLayout, uint32_t regionCount,
                                    const VkImageResolve* pRegions) {
    AEMU_SCOPED_TRACE("vkCmdResolveImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout,
                             regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event,
                                VkPipelineStageFlags stageMask) {
    AEMU_SCOPED_TRACE("vkCmdSetEvent");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetEvent(commandBuffer, event, stageMask, true /* do lock */);
}
static void entry_vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event,
                                  VkPipelineStageFlags stageMask) {
    AEMU_SCOPED_TRACE("vkCmdResetEvent");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResetEvent(commandBuffer, event, stageMask, true /* do lock */);
}
static void entry_vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                  const VkEvent* pEvents, VkPipelineStageFlags srcStageMask,
                                  VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount,
                                  const VkMemoryBarrier* pMemoryBarriers,
                                  uint32_t bufferMemoryBarrierCount,
                                  const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                                  uint32_t imageMemoryBarrierCount,
                                  const VkImageMemoryBarrier* pImageMemoryBarriers) {
    AEMU_SCOPED_TRACE("vkCmdWaitEvents");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask,
                           memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
                           pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers,
                           true /* do lock */);
}
static void entry_vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    auto resources = ResourceTracker::get();
    resources->on_vkCmdPipelineBarrier(vkEnc, commandBuffer, srcStageMask, dstStageMask,
                                       dependencyFlags, memoryBarrierCount, pMemoryBarriers,
                                       bufferMemoryBarrierCount, pBufferMemoryBarriers,
                                       imageMemoryBarrierCount, pImageMemoryBarriers);
}
static void entry_vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                  uint32_t query, VkQueryControlFlags flags) {
    AEMU_SCOPED_TRACE("vkCmdBeginQuery");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginQuery(commandBuffer, queryPool, query, flags, true /* do lock */);
}
static void entry_vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdEndQuery");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndQuery(commandBuffer, queryPool, query, true /* do lock */);
}
static void entry_vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                      uint32_t firstQuery, uint32_t queryCount) {
    AEMU_SCOPED_TRACE("vkCmdResetQueryPool");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount,
                               true /* do lock */);
}
static void entry_vkCmdWriteTimestamp(VkCommandBuffer commandBuffer,
                                      VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool,
                                      uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query, true /* do lock */);
}
static void entry_vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                            uint32_t firstQuery, uint32_t queryCount,
                                            VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                            VkDeviceSize stride, VkQueryResultFlags flags) {
    AEMU_SCOPED_TRACE("vkCmdCopyQueryPoolResults");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer,
                                     dstOffset, stride, flags, true /* do lock */);
}
static void entry_vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                     VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
                                     const void* pValues) {
    AEMU_SCOPED_TRACE("vkCmdPushConstants");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues,
                              true /* do lock */);
}
static void entry_vkCmdBeginRenderPass(VkCommandBuffer commandBuffer,
                                       const VkRenderPassBeginInfo* pRenderPassBegin,
                                       VkSubpassContents contents) {
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents, true /* do lock */);
}
static void entry_vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
    AEMU_SCOPED_TRACE("vkCmdNextSubpass");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass(commandBuffer, contents, true /* do lock */);
}
static void entry_vkCmdEndRenderPass(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass(commandBuffer, true /* do lock */);
}
static void entry_vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                       const VkCommandBuffer* pCommandBuffers) {
    AEMU_SCOPED_TRACE("vkCmdExecuteCommands");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    auto resources = ResourceTracker::get();
    resources->on_vkCmdExecuteCommands(vkEnc, commandBuffer, commandBufferCount, pCommandBuffers);
}
#endif
#ifdef VK_VERSION_1_1
static VkResult entry_vkEnumerateInstanceVersion(uint32_t* pApiVersion) {
    AEMU_SCOPED_TRACE("vkEnumerateInstanceVersion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    vkEnumerateInstanceVersion_VkResult_return =
        vkEnc->vkEnumerateInstanceVersion(pApiVersion, true /* do lock */);
    return vkEnumerateInstanceVersion_VkResult_return;
}
static VkResult entry_vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount,
                                          const VkBindBufferMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindBufferMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindBufferMemory2_VkResult_return =
        resources->on_vkBindBufferMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2_VkResult_return;
}
static VkResult dynCheck_entry_vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount,
                                                   const VkBindBufferMemoryInfo* pBindInfos) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkBindBufferMemory2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkBindBufferMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    vkBindBufferMemory2_VkResult_return =
        resources->on_vkBindBufferMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2_VkResult_return;
}
static VkResult entry_vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount,
                                         const VkBindImageMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindImageMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindImageMemory2_VkResult_return =
        resources->on_vkBindImageMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2_VkResult_return;
}
static VkResult dynCheck_entry_vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount,
                                                  const VkBindImageMemoryInfo* pBindInfos) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkBindImageMemory2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkBindImageMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    vkBindImageMemory2_VkResult_return =
        resources->on_vkBindImageMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2_VkResult_return;
}
static void entry_vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex,
                                              remoteDeviceIndex, pPeerMemoryFeatures,
                                              true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceGroupPeerMemoryFeatures", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex,
                                              remoteDeviceIndex, pPeerMemoryFeatures,
                                              true /* do lock */);
}
static void entry_vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMask");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDeviceMask(commandBuffer, deviceMask, true /* do lock */);
}
static void entry_vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX,
                                    uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX,
                                    uint32_t groupCountY, uint32_t groupCountZ) {
    AEMU_SCOPED_TRACE("vkCmdDispatchBase");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX,
                             groupCountY, groupCountZ, true /* do lock */);
}
static VkResult entry_vkEnumeratePhysicalDeviceGroups(
    VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroups");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    vkEnumeratePhysicalDeviceGroups_VkResult_return = vkEnc->vkEnumeratePhysicalDeviceGroups(
        instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, true /* do lock */);
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}
static void entry_vkGetImageMemoryRequirements2(VkDevice device,
                                                const VkImageMemoryRequirementsInfo2* pInfo,
                                                VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetImageMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetImageMemoryRequirements2(
    VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkGetImageMemoryRequirements2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetImageMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetBufferMemoryRequirements2(VkDevice device,
                                                 const VkBufferMemoryRequirementsInfo2* pInfo,
                                                 VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetBufferMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetBufferMemoryRequirements2(
    VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferMemoryRequirements2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetBufferMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetImageSparseMemoryRequirements2(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount,
                                               pSparseMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetImageSparseMemoryRequirements2(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkGetImageSparseMemoryRequirements2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount,
                                               pSparseMemoryRequirements, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
                                               VkPhysicalDeviceFeatures2* pFeatures) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice,
                                                 VkPhysicalDeviceProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceProperties2(physicalDevice, pProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice,
                                                       VkFormat format,
                                                       VkFormatProperties2* pFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties,
                                                true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetPhysicalDeviceImageFormatProperties2_VkResult_return =
        resources->on_vkGetPhysicalDeviceImageFormatProperties2(
            vkEnc, VK_SUCCESS, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}
static void entry_vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount,
                                                     pQueueFamilyProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties,
                                                true /* do lock */);
}
static void entry_vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties2(
        physicalDevice, pFormatInfo, pPropertyCount, pProperties, true /* do lock */);
}
static void entry_vkTrimCommandPool(VkDevice device, VkCommandPool commandPool,
                                    VkCommandPoolTrimFlags flags) {
    AEMU_SCOPED_TRACE("vkTrimCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPool(device, commandPool, flags, true /* do lock */);
}
static void dynCheck_entry_vkTrimCommandPool(VkDevice device, VkCommandPool commandPool,
                                             VkCommandPoolTrimFlags flags) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkTrimCommandPool", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkTrimCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPool(device, commandPool, flags, true /* do lock */);
}
static void entry_vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
                                    VkQueue* pQueue) {
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceQueue2(device, pQueueInfo, pQueue, true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
                                             VkQueue* pQueue) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceQueue2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceQueue2(device, pQueueInfo, pQueue, true /* do lock */);
}
static VkResult entry_vkCreateSamplerYcbcrConversion(
    VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSamplerYcbcrConversion_VkResult_return = resources->on_vkCreateSamplerYcbcrConversion(
        vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateSamplerYcbcrConversion(
    VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkCreateSamplerYcbcrConversion", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    vkCreateSamplerYcbcrConversion_VkResult_return = resources->on_vkCreateSamplerYcbcrConversion(
        vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}
static void entry_vkDestroySamplerYcbcrConversion(VkDevice device,
                                                  VkSamplerYcbcrConversion ycbcrConversion,
                                                  const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroySamplerYcbcrConversion(vkEnc, device, ycbcrConversion, pAllocator);
}
static void dynCheck_entry_vkDestroySamplerYcbcrConversion(
    VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkDestroySamplerYcbcrConversion", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkDestroySamplerYcbcrConversion(vkEnc, device, ycbcrConversion, pAllocator);
}
static VkResult entry_vkCreateDescriptorUpdateTemplate(
    VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplate_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplate(
        device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateDescriptorUpdateTemplate(
    VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkCreateDescriptorUpdateTemplate", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplate_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplate(
        device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}
static void entry_vkDestroyDescriptorUpdateTemplate(
    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator,
                                             true /* do lock */);
}
static void dynCheck_entry_vkDestroyDescriptorUpdateTemplate(
    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkDestroyDescriptorUpdateTemplate", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator,
                                             true /* do lock */);
}
static void entry_vkUpdateDescriptorSetWithTemplate(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkUpdateDescriptorSetWithTemplate(vkEnc, device, descriptorSet,
                                                    descriptorUpdateTemplate, pData);
}
static void dynCheck_entry_vkUpdateDescriptorSetWithTemplate(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkUpdateDescriptorSetWithTemplate", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkUpdateDescriptorSetWithTemplate(vkEnc, device, descriptorSet,
                                                    descriptorUpdateTemplate, pData);
}
static void entry_vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalBufferProperties(
        physicalDevice, pExternalBufferInfo, pExternalBufferProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFenceProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetPhysicalDeviceExternalFenceProperties(
        vkEnc, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
static void entry_vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphoreProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalSemaphoreProperties(
        physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties, true /* do lock */);
}
static void entry_vkGetDescriptorSetLayoutSupport(
    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, true /* do lock */);
}
static void dynCheck_entry_vkGetDescriptorSetLayoutSupport(
    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1) {
        sOnInvalidDynamicallyCheckedCall("vkGetDescriptorSetLayoutSupport", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, true /* do lock */);
}
#endif
#ifdef VK_VERSION_1_2
static void entry_vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                         VkDeviceSize offset, VkBuffer countBuffer,
                                         VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                         uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCount");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset,
                                  maxDrawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                VkDeviceSize offset, VkBuffer countBuffer,
                                                VkDeviceSize countBufferOffset,
                                                uint32_t maxDrawCount, uint32_t stride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCount");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer,
                                         countBufferOffset, maxDrawCount, stride,
                                         true /* do lock */);
}
static VkResult entry_vkCreateRenderPass2(VkDevice device,
                                          const VkRenderPassCreateInfo2* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkRenderPass* pRenderPass) {
    AEMU_SCOPED_TRACE("vkCreateRenderPass2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
    vkCreateRenderPass2_VkResult_return = vkEnc->vkCreateRenderPass2(
        device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateRenderPass2(VkDevice device,
                                                   const VkRenderPassCreateInfo2* pCreateInfo,
                                                   const VkAllocationCallbacks* pAllocator,
                                                   VkRenderPass* pRenderPass) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkCreateRenderPass2", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkCreateRenderPass2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
    vkCreateRenderPass2_VkResult_return = vkEnc->vkCreateRenderPass2(
        device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2_VkResult_return;
}
static void entry_vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer,
                                        const VkRenderPassBeginInfo* pRenderPassBegin,
                                        const VkSubpassBeginInfo* pSubpassBeginInfo) {
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo,
                                 true /* do lock */);
}
static void entry_vkCmdNextSubpass2(VkCommandBuffer commandBuffer,
                                    const VkSubpassBeginInfo* pSubpassBeginInfo,
                                    const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo, true /* do lock */);
}
static void entry_vkCmdEndRenderPass2(VkCommandBuffer commandBuffer,
                                      const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo, true /* do lock */);
}
static void entry_vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                   uint32_t queryCount) {
    AEMU_SCOPED_TRACE("vkResetQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkResetQueryPool(device, queryPool, firstQuery, queryCount, true /* do lock */);
}
static void dynCheck_entry_vkResetQueryPool(VkDevice device, VkQueryPool queryPool,
                                            uint32_t firstQuery, uint32_t queryCount) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkResetQueryPool", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkResetQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkResetQueryPool(device, queryPool, firstQuery, queryCount, true /* do lock */);
}
static VkResult entry_vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore,
                                                 uint64_t* pValue) {
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValue");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
    vkGetSemaphoreCounterValue_VkResult_return =
        vkEnc->vkGetSemaphoreCounterValue(device, semaphore, pValue, true /* do lock */);
    return vkGetSemaphoreCounterValue_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore,
                                                          uint64_t* pValue) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetSemaphoreCounterValue", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValue");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
    vkGetSemaphoreCounterValue_VkResult_return =
        vkEnc->vkGetSemaphoreCounterValue(device, semaphore, pValue, true /* do lock */);
    return vkGetSemaphoreCounterValue_VkResult_return;
}
static VkResult entry_vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo,
                                       uint64_t timeout) {
    AEMU_SCOPED_TRACE("vkWaitSemaphores");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
    vkWaitSemaphores_VkResult_return =
        vkEnc->vkWaitSemaphores(device, pWaitInfo, timeout, true /* do lock */);
    return vkWaitSemaphores_VkResult_return;
}
static VkResult dynCheck_entry_vkWaitSemaphores(VkDevice device,
                                                const VkSemaphoreWaitInfo* pWaitInfo,
                                                uint64_t timeout) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkWaitSemaphores", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkWaitSemaphores");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
    vkWaitSemaphores_VkResult_return =
        vkEnc->vkWaitSemaphores(device, pWaitInfo, timeout, true /* do lock */);
    return vkWaitSemaphores_VkResult_return;
}
static VkResult entry_vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo) {
    AEMU_SCOPED_TRACE("vkSignalSemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
    vkSignalSemaphore_VkResult_return =
        vkEnc->vkSignalSemaphore(device, pSignalInfo, true /* do lock */);
    return vkSignalSemaphore_VkResult_return;
}
static VkResult dynCheck_entry_vkSignalSemaphore(VkDevice device,
                                                 const VkSemaphoreSignalInfo* pSignalInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkSignalSemaphore", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkSignalSemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
    vkSignalSemaphore_VkResult_return =
        vkEnc->vkSignalSemaphore(device, pSignalInfo, true /* do lock */);
    return vkSignalSemaphore_VkResult_return;
}
static VkDeviceAddress entry_vkGetBufferDeviceAddress(VkDevice device,
                                                      const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddress_VkDeviceAddress_return =
        vkEnc->vkGetBufferDeviceAddress(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddress_VkDeviceAddress_return;
}
static VkDeviceAddress dynCheck_entry_vkGetBufferDeviceAddress(
    VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferDeviceAddress", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddress_VkDeviceAddress_return =
        vkEnc->vkGetBufferDeviceAddress(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddress_VkDeviceAddress_return;
}
static uint64_t entry_vkGetBufferOpaqueCaptureAddress(VkDevice device,
                                                      const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddress_uint64_t_return =
        vkEnc->vkGetBufferOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddress_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetBufferOpaqueCaptureAddress(
    VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferOpaqueCaptureAddress", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddress_uint64_t_return =
        vkEnc->vkGetBufferOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddress_uint64_t_return;
}
static uint64_t entry_vkGetDeviceMemoryOpaqueCaptureAddress(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return =
        vkEnc->vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddress(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceMemoryOpaqueCaptureAddress", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return =
        vkEnc->vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return;
}
#endif
#ifdef VK_VERSION_1_3
static VkResult entry_vkGetPhysicalDeviceToolProperties(
    VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
    VkPhysicalDeviceToolProperties* pToolProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceToolProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceToolProperties_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceToolProperties_VkResult_return = vkEnc->vkGetPhysicalDeviceToolProperties(
        physicalDevice, pToolCount, pToolProperties, true /* do lock */);
    return vkGetPhysicalDeviceToolProperties_VkResult_return;
}
static VkResult entry_vkCreatePrivateDataSlot(VkDevice device,
                                              const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator,
                                              VkPrivateDataSlot* pPrivateDataSlot) {
    AEMU_SCOPED_TRACE("vkCreatePrivateDataSlot");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePrivateDataSlot_VkResult_return = (VkResult)0;
    vkCreatePrivateDataSlot_VkResult_return = vkEnc->vkCreatePrivateDataSlot(
        device, pCreateInfo, pAllocator, pPrivateDataSlot, true /* do lock */);
    return vkCreatePrivateDataSlot_VkResult_return;
}
static VkResult dynCheck_entry_vkCreatePrivateDataSlot(
    VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkCreatePrivateDataSlot", "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkCreatePrivateDataSlot");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePrivateDataSlot_VkResult_return = (VkResult)0;
    vkCreatePrivateDataSlot_VkResult_return = vkEnc->vkCreatePrivateDataSlot(
        device, pCreateInfo, pAllocator, pPrivateDataSlot, true /* do lock */);
    return vkCreatePrivateDataSlot_VkResult_return;
}
static void entry_vkDestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                           const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyPrivateDataSlot");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyPrivateDataSlot(VkDevice device,
                                                    VkPrivateDataSlot privateDataSlot,
                                                    const VkAllocationCallbacks* pAllocator) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkDestroyPrivateDataSlot", "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkDestroyPrivateDataSlot");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator, true /* do lock */);
}
static VkResult entry_vkSetPrivateData(VkDevice device, VkObjectType objectType,
                                       uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
                                       uint64_t data) {
    AEMU_SCOPED_TRACE("vkSetPrivateData");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetPrivateData_VkResult_return = (VkResult)0;
    vkSetPrivateData_VkResult_return = vkEnc->vkSetPrivateData(
        device, objectType, objectHandle, privateDataSlot, data, true /* do lock */);
    return vkSetPrivateData_VkResult_return;
}
static VkResult dynCheck_entry_vkSetPrivateData(VkDevice device, VkObjectType objectType,
                                                uint64_t objectHandle,
                                                VkPrivateDataSlot privateDataSlot, uint64_t data) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkSetPrivateData", "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkSetPrivateData");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetPrivateData_VkResult_return = (VkResult)0;
    vkSetPrivateData_VkResult_return = vkEnc->vkSetPrivateData(
        device, objectType, objectHandle, privateDataSlot, data, true /* do lock */);
    return vkSetPrivateData_VkResult_return;
}
static void entry_vkGetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                   VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    AEMU_SCOPED_TRACE("vkGetPrivateData");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData,
                            true /* do lock */);
}
static void dynCheck_entry_vkGetPrivateData(VkDevice device, VkObjectType objectType,
                                            uint64_t objectHandle,
                                            VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkGetPrivateData", "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkGetPrivateData");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData,
                            true /* do lock */);
}
static void entry_vkCmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                 const VkDependencyInfo* pDependencyInfo) {
    AEMU_SCOPED_TRACE("vkCmdSetEvent2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetEvent2(commandBuffer, event, pDependencyInfo, true /* do lock */);
}
static void entry_vkCmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                   VkPipelineStageFlags2 stageMask) {
    AEMU_SCOPED_TRACE("vkCmdResetEvent2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResetEvent2(commandBuffer, event, stageMask, true /* do lock */);
}
static void entry_vkCmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                   const VkEvent* pEvents,
                                   const VkDependencyInfo* pDependencyInfos) {
    AEMU_SCOPED_TRACE("vkCmdWaitEvents2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos,
                            true /* do lock */);
}
static void entry_vkCmdPipelineBarrier2(VkCommandBuffer commandBuffer,
                                        const VkDependencyInfo* pDependencyInfo) {
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPipelineBarrier2(commandBuffer, pDependencyInfo, true /* do lock */);
}
static void entry_vkCmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                       VkQueryPool queryPool, uint32_t query) {
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query, true /* do lock */);
}
static VkResult entry_vkQueueSubmit2(VkQueue queue, uint32_t submitCount,
                                     const VkSubmitInfo2* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmit2");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueSubmit2_VkResult_return = (VkResult)0;
    vkQueueSubmit2_VkResult_return =
        vkEnc->vkQueueSubmit2(queue, submitCount, pSubmits, fence, true /* do lock */);
    return vkQueueSubmit2_VkResult_return;
}
static void entry_vkCmdCopyBuffer2(VkCommandBuffer commandBuffer,
                                   const VkCopyBufferInfo2* pCopyBufferInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo, true /* do lock */);
}
static void entry_vkCmdCopyImage2(VkCommandBuffer commandBuffer,
                                  const VkCopyImageInfo2* pCopyImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyImage2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImage2(commandBuffer, pCopyImageInfo, true /* do lock */);
}
static void entry_vkCmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
                                          const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo, true /* do lock */);
}
static void entry_vkCmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
                                          const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo, true /* do lock */);
}
static void entry_vkCmdBlitImage2(VkCommandBuffer commandBuffer,
                                  const VkBlitImageInfo2* pBlitImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdBlitImage2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBlitImage2(commandBuffer, pBlitImageInfo, true /* do lock */);
}
static void entry_vkCmdResolveImage2(VkCommandBuffer commandBuffer,
                                     const VkResolveImageInfo2* pResolveImageInfo) {
    AEMU_SCOPED_TRACE("vkCmdResolveImage2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResolveImage2(commandBuffer, pResolveImageInfo, true /* do lock */);
}
static void entry_vkCmdBeginRendering(VkCommandBuffer commandBuffer,
                                      const VkRenderingInfo* pRenderingInfo) {
    AEMU_SCOPED_TRACE("vkCmdBeginRendering");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRendering(commandBuffer, pRenderingInfo, true /* do lock */);
}
static void entry_vkCmdEndRendering(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkCmdEndRendering");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRendering(commandBuffer, true /* do lock */);
}
static void entry_vkCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    AEMU_SCOPED_TRACE("vkCmdSetCullMode");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetCullMode(commandBuffer, cullMode, true /* do lock */);
}
static void entry_vkCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    AEMU_SCOPED_TRACE("vkCmdSetFrontFace");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetFrontFace(commandBuffer, frontFace, true /* do lock */);
}
static void entry_vkCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer,
                                            VkPrimitiveTopology primitiveTopology) {
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveTopology");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology, true /* do lock */);
}
static void entry_vkCmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                            const VkViewport* pViewports) {
    AEMU_SCOPED_TRACE("vkCmdSetViewportWithCount");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports, true /* do lock */);
}
static void entry_vkCmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                           const VkRect2D* pScissors) {
    AEMU_SCOPED_TRACE("vkCmdSetScissorWithCount");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors, true /* do lock */);
}
static void entry_vkCmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                          uint32_t bindingCount, const VkBuffer* pBuffers,
                                          const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                          const VkDeviceSize* pStrides) {
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets,
                                   pSizes, pStrides, true /* do lock */);
}
static void entry_vkCmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthTestEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable, true /* do lock */);
}
static void entry_vkCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer,
                                           VkBool32 depthWriteEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthWriteEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable, true /* do lock */);
}
static void entry_vkCmdSetDepthCompareOp(VkCommandBuffer commandBuffer,
                                         VkCompareOp depthCompareOp) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthCompareOp");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp, true /* do lock */);
}
static void entry_vkCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer,
                                                VkBool32 depthBoundsTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBoundsTestEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable, true /* do lock */);
}
static void entry_vkCmdSetStencilTestEnable(VkCommandBuffer commandBuffer,
                                            VkBool32 stencilTestEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilTestEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable, true /* do lock */);
}
static void entry_vkCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                    VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
                                    VkCompareOp compareOp) {
    AEMU_SCOPED_TRACE("vkCmdSetStencilOp");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp,
                             true /* do lock */);
}
static void entry_vkCmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer,
                                                  VkBool32 rasterizerDiscardEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetRasterizerDiscardEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable,
                                           true /* do lock */);
}
static void entry_vkCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetDepthBiasEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable, true /* do lock */);
}
static void entry_vkCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer,
                                                 VkBool32 primitiveRestartEnable) {
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveRestartEnable");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable,
                                          true /* do lock */);
}
static void entry_vkGetDeviceBufferMemoryRequirements(VkDevice device,
                                                      const VkDeviceBufferMemoryRequirements* pInfo,
                                                      VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceBufferMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements,
                                               true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceBufferMemoryRequirements(
    VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceBufferMemoryRequirements", "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceBufferMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements,
                                               true /* do lock */);
}
static void entry_vkGetDeviceImageMemoryRequirements(VkDevice device,
                                                     const VkDeviceImageMemoryRequirements* pInfo,
                                                     VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements,
                                              true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceImageMemoryRequirements(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceImageMemoryRequirements", "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceImageMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements,
                                              true /* do lock */);
}
static void entry_vkGetDeviceImageSparseMemoryRequirements(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetDeviceImageSparseMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                    pSparseMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceImageSparseMemoryRequirements(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_3")) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceImageSparseMemoryRequirements",
                                         "VK_VERSION_1_3");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceImageSparseMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                    pSparseMemoryRequirements, true /* do lock */);
}
#endif
#ifdef VK_KHR_surface
#endif
#ifdef VK_KHR_swapchain
#endif
#ifdef VK_KHR_xcb_surface
#endif
#ifdef VK_KHR_android_surface
static VkResult entry_vkCreateAndroidSurfaceKHR(VkInstance instance,
                                                const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
                                                const VkAllocationCallbacks* pAllocator,
                                                VkSurfaceKHR* pSurface) {
    AEMU_SCOPED_TRACE("vkCreateAndroidSurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateAndroidSurfaceKHR_VkResult_return = vkEnc->vkCreateAndroidSurfaceKHR(
        instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_win32_surface
#endif
#ifdef VK_KHR_get_physical_device_properties2
static void entry_vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice,
                                                  VkPhysicalDeviceFeatures2* pFeatures) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice,
                                                    VkPhysicalDeviceProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice,
                                                          VkFormat format,
                                                          VkFormatProperties2* pFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties,
                                                   true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return =
        resources->on_vkGetPhysicalDeviceImageFormatProperties2KHR(
            vkEnc, VK_SUCCESS, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}
static void entry_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount,
                                                        pQueueFamilyProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties,
                                                   true /* do lock */);
}
static void entry_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        physicalDevice, pFormatInfo, pPropertyCount, pProperties, true /* do lock */);
}
#endif
#ifdef VK_KHR_maintenance1
static void entry_vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool,
                                       VkCommandPoolTrimFlags flags) {
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPoolKHR(device, commandPool, flags, true /* do lock */);
}
static void dynCheck_entry_vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool,
                                                VkCommandPoolTrimFlags flags) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_maintenance1")) {
        sOnInvalidDynamicallyCheckedCall("vkTrimCommandPoolKHR", "VK_KHR_maintenance1");
    }
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPoolKHR(device, commandPool, flags, true /* do lock */);
}
#endif
#ifdef VK_KHR_external_memory_capabilities
static void entry_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalBufferPropertiesKHR(
        physicalDevice, pExternalBufferInfo, pExternalBufferProperties, true /* do lock */);
}
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
#endif
#ifdef VK_KHR_external_memory_fd
#endif
#ifdef VK_KHR_external_semaphore_capabilities
static void entry_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties, true /* do lock */);
}
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
#endif
#ifdef VK_KHR_external_semaphore_fd
static VkResult entry_vkImportSemaphoreFdKHR(
    VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkImportSemaphoreFdKHR_VkResult_return =
        resources->on_vkImportSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pImportSemaphoreFdInfo);
    return vkImportSemaphoreFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkImportSemaphoreFdKHR(
    VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd")) {
        sOnInvalidDynamicallyCheckedCall("vkImportSemaphoreFdKHR", "VK_KHR_external_semaphore_fd");
    }
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    vkImportSemaphoreFdKHR_VkResult_return =
        resources->on_vkImportSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pImportSemaphoreFdInfo);
    return vkImportSemaphoreFdKHR_VkResult_return;
}
static VkResult entry_vkGetSemaphoreFdKHR(VkDevice device,
                                          const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetSemaphoreFdKHR_VkResult_return =
        resources->on_vkGetSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetSemaphoreFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSemaphoreFdKHR(VkDevice device,
                                                   const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
                                                   int* pFd) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd")) {
        sOnInvalidDynamicallyCheckedCall("vkGetSemaphoreFdKHR", "VK_KHR_external_semaphore_fd");
    }
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    vkGetSemaphoreFdKHR_VkResult_return =
        resources->on_vkGetSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetSemaphoreFdKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
static VkResult entry_vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
        vkEnc->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator,
                                                   pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template")) {
        sOnInvalidDynamicallyCheckedCall("vkCreateDescriptorUpdateTemplateKHR",
                                         "VK_KHR_descriptor_update_template");
    }
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplateKHR_VkResult_return =
        vkEnc->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator,
                                                   pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}
static void entry_vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator,
                                                true /* do lock */);
}
static void dynCheck_entry_vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template")) {
        sOnInvalidDynamicallyCheckedCall("vkDestroyDescriptorUpdateTemplateKHR",
                                         "VK_KHR_descriptor_update_template");
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator,
                                                true /* do lock */);
}
static void entry_vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate,
                                                pData, true /* do lock */);
}
static void dynCheck_entry_vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template")) {
        sOnInvalidDynamicallyCheckedCall("vkUpdateDescriptorSetWithTemplateKHR",
                                         "VK_KHR_descriptor_update_template");
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate,
                                                pData, true /* do lock */);
}
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
static VkResult entry_vkCreateRenderPass2KHR(VkDevice device,
                                             const VkRenderPassCreateInfo2* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkRenderPass* pRenderPass) {
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    vkCreateRenderPass2KHR_VkResult_return = vkEnc->vkCreateRenderPass2KHR(
        device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateRenderPass2KHR(VkDevice device,
                                                      const VkRenderPassCreateInfo2* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator,
                                                      VkRenderPass* pRenderPass) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2")) {
        sOnInvalidDynamicallyCheckedCall("vkCreateRenderPass2KHR", "VK_KHR_create_renderpass2");
    }
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    vkCreateRenderPass2KHR_VkResult_return = vkEnc->vkCreateRenderPass2KHR(
        device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2KHR_VkResult_return;
}
static void entry_vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer,
                                           const VkRenderPassBeginInfo* pRenderPassBegin,
                                           const VkSubpassBeginInfo* pSubpassBeginInfo) {
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo,
                                    true /* do lock */);
}
static void dynCheck_entry_vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer,
                                                    const VkRenderPassBeginInfo* pRenderPassBegin,
                                                    const VkSubpassBeginInfo* pSubpassBeginInfo) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdBeginRenderPass2KHR", "VK_KHR_create_renderpass2");
    }
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo,
                                    true /* do lock */);
}
static void entry_vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer,
                                       const VkSubpassBeginInfo* pSubpassBeginInfo,
                                       const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo,
                                true /* do lock */);
}
static void dynCheck_entry_vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer,
                                                const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                const VkSubpassEndInfo* pSubpassEndInfo) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdNextSubpass2KHR", "VK_KHR_create_renderpass2");
    }
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo,
                                true /* do lock */);
}
static void entry_vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer,
                                         const VkSubpassEndInfo* pSubpassEndInfo) {
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo, true /* do lock */);
}
static void dynCheck_entry_vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer,
                                                  const VkSubpassEndInfo* pSubpassEndInfo) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdEndRenderPass2KHR", "VK_KHR_create_renderpass2");
    }
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo, true /* do lock */);
}
#endif
#ifdef VK_KHR_external_fence_capabilities
static void entry_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties) {
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFencePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetPhysicalDeviceExternalFencePropertiesKHR(
        vkEnc, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_fd
static VkResult entry_vkImportFenceFdKHR(VkDevice device,
                                         const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkImportFenceFdKHR_VkResult_return =
        resources->on_vkImportFenceFdKHR(vkEnc, VK_SUCCESS, device, pImportFenceFdInfo);
    return vkImportFenceFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkImportFenceFdKHR(
    VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd")) {
        sOnInvalidDynamicallyCheckedCall("vkImportFenceFdKHR", "VK_KHR_external_fence_fd");
    }
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    vkImportFenceFdKHR_VkResult_return =
        resources->on_vkImportFenceFdKHR(vkEnc, VK_SUCCESS, device, pImportFenceFdInfo);
    return vkImportFenceFdKHR_VkResult_return;
}
static VkResult entry_vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo,
                                      int* pFd) {
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetFenceFdKHR_VkResult_return =
        resources->on_vkGetFenceFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetFenceFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetFenceFdKHR(VkDevice device,
                                               const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd")) {
        sOnInvalidDynamicallyCheckedCall("vkGetFenceFdKHR", "VK_KHR_external_fence_fd");
    }
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    vkGetFenceFdKHR_VkResult_return =
        resources->on_vkGetFenceFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetFenceFdKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_get_memory_requirements2
static void entry_vkGetImageMemoryRequirements2KHR(VkDevice device,
                                                   const VkImageMemoryRequirementsInfo2* pInfo,
                                                   VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetImageMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetImageMemoryRequirements2KHR(
    VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetImageMemoryRequirements2KHR",
                                         "VK_KHR_get_memory_requirements2");
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetImageMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetBufferMemoryRequirements2KHR(VkDevice device,
                                                    const VkBufferMemoryRequirementsInfo2* pInfo,
                                                    VkMemoryRequirements2* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetBufferMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetBufferMemoryRequirements2KHR(
    VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferMemoryRequirements2KHR",
                                         "VK_KHR_get_memory_requirements2");
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetBufferMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount,
                                                  pSparseMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2")) {
        sOnInvalidDynamicallyCheckedCall("vkGetImageSparseMemoryRequirements2KHR",
                                         "VK_KHR_get_memory_requirements2");
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount,
                                                  pSparseMemoryRequirements, true /* do lock */);
}
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
static VkResult entry_vkCreateSamplerYcbcrConversionKHR(
    VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSamplerYcbcrConversionKHR_VkResult_return =
        resources->on_vkCreateSamplerYcbcrConversionKHR(vkEnc, VK_SUCCESS, device, pCreateInfo,
                                                        pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateSamplerYcbcrConversionKHR(
    VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion")) {
        sOnInvalidDynamicallyCheckedCall("vkCreateSamplerYcbcrConversionKHR",
                                         "VK_KHR_sampler_ycbcr_conversion");
    }
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    vkCreateSamplerYcbcrConversionKHR_VkResult_return =
        resources->on_vkCreateSamplerYcbcrConversionKHR(vkEnc, VK_SUCCESS, device, pCreateInfo,
                                                        pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}
static void entry_vkDestroySamplerYcbcrConversionKHR(VkDevice device,
                                                     VkSamplerYcbcrConversion ycbcrConversion,
                                                     const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroySamplerYcbcrConversionKHR(vkEnc, device, ycbcrConversion, pAllocator);
}
static void dynCheck_entry_vkDestroySamplerYcbcrConversionKHR(
    VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion")) {
        sOnInvalidDynamicallyCheckedCall("vkDestroySamplerYcbcrConversionKHR",
                                         "VK_KHR_sampler_ycbcr_conversion");
    }
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkDestroySamplerYcbcrConversionKHR(vkEnc, device, ycbcrConversion, pAllocator);
}
#endif
#ifdef VK_KHR_bind_memory2
static VkResult entry_vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                             const VkBindBufferMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindBufferMemory2KHR_VkResult_return =
        resources->on_vkBindBufferMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                                      const VkBindBufferMemoryInfo* pBindInfos) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_bind_memory2")) {
        sOnInvalidDynamicallyCheckedCall("vkBindBufferMemory2KHR", "VK_KHR_bind_memory2");
    }
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    vkBindBufferMemory2KHR_VkResult_return =
        resources->on_vkBindBufferMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2KHR_VkResult_return;
}
static VkResult entry_vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                            const VkBindImageMemoryInfo* pBindInfos) {
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindImageMemory2KHR_VkResult_return =
        resources->on_vkBindImageMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                                     const VkBindImageMemoryInfo* pBindInfos) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_bind_memory2")) {
        sOnInvalidDynamicallyCheckedCall("vkBindImageMemory2KHR", "VK_KHR_bind_memory2");
    }
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    vkBindImageMemory2KHR_VkResult_return =
        resources->on_vkBindImageMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2KHR_VkResult_return;
}
#endif
#ifdef VK_KHR_maintenance3
static void entry_vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport, true /* do lock */);
}
static void dynCheck_entry_vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_maintenance3")) {
        sOnInvalidDynamicallyCheckedCall("vkGetDescriptorSetLayoutSupportKHR",
                                         "VK_KHR_maintenance3");
    }
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport, true /* do lock */);
}
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_buffer_device_address
static VkDeviceAddress entry_vkGetBufferDeviceAddressKHR(VkDevice device,
                                                         const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddressKHR_VkDeviceAddress_return =
        vkEnc->vkGetBufferDeviceAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddressKHR_VkDeviceAddress_return;
}
static VkDeviceAddress dynCheck_entry_vkGetBufferDeviceAddressKHR(
    VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address")) {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferDeviceAddressKHR",
                                         "VK_KHR_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddressKHR_VkDeviceAddress_return =
        vkEnc->vkGetBufferDeviceAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddressKHR_VkDeviceAddress_return;
}
static uint64_t entry_vkGetBufferOpaqueCaptureAddressKHR(VkDevice device,
                                                         const VkBufferDeviceAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return =
        vkEnc->vkGetBufferOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetBufferOpaqueCaptureAddressKHR(
    VkDevice device, const VkBufferDeviceAddressInfo* pInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address")) {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferOpaqueCaptureAddressKHR",
                                         "VK_KHR_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return =
        vkEnc->vkGetBufferOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return;
}
static uint64_t entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return =
        vkEnc->vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address")) {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceMemoryOpaqueCaptureAddressKHR",
                                         "VK_KHR_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return =
        vkEnc->vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return;
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
static VkResult entry_vkGetPipelineExecutablePropertiesKHR(
    VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties) {
    AEMU_SCOPED_TRACE("vkGetPipelineExecutablePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutablePropertiesKHR_VkResult_return =
        vkEnc->vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount,
                                                    pProperties, true /* do lock */);
    return vkGetPipelineExecutablePropertiesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPipelineExecutablePropertiesKHR(
    VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties")) {
        sOnInvalidDynamicallyCheckedCall("vkGetPipelineExecutablePropertiesKHR",
                                         "VK_KHR_pipeline_executable_properties");
    }
    AEMU_SCOPED_TRACE("vkGetPipelineExecutablePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutablePropertiesKHR_VkResult_return =
        vkEnc->vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount,
                                                    pProperties, true /* do lock */);
    return vkGetPipelineExecutablePropertiesKHR_VkResult_return;
}
static VkResult entry_vkGetPipelineExecutableStatisticsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics) {
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableStatisticsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableStatisticsKHR_VkResult_return =
        vkEnc->vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount,
                                                    pStatistics, true /* do lock */);
    return vkGetPipelineExecutableStatisticsKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPipelineExecutableStatisticsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties")) {
        sOnInvalidDynamicallyCheckedCall("vkGetPipelineExecutableStatisticsKHR",
                                         "VK_KHR_pipeline_executable_properties");
    }
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableStatisticsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableStatisticsKHR_VkResult_return =
        vkEnc->vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount,
                                                    pStatistics, true /* do lock */);
    return vkGetPipelineExecutableStatisticsKHR_VkResult_return;
}
static VkResult entry_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableInternalRepresentationsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return =
        vkEnc->vkGetPipelineExecutableInternalRepresentationsKHR(
            device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations,
            true /* do lock */);
    return vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties")) {
        sOnInvalidDynamicallyCheckedCall("vkGetPipelineExecutableInternalRepresentationsKHR",
                                         "VK_KHR_pipeline_executable_properties");
    }
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableInternalRepresentationsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return =
        vkEnc->vkGetPipelineExecutableInternalRepresentationsKHR(
            device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations,
            true /* do lock */);
    return vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return;
}
#endif
#ifdef VK_ANDROID_native_buffer
static VkResult entry_vkGetSwapchainGrallocUsageANDROID(VkDevice device, VkFormat format,
                                                        VkImageUsageFlags imageUsage,
                                                        int* grallocUsage) {
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    vkGetSwapchainGrallocUsageANDROID_VkResult_return = vkEnc->vkGetSwapchainGrallocUsageANDROID(
        device, format, imageUsage, grallocUsage, true /* do lock */);
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSwapchainGrallocUsageANDROID(VkDevice device, VkFormat format,
                                                                 VkImageUsageFlags imageUsage,
                                                                 int* grallocUsage) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer")) {
        sOnInvalidDynamicallyCheckedCall("vkGetSwapchainGrallocUsageANDROID",
                                         "VK_ANDROID_native_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    vkGetSwapchainGrallocUsageANDROID_VkResult_return = vkEnc->vkGetSwapchainGrallocUsageANDROID(
        device, format, imageUsage, grallocUsage, true /* do lock */);
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}
static VkResult entry_vkAcquireImageANDROID(VkDevice device, VkImage image, int nativeFenceFd,
                                            VkSemaphore semaphore, VkFence fence) {
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    vkAcquireImageANDROID_VkResult_return = vkEnc->vkAcquireImageANDROID(
        device, image, nativeFenceFd, semaphore, fence, true /* do lock */);
    return vkAcquireImageANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquireImageANDROID(VkDevice device, VkImage image,
                                                     int nativeFenceFd, VkSemaphore semaphore,
                                                     VkFence fence) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer")) {
        sOnInvalidDynamicallyCheckedCall("vkAcquireImageANDROID", "VK_ANDROID_native_buffer");
    }
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    vkAcquireImageANDROID_VkResult_return = vkEnc->vkAcquireImageANDROID(
        device, image, nativeFenceFd, semaphore, fence, true /* do lock */);
    return vkAcquireImageANDROID_VkResult_return;
}
static VkResult entry_vkQueueSignalReleaseImageANDROID(VkQueue queue, uint32_t waitSemaphoreCount,
                                                       const VkSemaphore* pWaitSemaphores,
                                                       VkImage image, int* pNativeFenceFd) {
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROID");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkQueueSignalReleaseImageANDROID_VkResult_return =
        resources->on_vkQueueSignalReleaseImageANDROID(vkEnc, VK_SUCCESS, queue, waitSemaphoreCount,
                                                       pWaitSemaphores, image, pNativeFenceFd);
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}
static VkResult entry_vkGetSwapchainGrallocUsage2ANDROID(
    VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
    VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
    uint64_t* grallocProducerUsage) {
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsage2ANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainGrallocUsage2ANDROID_VkResult_return = (VkResult)0;
    vkGetSwapchainGrallocUsage2ANDROID_VkResult_return = vkEnc->vkGetSwapchainGrallocUsage2ANDROID(
        device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage,
        true /* do lock */);
    return vkGetSwapchainGrallocUsage2ANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSwapchainGrallocUsage2ANDROID(
    VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
    VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
    uint64_t* grallocProducerUsage) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer")) {
        sOnInvalidDynamicallyCheckedCall("vkGetSwapchainGrallocUsage2ANDROID",
                                         "VK_ANDROID_native_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsage2ANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainGrallocUsage2ANDROID_VkResult_return = (VkResult)0;
    vkGetSwapchainGrallocUsage2ANDROID_VkResult_return = vkEnc->vkGetSwapchainGrallocUsage2ANDROID(
        device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage,
        true /* do lock */);
    return vkGetSwapchainGrallocUsage2ANDROID_VkResult_return;
}
#endif
#ifdef VK_EXT_transform_feedback
static void entry_vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer,
                                                       uint32_t firstBinding, uint32_t bindingCount,
                                                       const VkBuffer* pBuffers,
                                                       const VkDeviceSize* pOffsets,
                                                       const VkDeviceSize* pSizes) {
    AEMU_SCOPED_TRACE("vkCmdBindTransformFeedbackBuffersEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers,
                                                pOffsets, pSizes, true /* do lock */);
}
static void dynCheck_entry_vkCmdBindTransformFeedbackBuffersEXT(
    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
    const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_transform_feedback")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdBindTransformFeedbackBuffersEXT",
                                         "VK_EXT_transform_feedback");
    }
    AEMU_SCOPED_TRACE("vkCmdBindTransformFeedbackBuffersEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers,
                                                pOffsets, pSizes, true /* do lock */);
}
static void entry_vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer,
                                                 uint32_t firstCounterBuffer,
                                                 uint32_t counterBufferCount,
                                                 const VkBuffer* pCounterBuffers,
                                                 const VkDeviceSize* pCounterBufferOffsets) {
    AEMU_SCOPED_TRACE("vkCmdBeginTransformFeedbackEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                          pCounterBuffers, pCounterBufferOffsets,
                                          true /* do lock */);
}
static void dynCheck_entry_vkCmdBeginTransformFeedbackEXT(
    VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_transform_feedback")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdBeginTransformFeedbackEXT",
                                         "VK_EXT_transform_feedback");
    }
    AEMU_SCOPED_TRACE("vkCmdBeginTransformFeedbackEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                          pCounterBuffers, pCounterBufferOffsets,
                                          true /* do lock */);
}
static void entry_vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer,
                                               uint32_t firstCounterBuffer,
                                               uint32_t counterBufferCount,
                                               const VkBuffer* pCounterBuffers,
                                               const VkDeviceSize* pCounterBufferOffsets) {
    AEMU_SCOPED_TRACE("vkCmdEndTransformFeedbackEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                        pCounterBuffers, pCounterBufferOffsets, true /* do lock */);
}
static void dynCheck_entry_vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer,
                                                        uint32_t firstCounterBuffer,
                                                        uint32_t counterBufferCount,
                                                        const VkBuffer* pCounterBuffers,
                                                        const VkDeviceSize* pCounterBufferOffsets) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_transform_feedback")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdEndTransformFeedbackEXT",
                                         "VK_EXT_transform_feedback");
    }
    AEMU_SCOPED_TRACE("vkCmdEndTransformFeedbackEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                        pCounterBuffers, pCounterBufferOffsets, true /* do lock */);
}
static void entry_vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                            uint32_t query, VkQueryControlFlags flags,
                                            uint32_t index) {
    AEMU_SCOPED_TRACE("vkCmdBeginQueryIndexedEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index,
                                     true /* do lock */);
}
static void dynCheck_entry_vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer,
                                                     VkQueryPool queryPool, uint32_t query,
                                                     VkQueryControlFlags flags, uint32_t index) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_transform_feedback")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdBeginQueryIndexedEXT", "VK_EXT_transform_feedback");
    }
    AEMU_SCOPED_TRACE("vkCmdBeginQueryIndexedEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index,
                                     true /* do lock */);
}
static void entry_vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                          uint32_t query, uint32_t index) {
    AEMU_SCOPED_TRACE("vkCmdEndQueryIndexedEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index, true /* do lock */);
}
static void dynCheck_entry_vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer,
                                                   VkQueryPool queryPool, uint32_t query,
                                                   uint32_t index) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_transform_feedback")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdEndQueryIndexedEXT", "VK_EXT_transform_feedback");
    }
    AEMU_SCOPED_TRACE("vkCmdEndQueryIndexedEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index, true /* do lock */);
}
static void entry_vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer,
                                                uint32_t instanceCount, uint32_t firstInstance,
                                                VkBuffer counterBuffer,
                                                VkDeviceSize counterBufferOffset,
                                                uint32_t counterOffset, uint32_t vertexStride) {
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectByteCountEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer,
                                         counterBufferOffset, counterOffset, vertexStride,
                                         true /* do lock */);
}
static void dynCheck_entry_vkCmdDrawIndirectByteCountEXT(
    VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance,
    VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset,
    uint32_t vertexStride) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_transform_feedback")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdDrawIndirectByteCountEXT",
                                         "VK_EXT_transform_feedback");
    }
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectByteCountEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer,
                                         counterBufferOffset, counterOffset, vertexStride,
                                         true /* do lock */);
}
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
static VkResult entry_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device, const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties) {
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return =
        resources->on_vkGetAndroidHardwareBufferPropertiesANDROID(vkEnc, VK_SUCCESS, device, buffer,
                                                                  pProperties);
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device, const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device,
                                       "VK_ANDROID_external_memory_android_hardware_buffer")) {
        sOnInvalidDynamicallyCheckedCall("vkGetAndroidHardwareBufferPropertiesANDROID",
                                         "VK_ANDROID_external_memory_android_hardware_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return =
        resources->on_vkGetAndroidHardwareBufferPropertiesANDROID(vkEnc, VK_SUCCESS, device, buffer,
                                                                  pProperties);
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}
static VkResult entry_vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer) {
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return =
        resources->on_vkGetMemoryAndroidHardwareBufferANDROID(vkEnc, VK_SUCCESS, device, pInfo,
                                                              pBuffer);
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device,
                                       "VK_ANDROID_external_memory_android_hardware_buffer")) {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryAndroidHardwareBufferANDROID",
                                         "VK_ANDROID_external_memory_android_hardware_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return =
        resources->on_vkGetMemoryAndroidHardwareBufferANDROID(vkEnc, VK_SUCCESS, device, pInfo,
                                                              pBuffer);
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_EXT_metal_surface
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_EXT_provoking_vertex
#endif
#ifdef VK_EXT_line_rasterization
static void entry_vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                         uint16_t lineStipplePattern) {
    AEMU_SCOPED_TRACE("vkCmdSetLineStippleEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern,
                                  true /* do lock */);
}
static void dynCheck_entry_vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer,
                                                  uint32_t lineStippleFactor,
                                                  uint16_t lineStipplePattern) {
    auto resources = ResourceTracker::get();
    VkDevice device = resources->getDevice(commandBuffer);
    ;
    if (!resources->hasDeviceExtension(device, "VK_EXT_line_rasterization")) {
        sOnInvalidDynamicallyCheckedCall("vkCmdSetLineStippleEXT", "VK_EXT_line_rasterization");
    }
    AEMU_SCOPED_TRACE("vkCmdSetLineStippleEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern,
                                  true /* do lock */);
}
#endif
#ifdef VK_EXT_index_type_uint8
#endif
#ifdef VK_EXT_device_memory_report
#endif
#ifdef VK_EXT_custom_border_color
#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_primitive_topology_list_restart
#endif
#ifdef VK_GOOGLE_gfxstream
static VkResult entry_vkMapMemoryIntoAddressSpaceGOOGLE(VkDevice device, VkDeviceMemory memory,
                                                        uint64_t* pAddress) {
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return =
        vkEnc->vkMapMemoryIntoAddressSpaceGOOGLE(device, memory, pAddress, true /* do lock */);
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkMapMemoryIntoAddressSpaceGOOGLE(VkDevice device,
                                                                 VkDeviceMemory memory,
                                                                 uint64_t* pAddress) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkMapMemoryIntoAddressSpaceGOOGLE",
                                         "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return =
        vkEnc->vkMapMemoryIntoAddressSpaceGOOGLE(device, memory, pAddress, true /* do lock */);
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}
static void entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
    uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews) {
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
        device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount,
        bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices,
        pImageInfos, pBufferInfos, pBufferViews, true /* do lock */);
}
static void dynCheck_entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
    uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkUpdateDescriptorSetWithTemplateSizedGOOGLE",
                                         "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
        device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount,
        bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices,
        pImageInfos, pBufferInfos, pBufferViews, true /* do lock */);
}
static void entry_vkBeginCommandBufferAsyncGOOGLE(VkCommandBuffer commandBuffer,
                                                  const VkCommandBufferBeginInfo* pBeginInfo) {
    AEMU_SCOPED_TRACE("vkBeginCommandBufferAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkBeginCommandBufferAsyncGOOGLE(commandBuffer, pBeginInfo, true /* do lock */);
}
static void entry_vkEndCommandBufferAsyncGOOGLE(VkCommandBuffer commandBuffer) {
    AEMU_SCOPED_TRACE("vkEndCommandBufferAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkEndCommandBufferAsyncGOOGLE(commandBuffer, true /* do lock */);
}
static void entry_vkResetCommandBufferAsyncGOOGLE(VkCommandBuffer commandBuffer,
                                                  VkCommandBufferResetFlags flags) {
    AEMU_SCOPED_TRACE("vkResetCommandBufferAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkResetCommandBufferAsyncGOOGLE(commandBuffer, flags, true /* do lock */);
}
static void entry_vkCommandBufferHostSyncGOOGLE(VkCommandBuffer commandBuffer,
                                                uint32_t needHostSync, uint32_t sequenceNumber) {
    AEMU_SCOPED_TRACE("vkCommandBufferHostSyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCommandBufferHostSyncGOOGLE(commandBuffer, needHostSync, sequenceNumber,
                                         true /* do lock */);
}
static VkResult entry_vkCreateImageWithRequirementsGOOGLE(
    VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkImage* pImage, VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateImageWithRequirementsGOOGLE_VkResult_return =
        vkEnc->vkCreateImageWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pImage,
                                                   pMemoryRequirements, true /* do lock */);
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateImageWithRequirementsGOOGLE(
    VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkImage* pImage, VkMemoryRequirements* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkCreateImageWithRequirementsGOOGLE",
                                         "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateImageWithRequirementsGOOGLE_VkResult_return =
        vkEnc->vkCreateImageWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pImage,
                                                   pMemoryRequirements, true /* do lock */);
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}
static VkResult entry_vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
        vkEnc->vkCreateBufferWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pBuffer,
                                                    pMemoryRequirements, true /* do lock */);
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkCreateBufferWithRequirementsGOOGLE",
                                         "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateBufferWithRequirementsGOOGLE_VkResult_return =
        vkEnc->vkCreateBufferWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pBuffer,
                                                    pMemoryRequirements, true /* do lock */);
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}
static VkResult entry_vkGetMemoryHostAddressInfoGOOGLE(VkDevice device, VkDeviceMemory memory,
                                                       uint64_t* pAddress, uint64_t* pSize,
                                                       uint64_t* pHostmemId) {
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = vkEnc->vkGetMemoryHostAddressInfoGOOGLE(
        device, memory, pAddress, pSize, pHostmemId, true /* do lock */);
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryHostAddressInfoGOOGLE(VkDevice device,
                                                                VkDeviceMemory memory,
                                                                uint64_t* pAddress, uint64_t* pSize,
                                                                uint64_t* pHostmemId) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryHostAddressInfoGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = vkEnc->vkGetMemoryHostAddressInfoGOOGLE(
        device, memory, pAddress, pSize, pHostmemId, true /* do lock */);
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}
static VkResult entry_vkFreeMemorySyncGOOGLE(VkDevice device, VkDeviceMemory memory,
                                             const VkAllocationCallbacks* pAllocator) {
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    vkFreeMemorySyncGOOGLE_VkResult_return =
        vkEnc->vkFreeMemorySyncGOOGLE(device, memory, pAllocator, true /* do lock */);
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkFreeMemorySyncGOOGLE(VkDevice device, VkDeviceMemory memory,
                                                      const VkAllocationCallbacks* pAllocator) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkFreeMemorySyncGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    vkFreeMemorySyncGOOGLE_VkResult_return =
        vkEnc->vkFreeMemorySyncGOOGLE(device, memory, pAllocator, true /* do lock */);
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}
static void entry_vkQueueHostSyncGOOGLE(VkQueue queue, uint32_t needHostSync,
                                        uint32_t sequenceNumber) {
    AEMU_SCOPED_TRACE("vkQueueHostSyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueHostSyncGOOGLE(queue, needHostSync, sequenceNumber, true /* do lock */);
}
static void entry_vkQueueSubmitAsyncGOOGLE(VkQueue queue, uint32_t submitCount,
                                           const VkSubmitInfo* pSubmits, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueSubmitAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueSubmitAsyncGOOGLE(queue, submitCount, pSubmits, fence, true /* do lock */);
}
static void entry_vkQueueWaitIdleAsyncGOOGLE(VkQueue queue) {
    AEMU_SCOPED_TRACE("vkQueueWaitIdleAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueWaitIdleAsyncGOOGLE(queue, true /* do lock */);
}
static void entry_vkQueueBindSparseAsyncGOOGLE(VkQueue queue, uint32_t bindInfoCount,
                                               const VkBindSparseInfo* pBindInfo, VkFence fence) {
    AEMU_SCOPED_TRACE("vkQueueBindSparseAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueBindSparseAsyncGOOGLE(queue, bindInfoCount, pBindInfo, fence, true /* do lock */);
}
static void entry_vkGetLinearImageLayoutGOOGLE(VkDevice device, VkFormat format,
                                               VkDeviceSize* pOffset,
                                               VkDeviceSize* pRowPitchAlignment) {
    AEMU_SCOPED_TRACE("vkGetLinearImageLayoutGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetLinearImageLayoutGOOGLE(device, format, pOffset, pRowPitchAlignment,
                                        true /* do lock */);
}
static void dynCheck_entry_vkGetLinearImageLayoutGOOGLE(VkDevice device, VkFormat format,
                                                        VkDeviceSize* pOffset,
                                                        VkDeviceSize* pRowPitchAlignment) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkGetLinearImageLayoutGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkGetLinearImageLayoutGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetLinearImageLayoutGOOGLE(device, format, pOffset, pRowPitchAlignment,
                                        true /* do lock */);
}
static void entry_vkGetLinearImageLayout2GOOGLE(VkDevice device,
                                                const VkImageCreateInfo* pCreateInfo,
                                                VkDeviceSize* pOffset,
                                                VkDeviceSize* pRowPitchAlignment) {
    AEMU_SCOPED_TRACE("vkGetLinearImageLayout2GOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetLinearImageLayout2GOOGLE(device, pCreateInfo, pOffset, pRowPitchAlignment,
                                         true /* do lock */);
}
static void dynCheck_entry_vkGetLinearImageLayout2GOOGLE(VkDevice device,
                                                         const VkImageCreateInfo* pCreateInfo,
                                                         VkDeviceSize* pOffset,
                                                         VkDeviceSize* pRowPitchAlignment) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkGetLinearImageLayout2GOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkGetLinearImageLayout2GOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetLinearImageLayout2GOOGLE(device, pCreateInfo, pOffset, pRowPitchAlignment,
                                         true /* do lock */);
}
static void entry_vkQueueFlushCommandsGOOGLE(VkQueue queue, VkCommandBuffer commandBuffer,
                                             VkDeviceSize dataSize, const void* pData) {
    AEMU_SCOPED_TRACE("vkQueueFlushCommandsGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueFlushCommandsGOOGLE(queue, commandBuffer, dataSize, pData, true /* do lock */);
}
static void entry_vkQueueCommitDescriptorSetUpdatesGOOGLE(
    VkQueue queue, uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
    uint32_t descriptorSetCount, const VkDescriptorSetLayout* pSetLayouts,
    const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
    const uint32_t* pDescriptorSetPendingAllocation,
    const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
    const VkWriteDescriptorSet* pPendingDescriptorWrites) {
    AEMU_SCOPED_TRACE("vkQueueCommitDescriptorSetUpdatesGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueCommitDescriptorSetUpdatesGOOGLE(
        queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount, pSetLayouts,
        pDescriptorSetPoolIds, pDescriptorSetWhichPool, pDescriptorSetPendingAllocation,
        pDescriptorWriteStartingIndices, pendingDescriptorWriteCount, pPendingDescriptorWrites,
        true /* do lock */);
}
static void entry_vkCollectDescriptorPoolIdsGOOGLE(VkDevice device, VkDescriptorPool descriptorPool,
                                                   uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
    AEMU_SCOPED_TRACE("vkCollectDescriptorPoolIdsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkCollectDescriptorPoolIdsGOOGLE(device, descriptorPool, pPoolIdCount, pPoolIds,
                                            true /* do lock */);
}
static void dynCheck_entry_vkCollectDescriptorPoolIdsGOOGLE(VkDevice device,
                                                            VkDescriptorPool descriptorPool,
                                                            uint32_t* pPoolIdCount,
                                                            uint64_t* pPoolIds) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkCollectDescriptorPoolIdsGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkCollectDescriptorPoolIdsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkCollectDescriptorPoolIdsGOOGLE(device, descriptorPool, pPoolIdCount, pPoolIds,
                                            true /* do lock */);
}
static void entry_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(VkQueue queue,
                                                              uint32_t waitSemaphoreCount,
                                                              const VkSemaphore* pWaitSemaphores,
                                                              VkImage image) {
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROIDAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(queue, waitSemaphoreCount, pWaitSemaphores,
                                                       image, true /* do lock */);
}
static void entry_vkQueueFlushCommandsFromAuxMemoryGOOGLE(VkQueue queue,
                                                          VkCommandBuffer commandBuffer,
                                                          VkDeviceMemory deviceMemory,
                                                          VkDeviceSize dataOffset,
                                                          VkDeviceSize dataSize) {
    AEMU_SCOPED_TRACE("vkQueueFlushCommandsFromAuxMemoryGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueFlushCommandsFromAuxMemoryGOOGLE(queue, commandBuffer, deviceMemory, dataOffset,
                                                   dataSize, true /* do lock */);
}
static VkResult entry_vkGetBlobGOOGLE(VkDevice device, VkDeviceMemory memory) {
    AEMU_SCOPED_TRACE("vkGetBlobGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetBlobGOOGLE_VkResult_return = (VkResult)0;
    vkGetBlobGOOGLE_VkResult_return = vkEnc->vkGetBlobGOOGLE(device, memory, true /* do lock */);
    return vkGetBlobGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkGetBlobGOOGLE(VkDevice device, VkDeviceMemory memory) {
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream")) {
        sOnInvalidDynamicallyCheckedCall("vkGetBlobGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkGetBlobGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetBlobGOOGLE_VkResult_return = (VkResult)0;
    vkGetBlobGOOGLE_VkResult_return = vkEnc->vkGetBlobGOOGLE(device, memory, true /* do lock */);
    return vkGetBlobGOOGLE_VkResult_return;
}
#endif
#ifdef VK_EXT_load_store_op_none
#endif
void* goldfish_vulkan_get_proc_address(const char* name) {
#ifdef VK_VERSION_1_0
    if (!strcmp(name, "vkCreateInstance")) {
        return (void*)entry_vkCreateInstance;
    }
    if (!strcmp(name, "vkDestroyInstance")) {
        return (void*)entry_vkDestroyInstance;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDevices")) {
        return (void*)entry_vkEnumeratePhysicalDevices;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures")) {
        return (void*)entry_vkGetPhysicalDeviceFeatures;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceImageFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties")) {
        return (void*)entry_vkGetPhysicalDeviceProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties")) {
        return (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties")) {
        return (void*)entry_vkGetPhysicalDeviceMemoryProperties;
    }
    if (!strcmp(name, "vkGetInstanceProcAddr")) {
        return (void*)entry_vkGetInstanceProcAddr;
    }
    if (!strcmp(name, "vkGetDeviceProcAddr")) {
        return (void*)entry_vkGetDeviceProcAddr;
    }
    if (!strcmp(name, "vkCreateDevice")) {
        return (void*)entry_vkCreateDevice;
    }
    if (!strcmp(name, "vkDestroyDevice")) {
        return (void*)entry_vkDestroyDevice;
    }
    if (!strcmp(name, "vkEnumerateInstanceExtensionProperties")) {
        return (void*)entry_vkEnumerateInstanceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceExtensionProperties")) {
        return (void*)entry_vkEnumerateDeviceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateInstanceLayerProperties")) {
        return (void*)entry_vkEnumerateInstanceLayerProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceLayerProperties")) {
        return (void*)entry_vkEnumerateDeviceLayerProperties;
    }
    if (!strcmp(name, "vkGetDeviceQueue")) {
        return (void*)entry_vkGetDeviceQueue;
    }
    if (!strcmp(name, "vkQueueSubmit")) {
        return (void*)entry_vkQueueSubmit;
    }
    if (!strcmp(name, "vkQueueWaitIdle")) {
        return (void*)entry_vkQueueWaitIdle;
    }
    if (!strcmp(name, "vkDeviceWaitIdle")) {
        return (void*)entry_vkDeviceWaitIdle;
    }
    if (!strcmp(name, "vkAllocateMemory")) {
        return (void*)entry_vkAllocateMemory;
    }
    if (!strcmp(name, "vkFreeMemory")) {
        return (void*)entry_vkFreeMemory;
    }
    if (!strcmp(name, "vkMapMemory")) {
        return (void*)entry_vkMapMemory;
    }
    if (!strcmp(name, "vkUnmapMemory")) {
        return (void*)entry_vkUnmapMemory;
    }
    if (!strcmp(name, "vkFlushMappedMemoryRanges")) {
        return (void*)entry_vkFlushMappedMemoryRanges;
    }
    if (!strcmp(name, "vkInvalidateMappedMemoryRanges")) {
        return (void*)entry_vkInvalidateMappedMemoryRanges;
    }
    if (!strcmp(name, "vkGetDeviceMemoryCommitment")) {
        return (void*)entry_vkGetDeviceMemoryCommitment;
    }
    if (!strcmp(name, "vkBindBufferMemory")) {
        return (void*)entry_vkBindBufferMemory;
    }
    if (!strcmp(name, "vkBindImageMemory")) {
        return (void*)entry_vkBindImageMemory;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements")) {
        return (void*)entry_vkGetBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements")) {
        return (void*)entry_vkGetImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements")) {
        return (void*)entry_vkGetImageSparseMemoryRequirements;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties;
    }
    if (!strcmp(name, "vkQueueBindSparse")) {
        return (void*)entry_vkQueueBindSparse;
    }
    if (!strcmp(name, "vkCreateFence")) {
        return (void*)entry_vkCreateFence;
    }
    if (!strcmp(name, "vkDestroyFence")) {
        return (void*)entry_vkDestroyFence;
    }
    if (!strcmp(name, "vkResetFences")) {
        return (void*)entry_vkResetFences;
    }
    if (!strcmp(name, "vkGetFenceStatus")) {
        return (void*)entry_vkGetFenceStatus;
    }
    if (!strcmp(name, "vkWaitForFences")) {
        return (void*)entry_vkWaitForFences;
    }
    if (!strcmp(name, "vkCreateSemaphore")) {
        return (void*)entry_vkCreateSemaphore;
    }
    if (!strcmp(name, "vkDestroySemaphore")) {
        return (void*)entry_vkDestroySemaphore;
    }
    if (!strcmp(name, "vkCreateEvent")) {
        return (void*)entry_vkCreateEvent;
    }
    if (!strcmp(name, "vkDestroyEvent")) {
        return (void*)entry_vkDestroyEvent;
    }
    if (!strcmp(name, "vkGetEventStatus")) {
        return (void*)entry_vkGetEventStatus;
    }
    if (!strcmp(name, "vkSetEvent")) {
        return (void*)entry_vkSetEvent;
    }
    if (!strcmp(name, "vkResetEvent")) {
        return (void*)entry_vkResetEvent;
    }
    if (!strcmp(name, "vkCreateQueryPool")) {
        return (void*)entry_vkCreateQueryPool;
    }
    if (!strcmp(name, "vkDestroyQueryPool")) {
        return (void*)entry_vkDestroyQueryPool;
    }
    if (!strcmp(name, "vkGetQueryPoolResults")) {
        return (void*)entry_vkGetQueryPoolResults;
    }
    if (!strcmp(name, "vkCreateBuffer")) {
        return (void*)entry_vkCreateBuffer;
    }
    if (!strcmp(name, "vkDestroyBuffer")) {
        return (void*)entry_vkDestroyBuffer;
    }
    if (!strcmp(name, "vkCreateBufferView")) {
        return (void*)entry_vkCreateBufferView;
    }
    if (!strcmp(name, "vkDestroyBufferView")) {
        return (void*)entry_vkDestroyBufferView;
    }
    if (!strcmp(name, "vkCreateImage")) {
        return (void*)entry_vkCreateImage;
    }
    if (!strcmp(name, "vkDestroyImage")) {
        return (void*)entry_vkDestroyImage;
    }
    if (!strcmp(name, "vkGetImageSubresourceLayout")) {
        return (void*)entry_vkGetImageSubresourceLayout;
    }
    if (!strcmp(name, "vkCreateImageView")) {
        return (void*)entry_vkCreateImageView;
    }
    if (!strcmp(name, "vkDestroyImageView")) {
        return (void*)entry_vkDestroyImageView;
    }
    if (!strcmp(name, "vkCreateShaderModule")) {
        return (void*)entry_vkCreateShaderModule;
    }
    if (!strcmp(name, "vkDestroyShaderModule")) {
        return (void*)entry_vkDestroyShaderModule;
    }
    if (!strcmp(name, "vkCreatePipelineCache")) {
        return (void*)entry_vkCreatePipelineCache;
    }
    if (!strcmp(name, "vkDestroyPipelineCache")) {
        return (void*)entry_vkDestroyPipelineCache;
    }
    if (!strcmp(name, "vkGetPipelineCacheData")) {
        return (void*)entry_vkGetPipelineCacheData;
    }
    if (!strcmp(name, "vkMergePipelineCaches")) {
        return (void*)entry_vkMergePipelineCaches;
    }
    if (!strcmp(name, "vkCreateGraphicsPipelines")) {
        return (void*)entry_vkCreateGraphicsPipelines;
    }
    if (!strcmp(name, "vkCreateComputePipelines")) {
        return (void*)entry_vkCreateComputePipelines;
    }
    if (!strcmp(name, "vkDestroyPipeline")) {
        return (void*)entry_vkDestroyPipeline;
    }
    if (!strcmp(name, "vkCreatePipelineLayout")) {
        return (void*)entry_vkCreatePipelineLayout;
    }
    if (!strcmp(name, "vkDestroyPipelineLayout")) {
        return (void*)entry_vkDestroyPipelineLayout;
    }
    if (!strcmp(name, "vkCreateSampler")) {
        return (void*)entry_vkCreateSampler;
    }
    if (!strcmp(name, "vkDestroySampler")) {
        return (void*)entry_vkDestroySampler;
    }
    if (!strcmp(name, "vkCreateDescriptorSetLayout")) {
        return (void*)entry_vkCreateDescriptorSetLayout;
    }
    if (!strcmp(name, "vkDestroyDescriptorSetLayout")) {
        return (void*)entry_vkDestroyDescriptorSetLayout;
    }
    if (!strcmp(name, "vkCreateDescriptorPool")) {
        return (void*)entry_vkCreateDescriptorPool;
    }
    if (!strcmp(name, "vkDestroyDescriptorPool")) {
        return (void*)entry_vkDestroyDescriptorPool;
    }
    if (!strcmp(name, "vkResetDescriptorPool")) {
        return (void*)entry_vkResetDescriptorPool;
    }
    if (!strcmp(name, "vkAllocateDescriptorSets")) {
        return (void*)entry_vkAllocateDescriptorSets;
    }
    if (!strcmp(name, "vkFreeDescriptorSets")) {
        return (void*)entry_vkFreeDescriptorSets;
    }
    if (!strcmp(name, "vkUpdateDescriptorSets")) {
        return (void*)entry_vkUpdateDescriptorSets;
    }
    if (!strcmp(name, "vkCreateFramebuffer")) {
        return (void*)entry_vkCreateFramebuffer;
    }
    if (!strcmp(name, "vkDestroyFramebuffer")) {
        return (void*)entry_vkDestroyFramebuffer;
    }
    if (!strcmp(name, "vkCreateRenderPass")) {
        return (void*)entry_vkCreateRenderPass;
    }
    if (!strcmp(name, "vkDestroyRenderPass")) {
        return (void*)entry_vkDestroyRenderPass;
    }
    if (!strcmp(name, "vkGetRenderAreaGranularity")) {
        return (void*)entry_vkGetRenderAreaGranularity;
    }
    if (!strcmp(name, "vkCreateCommandPool")) {
        return (void*)entry_vkCreateCommandPool;
    }
    if (!strcmp(name, "vkDestroyCommandPool")) {
        return (void*)entry_vkDestroyCommandPool;
    }
    if (!strcmp(name, "vkResetCommandPool")) {
        return (void*)entry_vkResetCommandPool;
    }
    if (!strcmp(name, "vkAllocateCommandBuffers")) {
        return (void*)entry_vkAllocateCommandBuffers;
    }
    if (!strcmp(name, "vkFreeCommandBuffers")) {
        return (void*)entry_vkFreeCommandBuffers;
    }
    if (!strcmp(name, "vkBeginCommandBuffer")) {
        return (void*)entry_vkBeginCommandBuffer;
    }
    if (!strcmp(name, "vkEndCommandBuffer")) {
        return (void*)entry_vkEndCommandBuffer;
    }
    if (!strcmp(name, "vkResetCommandBuffer")) {
        return (void*)entry_vkResetCommandBuffer;
    }
    if (!strcmp(name, "vkCmdBindPipeline")) {
        return (void*)entry_vkCmdBindPipeline;
    }
    if (!strcmp(name, "vkCmdSetViewport")) {
        return (void*)entry_vkCmdSetViewport;
    }
    if (!strcmp(name, "vkCmdSetScissor")) {
        return (void*)entry_vkCmdSetScissor;
    }
    if (!strcmp(name, "vkCmdSetLineWidth")) {
        return (void*)entry_vkCmdSetLineWidth;
    }
    if (!strcmp(name, "vkCmdSetDepthBias")) {
        return (void*)entry_vkCmdSetDepthBias;
    }
    if (!strcmp(name, "vkCmdSetBlendConstants")) {
        return (void*)entry_vkCmdSetBlendConstants;
    }
    if (!strcmp(name, "vkCmdSetDepthBounds")) {
        return (void*)entry_vkCmdSetDepthBounds;
    }
    if (!strcmp(name, "vkCmdSetStencilCompareMask")) {
        return (void*)entry_vkCmdSetStencilCompareMask;
    }
    if (!strcmp(name, "vkCmdSetStencilWriteMask")) {
        return (void*)entry_vkCmdSetStencilWriteMask;
    }
    if (!strcmp(name, "vkCmdSetStencilReference")) {
        return (void*)entry_vkCmdSetStencilReference;
    }
    if (!strcmp(name, "vkCmdBindDescriptorSets")) {
        return (void*)entry_vkCmdBindDescriptorSets;
    }
    if (!strcmp(name, "vkCmdBindIndexBuffer")) {
        return (void*)entry_vkCmdBindIndexBuffer;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers")) {
        return (void*)entry_vkCmdBindVertexBuffers;
    }
    if (!strcmp(name, "vkCmdDraw")) {
        return (void*)entry_vkCmdDraw;
    }
    if (!strcmp(name, "vkCmdDrawIndexed")) {
        return (void*)entry_vkCmdDrawIndexed;
    }
    if (!strcmp(name, "vkCmdDrawIndirect")) {
        return (void*)entry_vkCmdDrawIndirect;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirect")) {
        return (void*)entry_vkCmdDrawIndexedIndirect;
    }
    if (!strcmp(name, "vkCmdDispatch")) {
        return (void*)entry_vkCmdDispatch;
    }
    if (!strcmp(name, "vkCmdDispatchIndirect")) {
        return (void*)entry_vkCmdDispatchIndirect;
    }
    if (!strcmp(name, "vkCmdCopyBuffer")) {
        return (void*)entry_vkCmdCopyBuffer;
    }
    if (!strcmp(name, "vkCmdCopyImage")) {
        return (void*)entry_vkCmdCopyImage;
    }
    if (!strcmp(name, "vkCmdBlitImage")) {
        return (void*)entry_vkCmdBlitImage;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage")) {
        return (void*)entry_vkCmdCopyBufferToImage;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer")) {
        return (void*)entry_vkCmdCopyImageToBuffer;
    }
    if (!strcmp(name, "vkCmdUpdateBuffer")) {
        return (void*)entry_vkCmdUpdateBuffer;
    }
    if (!strcmp(name, "vkCmdFillBuffer")) {
        return (void*)entry_vkCmdFillBuffer;
    }
    if (!strcmp(name, "vkCmdClearColorImage")) {
        return (void*)entry_vkCmdClearColorImage;
    }
    if (!strcmp(name, "vkCmdClearDepthStencilImage")) {
        return (void*)entry_vkCmdClearDepthStencilImage;
    }
    if (!strcmp(name, "vkCmdClearAttachments")) {
        return (void*)entry_vkCmdClearAttachments;
    }
    if (!strcmp(name, "vkCmdResolveImage")) {
        return (void*)entry_vkCmdResolveImage;
    }
    if (!strcmp(name, "vkCmdSetEvent")) {
        return (void*)entry_vkCmdSetEvent;
    }
    if (!strcmp(name, "vkCmdResetEvent")) {
        return (void*)entry_vkCmdResetEvent;
    }
    if (!strcmp(name, "vkCmdWaitEvents")) {
        return (void*)entry_vkCmdWaitEvents;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier")) {
        return (void*)entry_vkCmdPipelineBarrier;
    }
    if (!strcmp(name, "vkCmdBeginQuery")) {
        return (void*)entry_vkCmdBeginQuery;
    }
    if (!strcmp(name, "vkCmdEndQuery")) {
        return (void*)entry_vkCmdEndQuery;
    }
    if (!strcmp(name, "vkCmdResetQueryPool")) {
        return (void*)entry_vkCmdResetQueryPool;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp")) {
        return (void*)entry_vkCmdWriteTimestamp;
    }
    if (!strcmp(name, "vkCmdCopyQueryPoolResults")) {
        return (void*)entry_vkCmdCopyQueryPoolResults;
    }
    if (!strcmp(name, "vkCmdPushConstants")) {
        return (void*)entry_vkCmdPushConstants;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass")) {
        return (void*)entry_vkCmdBeginRenderPass;
    }
    if (!strcmp(name, "vkCmdNextSubpass")) {
        return (void*)entry_vkCmdNextSubpass;
    }
    if (!strcmp(name, "vkCmdEndRenderPass")) {
        return (void*)entry_vkCmdEndRenderPass;
    }
    if (!strcmp(name, "vkCmdExecuteCommands")) {
        return (void*)entry_vkCmdExecuteCommands;
    }
#endif
#ifdef VK_VERSION_1_1
    if (!strcmp(name, "vkEnumerateInstanceVersion")) {
        return nullptr;
    }
    if (!strcmp(name, "vkBindBufferMemory2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeatures")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDeviceMask")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBase")) {
        return nullptr;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroups")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkTrimCommandPool")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceQueue2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateSamplerYcbcrConversion")) {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversion")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplate")) {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplate")) {
        return nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplate")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferProperties")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFenceProperties")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphoreProperties")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupport")) {
        return nullptr;
    }
#endif
#ifdef VK_VERSION_1_2
    if (!strcmp(name, "vkCmdDrawIndirectCount")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCount")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateRenderPass2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkResetQueryPool")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreCounterValue")) {
        return nullptr;
    }
    if (!strcmp(name, "vkWaitSemaphores")) {
        return nullptr;
    }
    if (!strcmp(name, "vkSignalSemaphore")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferDeviceAddress")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddress")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddress")) {
        return nullptr;
    }
#endif
#ifdef VK_VERSION_1_3
    if (!strcmp(name, "vkGetPhysicalDeviceToolProperties")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCreatePrivateDataSlot")) {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyPrivateDataSlot")) {
        return nullptr;
    }
    if (!strcmp(name, "vkSetPrivateData")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPrivateData")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetEvent2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdResetEvent2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdWaitEvents2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSubmit2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBuffer2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImage2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBlitImage2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdResolveImage2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRendering")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndRendering")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetCullMode")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetFrontFace")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveTopology")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportWithCount")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetScissorWithCount")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers2")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthTestEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthWriteEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthCompareOp")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBoundsTestEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilTestEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilOp")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetRasterizerDiscardEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBiasEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveRestartEnable")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceBufferMemoryRequirements")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceImageMemoryRequirements")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceImageSparseMemoryRequirements")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_android_surface
    if (!strcmp(name, "vkCreateAndroidSurfaceKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_maintenance1
    if (!strcmp(name, "vkTrimCommandPoolKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferPropertiesKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_fd
    if (!strcmp(name, "vkImportSemaphoreFdKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreFdKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_descriptor_update_template
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplateKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplateKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_create_renderpass2
    if (!strcmp(name, "vkCreateRenderPass2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2KHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFencePropertiesKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_fd
    if (!strcmp(name, "vkImportFenceFdKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetFenceFdKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_get_memory_requirements2
    if (!strcmp(name, "vkGetImageMemoryRequirements2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2KHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    if (!strcmp(name, "vkCreateSamplerYcbcrConversionKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversionKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_bind_memory2
    if (!strcmp(name, "vkBindBufferMemory2KHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2KHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_maintenance3
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupportKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddressKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddressKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_KHR_pipeline_executable_properties
    if (!strcmp(name, "vkGetPipelineExecutablePropertiesKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableStatisticsKHR")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableInternalRepresentationsKHR")) {
        return nullptr;
    }
#endif
#ifdef VK_ANDROID_native_buffer
    if (!strcmp(name, "vkGetSwapchainGrallocUsageANDROID")) {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquireImageANDROID")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROID")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSwapchainGrallocUsage2ANDROID")) {
        return nullptr;
    }
#endif
#ifdef VK_EXT_transform_feedback
    if (!strcmp(name, "vkCmdBindTransformFeedbackBuffersEXT")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginTransformFeedbackEXT")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndTransformFeedbackEXT")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginQueryIndexedEXT")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndQueryIndexedEXT")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndirectByteCountEXT")) {
        return nullptr;
    }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (!strcmp(name, "vkGetAndroidHardwareBufferPropertiesANDROID")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMemoryAndroidHardwareBufferANDROID")) {
        return nullptr;
    }
#endif
#ifdef VK_EXT_line_rasterization
    if (!strcmp(name, "vkCmdSetLineStippleEXT")) {
        return nullptr;
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    if (!strcmp(name, "vkMapMemoryIntoAddressSpaceGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateSizedGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkBeginCommandBufferAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkEndCommandBufferAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkResetCommandBufferAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCommandBufferHostSyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateImageWithRequirementsGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateBufferWithRequirementsGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMemoryHostAddressInfoGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkFreeMemorySyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueHostSyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSubmitAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueWaitIdleAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueBindSparseAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayoutGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayout2GOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueCommitDescriptorSetUpdatesGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkCollectDescriptorPoolIdsGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROIDAsyncGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsFromAuxMemoryGOOGLE")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBlobGOOGLE")) {
        return nullptr;
    }
#endif
    return nullptr;
}
void* goldfish_vulkan_get_instance_proc_address(VkInstance instance, const char* name) {
    auto resources = ResourceTracker::get();
    bool has1_1OrHigher = resources->getApiVersionFromInstance(instance) >= VK_API_VERSION_1_1;
    bool has1_2OrHigher = resources->getApiVersionFromInstance(instance) >= VK_API_VERSION_1_2;
#ifdef VK_VERSION_1_0
    if (!strcmp(name, "vkCreateInstance")) {
        return (void*)entry_vkCreateInstance;
    }
    if (!strcmp(name, "vkDestroyInstance")) {
        return (void*)entry_vkDestroyInstance;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDevices")) {
        return (void*)entry_vkEnumeratePhysicalDevices;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures")) {
        return (void*)entry_vkGetPhysicalDeviceFeatures;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceImageFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties")) {
        return (void*)entry_vkGetPhysicalDeviceProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties")) {
        return (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties")) {
        return (void*)entry_vkGetPhysicalDeviceMemoryProperties;
    }
    if (!strcmp(name, "vkGetInstanceProcAddr")) {
        return (void*)entry_vkGetInstanceProcAddr;
    }
    if (!strcmp(name, "vkGetDeviceProcAddr")) {
        return (void*)entry_vkGetDeviceProcAddr;
    }
    if (!strcmp(name, "vkCreateDevice")) {
        return (void*)entry_vkCreateDevice;
    }
    if (!strcmp(name, "vkDestroyDevice")) {
        return (void*)entry_vkDestroyDevice;
    }
    if (!strcmp(name, "vkEnumerateInstanceExtensionProperties")) {
        return (void*)entry_vkEnumerateInstanceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceExtensionProperties")) {
        return (void*)entry_vkEnumerateDeviceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateInstanceLayerProperties")) {
        return (void*)entry_vkEnumerateInstanceLayerProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceLayerProperties")) {
        return (void*)entry_vkEnumerateDeviceLayerProperties;
    }
    if (!strcmp(name, "vkGetDeviceQueue")) {
        return (void*)entry_vkGetDeviceQueue;
    }
    if (!strcmp(name, "vkQueueSubmit")) {
        return (void*)entry_vkQueueSubmit;
    }
    if (!strcmp(name, "vkQueueWaitIdle")) {
        return (void*)entry_vkQueueWaitIdle;
    }
    if (!strcmp(name, "vkDeviceWaitIdle")) {
        return (void*)entry_vkDeviceWaitIdle;
    }
    if (!strcmp(name, "vkAllocateMemory")) {
        return (void*)entry_vkAllocateMemory;
    }
    if (!strcmp(name, "vkFreeMemory")) {
        return (void*)entry_vkFreeMemory;
    }
    if (!strcmp(name, "vkMapMemory")) {
        return (void*)entry_vkMapMemory;
    }
    if (!strcmp(name, "vkUnmapMemory")) {
        return (void*)entry_vkUnmapMemory;
    }
    if (!strcmp(name, "vkFlushMappedMemoryRanges")) {
        return (void*)entry_vkFlushMappedMemoryRanges;
    }
    if (!strcmp(name, "vkInvalidateMappedMemoryRanges")) {
        return (void*)entry_vkInvalidateMappedMemoryRanges;
    }
    if (!strcmp(name, "vkGetDeviceMemoryCommitment")) {
        return (void*)entry_vkGetDeviceMemoryCommitment;
    }
    if (!strcmp(name, "vkBindBufferMemory")) {
        return (void*)entry_vkBindBufferMemory;
    }
    if (!strcmp(name, "vkBindImageMemory")) {
        return (void*)entry_vkBindImageMemory;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements")) {
        return (void*)entry_vkGetBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements")) {
        return (void*)entry_vkGetImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements")) {
        return (void*)entry_vkGetImageSparseMemoryRequirements;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties;
    }
    if (!strcmp(name, "vkQueueBindSparse")) {
        return (void*)entry_vkQueueBindSparse;
    }
    if (!strcmp(name, "vkCreateFence")) {
        return (void*)entry_vkCreateFence;
    }
    if (!strcmp(name, "vkDestroyFence")) {
        return (void*)entry_vkDestroyFence;
    }
    if (!strcmp(name, "vkResetFences")) {
        return (void*)entry_vkResetFences;
    }
    if (!strcmp(name, "vkGetFenceStatus")) {
        return (void*)entry_vkGetFenceStatus;
    }
    if (!strcmp(name, "vkWaitForFences")) {
        return (void*)entry_vkWaitForFences;
    }
    if (!strcmp(name, "vkCreateSemaphore")) {
        return (void*)entry_vkCreateSemaphore;
    }
    if (!strcmp(name, "vkDestroySemaphore")) {
        return (void*)entry_vkDestroySemaphore;
    }
    if (!strcmp(name, "vkCreateEvent")) {
        return (void*)entry_vkCreateEvent;
    }
    if (!strcmp(name, "vkDestroyEvent")) {
        return (void*)entry_vkDestroyEvent;
    }
    if (!strcmp(name, "vkGetEventStatus")) {
        return (void*)entry_vkGetEventStatus;
    }
    if (!strcmp(name, "vkSetEvent")) {
        return (void*)entry_vkSetEvent;
    }
    if (!strcmp(name, "vkResetEvent")) {
        return (void*)entry_vkResetEvent;
    }
    if (!strcmp(name, "vkCreateQueryPool")) {
        return (void*)entry_vkCreateQueryPool;
    }
    if (!strcmp(name, "vkDestroyQueryPool")) {
        return (void*)entry_vkDestroyQueryPool;
    }
    if (!strcmp(name, "vkGetQueryPoolResults")) {
        return (void*)entry_vkGetQueryPoolResults;
    }
    if (!strcmp(name, "vkCreateBuffer")) {
        return (void*)entry_vkCreateBuffer;
    }
    if (!strcmp(name, "vkDestroyBuffer")) {
        return (void*)entry_vkDestroyBuffer;
    }
    if (!strcmp(name, "vkCreateBufferView")) {
        return (void*)entry_vkCreateBufferView;
    }
    if (!strcmp(name, "vkDestroyBufferView")) {
        return (void*)entry_vkDestroyBufferView;
    }
    if (!strcmp(name, "vkCreateImage")) {
        return (void*)entry_vkCreateImage;
    }
    if (!strcmp(name, "vkDestroyImage")) {
        return (void*)entry_vkDestroyImage;
    }
    if (!strcmp(name, "vkGetImageSubresourceLayout")) {
        return (void*)entry_vkGetImageSubresourceLayout;
    }
    if (!strcmp(name, "vkCreateImageView")) {
        return (void*)entry_vkCreateImageView;
    }
    if (!strcmp(name, "vkDestroyImageView")) {
        return (void*)entry_vkDestroyImageView;
    }
    if (!strcmp(name, "vkCreateShaderModule")) {
        return (void*)entry_vkCreateShaderModule;
    }
    if (!strcmp(name, "vkDestroyShaderModule")) {
        return (void*)entry_vkDestroyShaderModule;
    }
    if (!strcmp(name, "vkCreatePipelineCache")) {
        return (void*)entry_vkCreatePipelineCache;
    }
    if (!strcmp(name, "vkDestroyPipelineCache")) {
        return (void*)entry_vkDestroyPipelineCache;
    }
    if (!strcmp(name, "vkGetPipelineCacheData")) {
        return (void*)entry_vkGetPipelineCacheData;
    }
    if (!strcmp(name, "vkMergePipelineCaches")) {
        return (void*)entry_vkMergePipelineCaches;
    }
    if (!strcmp(name, "vkCreateGraphicsPipelines")) {
        return (void*)entry_vkCreateGraphicsPipelines;
    }
    if (!strcmp(name, "vkCreateComputePipelines")) {
        return (void*)entry_vkCreateComputePipelines;
    }
    if (!strcmp(name, "vkDestroyPipeline")) {
        return (void*)entry_vkDestroyPipeline;
    }
    if (!strcmp(name, "vkCreatePipelineLayout")) {
        return (void*)entry_vkCreatePipelineLayout;
    }
    if (!strcmp(name, "vkDestroyPipelineLayout")) {
        return (void*)entry_vkDestroyPipelineLayout;
    }
    if (!strcmp(name, "vkCreateSampler")) {
        return (void*)entry_vkCreateSampler;
    }
    if (!strcmp(name, "vkDestroySampler")) {
        return (void*)entry_vkDestroySampler;
    }
    if (!strcmp(name, "vkCreateDescriptorSetLayout")) {
        return (void*)entry_vkCreateDescriptorSetLayout;
    }
    if (!strcmp(name, "vkDestroyDescriptorSetLayout")) {
        return (void*)entry_vkDestroyDescriptorSetLayout;
    }
    if (!strcmp(name, "vkCreateDescriptorPool")) {
        return (void*)entry_vkCreateDescriptorPool;
    }
    if (!strcmp(name, "vkDestroyDescriptorPool")) {
        return (void*)entry_vkDestroyDescriptorPool;
    }
    if (!strcmp(name, "vkResetDescriptorPool")) {
        return (void*)entry_vkResetDescriptorPool;
    }
    if (!strcmp(name, "vkAllocateDescriptorSets")) {
        return (void*)entry_vkAllocateDescriptorSets;
    }
    if (!strcmp(name, "vkFreeDescriptorSets")) {
        return (void*)entry_vkFreeDescriptorSets;
    }
    if (!strcmp(name, "vkUpdateDescriptorSets")) {
        return (void*)entry_vkUpdateDescriptorSets;
    }
    if (!strcmp(name, "vkCreateFramebuffer")) {
        return (void*)entry_vkCreateFramebuffer;
    }
    if (!strcmp(name, "vkDestroyFramebuffer")) {
        return (void*)entry_vkDestroyFramebuffer;
    }
    if (!strcmp(name, "vkCreateRenderPass")) {
        return (void*)entry_vkCreateRenderPass;
    }
    if (!strcmp(name, "vkDestroyRenderPass")) {
        return (void*)entry_vkDestroyRenderPass;
    }
    if (!strcmp(name, "vkGetRenderAreaGranularity")) {
        return (void*)entry_vkGetRenderAreaGranularity;
    }
    if (!strcmp(name, "vkCreateCommandPool")) {
        return (void*)entry_vkCreateCommandPool;
    }
    if (!strcmp(name, "vkDestroyCommandPool")) {
        return (void*)entry_vkDestroyCommandPool;
    }
    if (!strcmp(name, "vkResetCommandPool")) {
        return (void*)entry_vkResetCommandPool;
    }
    if (!strcmp(name, "vkAllocateCommandBuffers")) {
        return (void*)entry_vkAllocateCommandBuffers;
    }
    if (!strcmp(name, "vkFreeCommandBuffers")) {
        return (void*)entry_vkFreeCommandBuffers;
    }
    if (!strcmp(name, "vkBeginCommandBuffer")) {
        return (void*)entry_vkBeginCommandBuffer;
    }
    if (!strcmp(name, "vkEndCommandBuffer")) {
        return (void*)entry_vkEndCommandBuffer;
    }
    if (!strcmp(name, "vkResetCommandBuffer")) {
        return (void*)entry_vkResetCommandBuffer;
    }
    if (!strcmp(name, "vkCmdBindPipeline")) {
        return (void*)entry_vkCmdBindPipeline;
    }
    if (!strcmp(name, "vkCmdSetViewport")) {
        return (void*)entry_vkCmdSetViewport;
    }
    if (!strcmp(name, "vkCmdSetScissor")) {
        return (void*)entry_vkCmdSetScissor;
    }
    if (!strcmp(name, "vkCmdSetLineWidth")) {
        return (void*)entry_vkCmdSetLineWidth;
    }
    if (!strcmp(name, "vkCmdSetDepthBias")) {
        return (void*)entry_vkCmdSetDepthBias;
    }
    if (!strcmp(name, "vkCmdSetBlendConstants")) {
        return (void*)entry_vkCmdSetBlendConstants;
    }
    if (!strcmp(name, "vkCmdSetDepthBounds")) {
        return (void*)entry_vkCmdSetDepthBounds;
    }
    if (!strcmp(name, "vkCmdSetStencilCompareMask")) {
        return (void*)entry_vkCmdSetStencilCompareMask;
    }
    if (!strcmp(name, "vkCmdSetStencilWriteMask")) {
        return (void*)entry_vkCmdSetStencilWriteMask;
    }
    if (!strcmp(name, "vkCmdSetStencilReference")) {
        return (void*)entry_vkCmdSetStencilReference;
    }
    if (!strcmp(name, "vkCmdBindDescriptorSets")) {
        return (void*)entry_vkCmdBindDescriptorSets;
    }
    if (!strcmp(name, "vkCmdBindIndexBuffer")) {
        return (void*)entry_vkCmdBindIndexBuffer;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers")) {
        return (void*)entry_vkCmdBindVertexBuffers;
    }
    if (!strcmp(name, "vkCmdDraw")) {
        return (void*)entry_vkCmdDraw;
    }
    if (!strcmp(name, "vkCmdDrawIndexed")) {
        return (void*)entry_vkCmdDrawIndexed;
    }
    if (!strcmp(name, "vkCmdDrawIndirect")) {
        return (void*)entry_vkCmdDrawIndirect;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirect")) {
        return (void*)entry_vkCmdDrawIndexedIndirect;
    }
    if (!strcmp(name, "vkCmdDispatch")) {
        return (void*)entry_vkCmdDispatch;
    }
    if (!strcmp(name, "vkCmdDispatchIndirect")) {
        return (void*)entry_vkCmdDispatchIndirect;
    }
    if (!strcmp(name, "vkCmdCopyBuffer")) {
        return (void*)entry_vkCmdCopyBuffer;
    }
    if (!strcmp(name, "vkCmdCopyImage")) {
        return (void*)entry_vkCmdCopyImage;
    }
    if (!strcmp(name, "vkCmdBlitImage")) {
        return (void*)entry_vkCmdBlitImage;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage")) {
        return (void*)entry_vkCmdCopyBufferToImage;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer")) {
        return (void*)entry_vkCmdCopyImageToBuffer;
    }
    if (!strcmp(name, "vkCmdUpdateBuffer")) {
        return (void*)entry_vkCmdUpdateBuffer;
    }
    if (!strcmp(name, "vkCmdFillBuffer")) {
        return (void*)entry_vkCmdFillBuffer;
    }
    if (!strcmp(name, "vkCmdClearColorImage")) {
        return (void*)entry_vkCmdClearColorImage;
    }
    if (!strcmp(name, "vkCmdClearDepthStencilImage")) {
        return (void*)entry_vkCmdClearDepthStencilImage;
    }
    if (!strcmp(name, "vkCmdClearAttachments")) {
        return (void*)entry_vkCmdClearAttachments;
    }
    if (!strcmp(name, "vkCmdResolveImage")) {
        return (void*)entry_vkCmdResolveImage;
    }
    if (!strcmp(name, "vkCmdSetEvent")) {
        return (void*)entry_vkCmdSetEvent;
    }
    if (!strcmp(name, "vkCmdResetEvent")) {
        return (void*)entry_vkCmdResetEvent;
    }
    if (!strcmp(name, "vkCmdWaitEvents")) {
        return (void*)entry_vkCmdWaitEvents;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier")) {
        return (void*)entry_vkCmdPipelineBarrier;
    }
    if (!strcmp(name, "vkCmdBeginQuery")) {
        return (void*)entry_vkCmdBeginQuery;
    }
    if (!strcmp(name, "vkCmdEndQuery")) {
        return (void*)entry_vkCmdEndQuery;
    }
    if (!strcmp(name, "vkCmdResetQueryPool")) {
        return (void*)entry_vkCmdResetQueryPool;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp")) {
        return (void*)entry_vkCmdWriteTimestamp;
    }
    if (!strcmp(name, "vkCmdCopyQueryPoolResults")) {
        return (void*)entry_vkCmdCopyQueryPoolResults;
    }
    if (!strcmp(name, "vkCmdPushConstants")) {
        return (void*)entry_vkCmdPushConstants;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass")) {
        return (void*)entry_vkCmdBeginRenderPass;
    }
    if (!strcmp(name, "vkCmdNextSubpass")) {
        return (void*)entry_vkCmdNextSubpass;
    }
    if (!strcmp(name, "vkCmdEndRenderPass")) {
        return (void*)entry_vkCmdEndRenderPass;
    }
    if (!strcmp(name, "vkCmdExecuteCommands")) {
        return (void*)entry_vkCmdExecuteCommands;
    }
#endif
#ifdef VK_VERSION_1_1
    if (!strcmp(name, "vkEnumerateInstanceVersion")) {
        return has1_1OrHigher ? (void*)entry_vkEnumerateInstanceVersion : nullptr;
    }
    if (!strcmp(name, "vkBindBufferMemory2")) {
        return (void*)dynCheck_entry_vkBindBufferMemory2;
    }
    if (!strcmp(name, "vkBindImageMemory2")) {
        return (void*)dynCheck_entry_vkBindImageMemory2;
    }
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeatures")) {
        return (void*)dynCheck_entry_vkGetDeviceGroupPeerMemoryFeatures;
    }
    if (!strcmp(name, "vkCmdSetDeviceMask")) {
        return has1_1OrHigher ? (void*)entry_vkCmdSetDeviceMask : nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBase")) {
        return has1_1OrHigher ? (void*)entry_vkCmdDispatchBase : nullptr;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroups")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements2")) {
        return (void*)dynCheck_entry_vkGetImageMemoryRequirements2;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2")) {
        return (void*)dynCheck_entry_vkGetBufferMemoryRequirements2;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2")) {
        return (void*)dynCheck_entry_vkGetImageSparseMemoryRequirements2;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFeatures2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2
                              : nullptr;
    }
    if (!strcmp(name, "vkTrimCommandPool")) {
        return (void*)dynCheck_entry_vkTrimCommandPool;
    }
    if (!strcmp(name, "vkGetDeviceQueue2")) {
        return (void*)dynCheck_entry_vkGetDeviceQueue2;
    }
    if (!strcmp(name, "vkCreateSamplerYcbcrConversion")) {
        return (void*)dynCheck_entry_vkCreateSamplerYcbcrConversion;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversion")) {
        return (void*)dynCheck_entry_vkDestroySamplerYcbcrConversion;
    }
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplate")) {
        return (void*)dynCheck_entry_vkCreateDescriptorUpdateTemplate;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplate")) {
        return (void*)dynCheck_entry_vkDestroyDescriptorUpdateTemplate;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplate")) {
        return (void*)dynCheck_entry_vkUpdateDescriptorSetWithTemplate;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferProperties")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalBufferProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFenceProperties")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalFenceProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphoreProperties")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalSemaphoreProperties
                              : nullptr;
    }
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupport")) {
        return (void*)dynCheck_entry_vkGetDescriptorSetLayoutSupport;
    }
#endif
#ifdef VK_VERSION_1_2
    if (!strcmp(name, "vkCmdDrawIndirectCount")) {
        return has1_2OrHigher ? (void*)entry_vkCmdDrawIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCount")) {
        return has1_2OrHigher ? (void*)entry_vkCmdDrawIndexedIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCreateRenderPass2")) {
        return (void*)dynCheck_entry_vkCreateRenderPass2;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2")) {
        return has1_2OrHigher ? (void*)entry_vkCmdBeginRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2")) {
        return has1_2OrHigher ? (void*)entry_vkCmdNextSubpass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2")) {
        return has1_2OrHigher ? (void*)entry_vkCmdEndRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkResetQueryPool")) {
        return (void*)dynCheck_entry_vkResetQueryPool;
    }
    if (!strcmp(name, "vkGetSemaphoreCounterValue")) {
        return (void*)dynCheck_entry_vkGetSemaphoreCounterValue;
    }
    if (!strcmp(name, "vkWaitSemaphores")) {
        return (void*)dynCheck_entry_vkWaitSemaphores;
    }
    if (!strcmp(name, "vkSignalSemaphore")) {
        return (void*)dynCheck_entry_vkSignalSemaphore;
    }
    if (!strcmp(name, "vkGetBufferDeviceAddress")) {
        return (void*)dynCheck_entry_vkGetBufferDeviceAddress;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddress")) {
        return (void*)dynCheck_entry_vkGetBufferOpaqueCaptureAddress;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddress")) {
        return (void*)dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddress;
    }
#endif
#ifdef VK_VERSION_1_3
    if (!strcmp(name, "vkGetPhysicalDeviceToolProperties")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkGetPhysicalDeviceToolProperties;
    }
    if (!strcmp(name, "vkCreatePrivateDataSlot")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCreatePrivateDataSlot;
    }
    if (!strcmp(name, "vkDestroyPrivateDataSlot")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkDestroyPrivateDataSlot;
    }
    if (!strcmp(name, "vkSetPrivateData")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkSetPrivateData;
    }
    if (!strcmp(name, "vkGetPrivateData")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetPrivateData;
    }
    if (!strcmp(name, "vkCmdSetEvent2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetEvent2;
    }
    if (!strcmp(name, "vkCmdResetEvent2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdResetEvent2;
    }
    if (!strcmp(name, "vkCmdWaitEvents2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdWaitEvents2;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdPipelineBarrier2;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdWriteTimestamp2;
    }
    if (!strcmp(name, "vkQueueSubmit2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkQueueSubmit2;
    }
    if (!strcmp(name, "vkCmdCopyBuffer2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdCopyBuffer2;
    }
    if (!strcmp(name, "vkCmdCopyImage2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdCopyImage2;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdCopyBufferToImage2;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdCopyImageToBuffer2;
    }
    if (!strcmp(name, "vkCmdBlitImage2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdBlitImage2;
    }
    if (!strcmp(name, "vkCmdResolveImage2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdResolveImage2;
    }
    if (!strcmp(name, "vkCmdBeginRendering")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdBeginRendering;
    }
    if (!strcmp(name, "vkCmdEndRendering")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdEndRendering;
    }
    if (!strcmp(name, "vkCmdSetCullMode")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetCullMode;
    }
    if (!strcmp(name, "vkCmdSetFrontFace")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetFrontFace;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveTopology")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetPrimitiveTopology;
    }
    if (!strcmp(name, "vkCmdSetViewportWithCount")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetViewportWithCount;
    }
    if (!strcmp(name, "vkCmdSetScissorWithCount")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetScissorWithCount;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers2")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdBindVertexBuffers2;
    }
    if (!strcmp(name, "vkCmdSetDepthTestEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetDepthTestEnable;
    }
    if (!strcmp(name, "vkCmdSetDepthWriteEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetDepthWriteEnable;
    }
    if (!strcmp(name, "vkCmdSetDepthCompareOp")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetDepthCompareOp;
    }
    if (!strcmp(name, "vkCmdSetDepthBoundsTestEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetDepthBoundsTestEnable;
    }
    if (!strcmp(name, "vkCmdSetStencilTestEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetStencilTestEnable;
    }
    if (!strcmp(name, "vkCmdSetStencilOp")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetStencilOp;
    }
    if (!strcmp(name, "vkCmdSetRasterizerDiscardEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetRasterizerDiscardEnable;
    }
    if (!strcmp(name, "vkCmdSetDepthBiasEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetDepthBiasEnable;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveRestartEnable")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkCmdSetPrimitiveRestartEnable;
    }
    if (!strcmp(name, "vkGetDeviceBufferMemoryRequirements")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetDeviceBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetDeviceImageMemoryRequirements")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetDeviceImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetDeviceImageSparseMemoryRequirements")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetDeviceImageSparseMemoryRequirements;
    }
#endif
#ifdef VK_KHR_android_surface
    if (!strcmp(name, "vkCreateAndroidSurfaceKHR")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_android_surface");
        return hasExt ? (void*)entry_vkCreateAndroidSurfaceKHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFeatures2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_maintenance1
    if (!strcmp(name, "vkTrimCommandPoolKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkTrimCommandPoolKHR;
    }
#endif
#ifdef VK_KHR_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferPropertiesKHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_external_memory_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalBufferPropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_external_semaphore_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_fd
    if (!strcmp(name, "vkImportSemaphoreFdKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkImportSemaphoreFdKHR;
    }
    if (!strcmp(name, "vkGetSemaphoreFdKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetSemaphoreFdKHR;
    }
#endif
#ifdef VK_KHR_descriptor_update_template
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplateKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCreateDescriptorUpdateTemplateKHR;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplateKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkDestroyDescriptorUpdateTemplateKHR;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkUpdateDescriptorSetWithTemplateKHR;
    }
#endif
#ifdef VK_KHR_create_renderpass2
    if (!strcmp(name, "vkCreateRenderPass2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCreateRenderPass2KHR;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdBeginRenderPass2KHR;
    }
    if (!strcmp(name, "vkCmdNextSubpass2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdNextSubpass2KHR;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdEndRenderPass2KHR;
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFencePropertiesKHR")) {
        bool hasExt =
            resources->hasInstanceExtension(instance, "VK_KHR_external_fence_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalFencePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_fd
    if (!strcmp(name, "vkImportFenceFdKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkImportFenceFdKHR;
    }
    if (!strcmp(name, "vkGetFenceFdKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetFenceFdKHR;
    }
#endif
#ifdef VK_KHR_get_memory_requirements2
    if (!strcmp(name, "vkGetImageMemoryRequirements2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetImageMemoryRequirements2KHR;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetBufferMemoryRequirements2KHR;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetImageSparseMemoryRequirements2KHR;
    }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    if (!strcmp(name, "vkCreateSamplerYcbcrConversionKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCreateSamplerYcbcrConversionKHR;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversionKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkDestroySamplerYcbcrConversionKHR;
    }
#endif
#ifdef VK_KHR_bind_memory2
    if (!strcmp(name, "vkBindBufferMemory2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkBindBufferMemory2KHR;
    }
    if (!strcmp(name, "vkBindImageMemory2KHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkBindImageMemory2KHR;
    }
#endif
#ifdef VK_KHR_maintenance3
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupportKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetDescriptorSetLayoutSupportKHR;
    }
#endif
#ifdef VK_KHR_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetBufferDeviceAddressKHR;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddressKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetBufferOpaqueCaptureAddressKHR;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddressKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR;
    }
#endif
#ifdef VK_KHR_pipeline_executable_properties
    if (!strcmp(name, "vkGetPipelineExecutablePropertiesKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetPipelineExecutablePropertiesKHR;
    }
    if (!strcmp(name, "vkGetPipelineExecutableStatisticsKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetPipelineExecutableStatisticsKHR;
    }
    if (!strcmp(name, "vkGetPipelineExecutableInternalRepresentationsKHR")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetPipelineExecutableInternalRepresentationsKHR;
    }
#endif
#ifdef VK_ANDROID_native_buffer
    if (!strcmp(name, "vkGetSwapchainGrallocUsageANDROID")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetSwapchainGrallocUsageANDROID;
    }
    if (!strcmp(name, "vkAcquireImageANDROID")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkAcquireImageANDROID;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROID")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)entry_vkQueueSignalReleaseImageANDROID;
    }
    if (!strcmp(name, "vkGetSwapchainGrallocUsage2ANDROID")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetSwapchainGrallocUsage2ANDROID;
    }
#endif
#ifdef VK_EXT_transform_feedback
    if (!strcmp(name, "vkCmdBindTransformFeedbackBuffersEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdBindTransformFeedbackBuffersEXT;
    }
    if (!strcmp(name, "vkCmdBeginTransformFeedbackEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdBeginTransformFeedbackEXT;
    }
    if (!strcmp(name, "vkCmdEndTransformFeedbackEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdEndTransformFeedbackEXT;
    }
    if (!strcmp(name, "vkCmdBeginQueryIndexedEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdBeginQueryIndexedEXT;
    }
    if (!strcmp(name, "vkCmdEndQueryIndexedEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdEndQueryIndexedEXT;
    }
    if (!strcmp(name, "vkCmdDrawIndirectByteCountEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdDrawIndirectByteCountEXT;
    }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (!strcmp(name, "vkGetAndroidHardwareBufferPropertiesANDROID")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetAndroidHardwareBufferPropertiesANDROID;
    }
    if (!strcmp(name, "vkGetMemoryAndroidHardwareBufferANDROID")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkGetMemoryAndroidHardwareBufferANDROID;
    }
#endif
#ifdef VK_EXT_line_rasterization
    if (!strcmp(name, "vkCmdSetLineStippleEXT")) {
        // TODO(b/236246382): Check support for device extension;
        return (void*)dynCheck_entry_vkCmdSetLineStippleEXT;
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    if (!strcmp(name, "vkMapMemoryIntoAddressSpaceGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkMapMemoryIntoAddressSpaceGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateSizedGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE
                      : nullptr;
    }
    if (!strcmp(name, "vkBeginCommandBufferAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkBeginCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkEndCommandBufferAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkEndCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkResetCommandBufferAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkResetCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCommandBufferHostSyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCommandBufferHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateImageWithRequirementsGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkCreateImageWithRequirementsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateBufferWithRequirementsGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkCreateBufferWithRequirementsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryHostAddressInfoGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkGetMemoryHostAddressInfoGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkFreeMemorySyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkFreeMemorySyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueHostSyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueSubmitAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueSubmitAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueWaitIdleAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueWaitIdleAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueBindSparseAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueBindSparseAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayoutGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkGetLinearImageLayoutGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayout2GOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkGetLinearImageLayout2GOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueFlushCommandsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueCommitDescriptorSetUpdatesGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueCommitDescriptorSetUpdatesGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCollectDescriptorPoolIdsGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkCollectDescriptorPoolIdsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROIDAsyncGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsFromAuxMemoryGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueFlushCommandsFromAuxMemoryGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetBlobGOOGLE")) {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)dynCheck_entry_vkGetBlobGOOGLE : nullptr;
    }
#endif
    return nullptr;
}
void* goldfish_vulkan_get_device_proc_address(VkDevice device, const char* name) {
    auto resources = ResourceTracker::get();
    bool has1_1OrHigher = resources->getApiVersionFromDevice(device) >= VK_API_VERSION_1_1;
#ifdef VK_VERSION_1_0
    if (!strcmp(name, "vkCreateInstance")) {
        return (void*)entry_vkCreateInstance;
    }
    if (!strcmp(name, "vkDestroyInstance")) {
        return (void*)entry_vkDestroyInstance;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDevices")) {
        return (void*)entry_vkEnumeratePhysicalDevices;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures")) {
        return (void*)entry_vkGetPhysicalDeviceFeatures;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceImageFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties")) {
        return (void*)entry_vkGetPhysicalDeviceProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties")) {
        return (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties")) {
        return (void*)entry_vkGetPhysicalDeviceMemoryProperties;
    }
    if (!strcmp(name, "vkGetInstanceProcAddr")) {
        return (void*)entry_vkGetInstanceProcAddr;
    }
    if (!strcmp(name, "vkGetDeviceProcAddr")) {
        return (void*)entry_vkGetDeviceProcAddr;
    }
    if (!strcmp(name, "vkCreateDevice")) {
        return (void*)entry_vkCreateDevice;
    }
    if (!strcmp(name, "vkDestroyDevice")) {
        return (void*)entry_vkDestroyDevice;
    }
    if (!strcmp(name, "vkEnumerateInstanceExtensionProperties")) {
        return (void*)entry_vkEnumerateInstanceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceExtensionProperties")) {
        return (void*)entry_vkEnumerateDeviceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateInstanceLayerProperties")) {
        return (void*)entry_vkEnumerateInstanceLayerProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceLayerProperties")) {
        return (void*)entry_vkEnumerateDeviceLayerProperties;
    }
    if (!strcmp(name, "vkGetDeviceQueue")) {
        return (void*)entry_vkGetDeviceQueue;
    }
    if (!strcmp(name, "vkQueueSubmit")) {
        return (void*)entry_vkQueueSubmit;
    }
    if (!strcmp(name, "vkQueueWaitIdle")) {
        return (void*)entry_vkQueueWaitIdle;
    }
    if (!strcmp(name, "vkDeviceWaitIdle")) {
        return (void*)entry_vkDeviceWaitIdle;
    }
    if (!strcmp(name, "vkAllocateMemory")) {
        return (void*)entry_vkAllocateMemory;
    }
    if (!strcmp(name, "vkFreeMemory")) {
        return (void*)entry_vkFreeMemory;
    }
    if (!strcmp(name, "vkMapMemory")) {
        return (void*)entry_vkMapMemory;
    }
    if (!strcmp(name, "vkUnmapMemory")) {
        return (void*)entry_vkUnmapMemory;
    }
    if (!strcmp(name, "vkFlushMappedMemoryRanges")) {
        return (void*)entry_vkFlushMappedMemoryRanges;
    }
    if (!strcmp(name, "vkInvalidateMappedMemoryRanges")) {
        return (void*)entry_vkInvalidateMappedMemoryRanges;
    }
    if (!strcmp(name, "vkGetDeviceMemoryCommitment")) {
        return (void*)entry_vkGetDeviceMemoryCommitment;
    }
    if (!strcmp(name, "vkBindBufferMemory")) {
        return (void*)entry_vkBindBufferMemory;
    }
    if (!strcmp(name, "vkBindImageMemory")) {
        return (void*)entry_vkBindImageMemory;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements")) {
        return (void*)entry_vkGetBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements")) {
        return (void*)entry_vkGetImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements")) {
        return (void*)entry_vkGetImageSparseMemoryRequirements;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties")) {
        return (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties;
    }
    if (!strcmp(name, "vkQueueBindSparse")) {
        return (void*)entry_vkQueueBindSparse;
    }
    if (!strcmp(name, "vkCreateFence")) {
        return (void*)entry_vkCreateFence;
    }
    if (!strcmp(name, "vkDestroyFence")) {
        return (void*)entry_vkDestroyFence;
    }
    if (!strcmp(name, "vkResetFences")) {
        return (void*)entry_vkResetFences;
    }
    if (!strcmp(name, "vkGetFenceStatus")) {
        return (void*)entry_vkGetFenceStatus;
    }
    if (!strcmp(name, "vkWaitForFences")) {
        return (void*)entry_vkWaitForFences;
    }
    if (!strcmp(name, "vkCreateSemaphore")) {
        return (void*)entry_vkCreateSemaphore;
    }
    if (!strcmp(name, "vkDestroySemaphore")) {
        return (void*)entry_vkDestroySemaphore;
    }
    if (!strcmp(name, "vkCreateEvent")) {
        return (void*)entry_vkCreateEvent;
    }
    if (!strcmp(name, "vkDestroyEvent")) {
        return (void*)entry_vkDestroyEvent;
    }
    if (!strcmp(name, "vkGetEventStatus")) {
        return (void*)entry_vkGetEventStatus;
    }
    if (!strcmp(name, "vkSetEvent")) {
        return (void*)entry_vkSetEvent;
    }
    if (!strcmp(name, "vkResetEvent")) {
        return (void*)entry_vkResetEvent;
    }
    if (!strcmp(name, "vkCreateQueryPool")) {
        return (void*)entry_vkCreateQueryPool;
    }
    if (!strcmp(name, "vkDestroyQueryPool")) {
        return (void*)entry_vkDestroyQueryPool;
    }
    if (!strcmp(name, "vkGetQueryPoolResults")) {
        return (void*)entry_vkGetQueryPoolResults;
    }
    if (!strcmp(name, "vkCreateBuffer")) {
        return (void*)entry_vkCreateBuffer;
    }
    if (!strcmp(name, "vkDestroyBuffer")) {
        return (void*)entry_vkDestroyBuffer;
    }
    if (!strcmp(name, "vkCreateBufferView")) {
        return (void*)entry_vkCreateBufferView;
    }
    if (!strcmp(name, "vkDestroyBufferView")) {
        return (void*)entry_vkDestroyBufferView;
    }
    if (!strcmp(name, "vkCreateImage")) {
        return (void*)entry_vkCreateImage;
    }
    if (!strcmp(name, "vkDestroyImage")) {
        return (void*)entry_vkDestroyImage;
    }
    if (!strcmp(name, "vkGetImageSubresourceLayout")) {
        return (void*)entry_vkGetImageSubresourceLayout;
    }
    if (!strcmp(name, "vkCreateImageView")) {
        return (void*)entry_vkCreateImageView;
    }
    if (!strcmp(name, "vkDestroyImageView")) {
        return (void*)entry_vkDestroyImageView;
    }
    if (!strcmp(name, "vkCreateShaderModule")) {
        return (void*)entry_vkCreateShaderModule;
    }
    if (!strcmp(name, "vkDestroyShaderModule")) {
        return (void*)entry_vkDestroyShaderModule;
    }
    if (!strcmp(name, "vkCreatePipelineCache")) {
        return (void*)entry_vkCreatePipelineCache;
    }
    if (!strcmp(name, "vkDestroyPipelineCache")) {
        return (void*)entry_vkDestroyPipelineCache;
    }
    if (!strcmp(name, "vkGetPipelineCacheData")) {
        return (void*)entry_vkGetPipelineCacheData;
    }
    if (!strcmp(name, "vkMergePipelineCaches")) {
        return (void*)entry_vkMergePipelineCaches;
    }
    if (!strcmp(name, "vkCreateGraphicsPipelines")) {
        return (void*)entry_vkCreateGraphicsPipelines;
    }
    if (!strcmp(name, "vkCreateComputePipelines")) {
        return (void*)entry_vkCreateComputePipelines;
    }
    if (!strcmp(name, "vkDestroyPipeline")) {
        return (void*)entry_vkDestroyPipeline;
    }
    if (!strcmp(name, "vkCreatePipelineLayout")) {
        return (void*)entry_vkCreatePipelineLayout;
    }
    if (!strcmp(name, "vkDestroyPipelineLayout")) {
        return (void*)entry_vkDestroyPipelineLayout;
    }
    if (!strcmp(name, "vkCreateSampler")) {
        return (void*)entry_vkCreateSampler;
    }
    if (!strcmp(name, "vkDestroySampler")) {
        return (void*)entry_vkDestroySampler;
    }
    if (!strcmp(name, "vkCreateDescriptorSetLayout")) {
        return (void*)entry_vkCreateDescriptorSetLayout;
    }
    if (!strcmp(name, "vkDestroyDescriptorSetLayout")) {
        return (void*)entry_vkDestroyDescriptorSetLayout;
    }
    if (!strcmp(name, "vkCreateDescriptorPool")) {
        return (void*)entry_vkCreateDescriptorPool;
    }
    if (!strcmp(name, "vkDestroyDescriptorPool")) {
        return (void*)entry_vkDestroyDescriptorPool;
    }
    if (!strcmp(name, "vkResetDescriptorPool")) {
        return (void*)entry_vkResetDescriptorPool;
    }
    if (!strcmp(name, "vkAllocateDescriptorSets")) {
        return (void*)entry_vkAllocateDescriptorSets;
    }
    if (!strcmp(name, "vkFreeDescriptorSets")) {
        return (void*)entry_vkFreeDescriptorSets;
    }
    if (!strcmp(name, "vkUpdateDescriptorSets")) {
        return (void*)entry_vkUpdateDescriptorSets;
    }
    if (!strcmp(name, "vkCreateFramebuffer")) {
        return (void*)entry_vkCreateFramebuffer;
    }
    if (!strcmp(name, "vkDestroyFramebuffer")) {
        return (void*)entry_vkDestroyFramebuffer;
    }
    if (!strcmp(name, "vkCreateRenderPass")) {
        return (void*)entry_vkCreateRenderPass;
    }
    if (!strcmp(name, "vkDestroyRenderPass")) {
        return (void*)entry_vkDestroyRenderPass;
    }
    if (!strcmp(name, "vkGetRenderAreaGranularity")) {
        return (void*)entry_vkGetRenderAreaGranularity;
    }
    if (!strcmp(name, "vkCreateCommandPool")) {
        return (void*)entry_vkCreateCommandPool;
    }
    if (!strcmp(name, "vkDestroyCommandPool")) {
        return (void*)entry_vkDestroyCommandPool;
    }
    if (!strcmp(name, "vkResetCommandPool")) {
        return (void*)entry_vkResetCommandPool;
    }
    if (!strcmp(name, "vkAllocateCommandBuffers")) {
        return (void*)entry_vkAllocateCommandBuffers;
    }
    if (!strcmp(name, "vkFreeCommandBuffers")) {
        return (void*)entry_vkFreeCommandBuffers;
    }
    if (!strcmp(name, "vkBeginCommandBuffer")) {
        return (void*)entry_vkBeginCommandBuffer;
    }
    if (!strcmp(name, "vkEndCommandBuffer")) {
        return (void*)entry_vkEndCommandBuffer;
    }
    if (!strcmp(name, "vkResetCommandBuffer")) {
        return (void*)entry_vkResetCommandBuffer;
    }
    if (!strcmp(name, "vkCmdBindPipeline")) {
        return (void*)entry_vkCmdBindPipeline;
    }
    if (!strcmp(name, "vkCmdSetViewport")) {
        return (void*)entry_vkCmdSetViewport;
    }
    if (!strcmp(name, "vkCmdSetScissor")) {
        return (void*)entry_vkCmdSetScissor;
    }
    if (!strcmp(name, "vkCmdSetLineWidth")) {
        return (void*)entry_vkCmdSetLineWidth;
    }
    if (!strcmp(name, "vkCmdSetDepthBias")) {
        return (void*)entry_vkCmdSetDepthBias;
    }
    if (!strcmp(name, "vkCmdSetBlendConstants")) {
        return (void*)entry_vkCmdSetBlendConstants;
    }
    if (!strcmp(name, "vkCmdSetDepthBounds")) {
        return (void*)entry_vkCmdSetDepthBounds;
    }
    if (!strcmp(name, "vkCmdSetStencilCompareMask")) {
        return (void*)entry_vkCmdSetStencilCompareMask;
    }
    if (!strcmp(name, "vkCmdSetStencilWriteMask")) {
        return (void*)entry_vkCmdSetStencilWriteMask;
    }
    if (!strcmp(name, "vkCmdSetStencilReference")) {
        return (void*)entry_vkCmdSetStencilReference;
    }
    if (!strcmp(name, "vkCmdBindDescriptorSets")) {
        return (void*)entry_vkCmdBindDescriptorSets;
    }
    if (!strcmp(name, "vkCmdBindIndexBuffer")) {
        return (void*)entry_vkCmdBindIndexBuffer;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers")) {
        return (void*)entry_vkCmdBindVertexBuffers;
    }
    if (!strcmp(name, "vkCmdDraw")) {
        return (void*)entry_vkCmdDraw;
    }
    if (!strcmp(name, "vkCmdDrawIndexed")) {
        return (void*)entry_vkCmdDrawIndexed;
    }
    if (!strcmp(name, "vkCmdDrawIndirect")) {
        return (void*)entry_vkCmdDrawIndirect;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirect")) {
        return (void*)entry_vkCmdDrawIndexedIndirect;
    }
    if (!strcmp(name, "vkCmdDispatch")) {
        return (void*)entry_vkCmdDispatch;
    }
    if (!strcmp(name, "vkCmdDispatchIndirect")) {
        return (void*)entry_vkCmdDispatchIndirect;
    }
    if (!strcmp(name, "vkCmdCopyBuffer")) {
        return (void*)entry_vkCmdCopyBuffer;
    }
    if (!strcmp(name, "vkCmdCopyImage")) {
        return (void*)entry_vkCmdCopyImage;
    }
    if (!strcmp(name, "vkCmdBlitImage")) {
        return (void*)entry_vkCmdBlitImage;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage")) {
        return (void*)entry_vkCmdCopyBufferToImage;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer")) {
        return (void*)entry_vkCmdCopyImageToBuffer;
    }
    if (!strcmp(name, "vkCmdUpdateBuffer")) {
        return (void*)entry_vkCmdUpdateBuffer;
    }
    if (!strcmp(name, "vkCmdFillBuffer")) {
        return (void*)entry_vkCmdFillBuffer;
    }
    if (!strcmp(name, "vkCmdClearColorImage")) {
        return (void*)entry_vkCmdClearColorImage;
    }
    if (!strcmp(name, "vkCmdClearDepthStencilImage")) {
        return (void*)entry_vkCmdClearDepthStencilImage;
    }
    if (!strcmp(name, "vkCmdClearAttachments")) {
        return (void*)entry_vkCmdClearAttachments;
    }
    if (!strcmp(name, "vkCmdResolveImage")) {
        return (void*)entry_vkCmdResolveImage;
    }
    if (!strcmp(name, "vkCmdSetEvent")) {
        return (void*)entry_vkCmdSetEvent;
    }
    if (!strcmp(name, "vkCmdResetEvent")) {
        return (void*)entry_vkCmdResetEvent;
    }
    if (!strcmp(name, "vkCmdWaitEvents")) {
        return (void*)entry_vkCmdWaitEvents;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier")) {
        return (void*)entry_vkCmdPipelineBarrier;
    }
    if (!strcmp(name, "vkCmdBeginQuery")) {
        return (void*)entry_vkCmdBeginQuery;
    }
    if (!strcmp(name, "vkCmdEndQuery")) {
        return (void*)entry_vkCmdEndQuery;
    }
    if (!strcmp(name, "vkCmdResetQueryPool")) {
        return (void*)entry_vkCmdResetQueryPool;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp")) {
        return (void*)entry_vkCmdWriteTimestamp;
    }
    if (!strcmp(name, "vkCmdCopyQueryPoolResults")) {
        return (void*)entry_vkCmdCopyQueryPoolResults;
    }
    if (!strcmp(name, "vkCmdPushConstants")) {
        return (void*)entry_vkCmdPushConstants;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass")) {
        return (void*)entry_vkCmdBeginRenderPass;
    }
    if (!strcmp(name, "vkCmdNextSubpass")) {
        return (void*)entry_vkCmdNextSubpass;
    }
    if (!strcmp(name, "vkCmdEndRenderPass")) {
        return (void*)entry_vkCmdEndRenderPass;
    }
    if (!strcmp(name, "vkCmdExecuteCommands")) {
        return (void*)entry_vkCmdExecuteCommands;
    }
#endif
#ifdef VK_VERSION_1_1
    if (!strcmp(name, "vkEnumerateInstanceVersion")) {
        return has1_1OrHigher ? (void*)entry_vkEnumerateInstanceVersion : nullptr;
    }
    if (!strcmp(name, "vkBindBufferMemory2")) {
        return has1_1OrHigher ? (void*)entry_vkBindBufferMemory2 : nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2")) {
        return has1_1OrHigher ? (void*)entry_vkBindImageMemory2 : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeatures")) {
        return has1_1OrHigher ? (void*)entry_vkGetDeviceGroupPeerMemoryFeatures : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDeviceMask")) {
        return has1_1OrHigher ? (void*)entry_vkCmdSetDeviceMask : nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBase")) {
        return has1_1OrHigher ? (void*)entry_vkCmdDispatchBase : nullptr;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroups")) {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements2")) {
        return has1_1OrHigher ? (void*)entry_vkGetImageMemoryRequirements2 : nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2")) {
        return has1_1OrHigher ? (void*)entry_vkGetBufferMemoryRequirements2 : nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2")) {
        return has1_1OrHigher ? (void*)entry_vkGetImageSparseMemoryRequirements2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFeatures2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2
                              : nullptr;
    }
    if (!strcmp(name, "vkTrimCommandPool")) {
        return has1_1OrHigher ? (void*)entry_vkTrimCommandPool : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceQueue2")) {
        return has1_1OrHigher ? (void*)entry_vkGetDeviceQueue2 : nullptr;
    }
    if (!strcmp(name, "vkCreateSamplerYcbcrConversion")) {
        return has1_1OrHigher ? (void*)entry_vkCreateSamplerYcbcrConversion : nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversion")) {
        return has1_1OrHigher ? (void*)entry_vkDestroySamplerYcbcrConversion : nullptr;
    }
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplate")) {
        return has1_1OrHigher ? (void*)entry_vkCreateDescriptorUpdateTemplate : nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplate")) {
        return has1_1OrHigher ? (void*)entry_vkDestroyDescriptorUpdateTemplate : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplate")) {
        return has1_1OrHigher ? (void*)entry_vkUpdateDescriptorSetWithTemplate : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferProperties")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalBufferProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFenceProperties")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalFenceProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphoreProperties")) {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalSemaphoreProperties
                              : nullptr;
    }
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupport")) {
        return has1_1OrHigher ? (void*)entry_vkGetDescriptorSetLayoutSupport : nullptr;
    }
#endif
#ifdef VK_VERSION_1_2
    if (!strcmp(name, "vkCmdDrawIndirectCount")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCount")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCreateRenderPass2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCreateRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdBeginRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdNextSubpass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdEndRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkResetQueryPool")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkResetQueryPool : nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreCounterValue")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetSemaphoreCounterValue : nullptr;
    }
    if (!strcmp(name, "vkWaitSemaphores")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkWaitSemaphores : nullptr;
    }
    if (!strcmp(name, "vkSignalSemaphore")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkSignalSemaphore : nullptr;
    }
    if (!strcmp(name, "vkGetBufferDeviceAddress")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetBufferDeviceAddress : nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddress")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetBufferOpaqueCaptureAddress : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddress")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetDeviceMemoryOpaqueCaptureAddress : nullptr;
    }
#endif
#ifdef VK_VERSION_1_3
    if (!strcmp(name, "vkGetPhysicalDeviceToolProperties")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceToolProperties : nullptr;
    }
    if (!strcmp(name, "vkCreatePrivateDataSlot")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCreatePrivateDataSlot : nullptr;
    }
    if (!strcmp(name, "vkDestroyPrivateDataSlot")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkDestroyPrivateDataSlot : nullptr;
    }
    if (!strcmp(name, "vkSetPrivateData")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkSetPrivateData : nullptr;
    }
    if (!strcmp(name, "vkGetPrivateData")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkGetPrivateData : nullptr;
    }
    if (!strcmp(name, "vkCmdSetEvent2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetEvent2 : nullptr;
    }
    if (!strcmp(name, "vkCmdResetEvent2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdResetEvent2 : nullptr;
    }
    if (!strcmp(name, "vkCmdWaitEvents2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdWaitEvents2 : nullptr;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdPipelineBarrier2 : nullptr;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdWriteTimestamp2 : nullptr;
    }
    if (!strcmp(name, "vkQueueSubmit2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkQueueSubmit2 : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBuffer2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdCopyBuffer2 : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImage2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdCopyImage2 : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdCopyBufferToImage2 : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdCopyImageToBuffer2 : nullptr;
    }
    if (!strcmp(name, "vkCmdBlitImage2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdBlitImage2 : nullptr;
    }
    if (!strcmp(name, "vkCmdResolveImage2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdResolveImage2 : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRendering")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdBeginRendering : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRendering")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdEndRendering : nullptr;
    }
    if (!strcmp(name, "vkCmdSetCullMode")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetCullMode : nullptr;
    }
    if (!strcmp(name, "vkCmdSetFrontFace")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetFrontFace : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveTopology")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetPrimitiveTopology : nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportWithCount")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetViewportWithCount : nullptr;
    }
    if (!strcmp(name, "vkCmdSetScissorWithCount")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetScissorWithCount : nullptr;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers2")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdBindVertexBuffers2 : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthTestEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetDepthTestEnable : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthWriteEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetDepthWriteEnable : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthCompareOp")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetDepthCompareOp : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBoundsTestEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetDepthBoundsTestEnable : nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilTestEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetStencilTestEnable : nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilOp")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetStencilOp : nullptr;
    }
    if (!strcmp(name, "vkCmdSetRasterizerDiscardEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetRasterizerDiscardEnable : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBiasEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetDepthBiasEnable : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveRestartEnable")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkCmdSetPrimitiveRestartEnable : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceBufferMemoryRequirements")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkGetDeviceBufferMemoryRequirements : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceImageMemoryRequirements")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkGetDeviceImageMemoryRequirements : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceImageSparseMemoryRequirements")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_3");
        return hasExt ? (void*)entry_vkGetDeviceImageSparseMemoryRequirements : nullptr;
    }
#endif
#ifdef VK_KHR_android_surface
    if (!strcmp(name, "vkCreateAndroidSurfaceKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_android_surface");
        return hasExt ? (void*)entry_vkCreateAndroidSurfaceKHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFeatures2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_maintenance1
    if (!strcmp(name, "vkTrimCommandPoolKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_maintenance1");
        return hasExt ? (void*)entry_vkTrimCommandPoolKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferPropertiesKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_memory_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalBufferPropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_fd
    if (!strcmp(name, "vkImportSemaphoreFdKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd");
        return hasExt ? (void*)entry_vkImportSemaphoreFdKHR : nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreFdKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd");
        return hasExt ? (void*)entry_vkGetSemaphoreFdKHR : nullptr;
    }
#endif
#ifdef VK_KHR_descriptor_update_template
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplateKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template");
        return hasExt ? (void*)entry_vkCreateDescriptorUpdateTemplateKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplateKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template");
        return hasExt ? (void*)entry_vkDestroyDescriptorUpdateTemplateKHR : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template");
        return hasExt ? (void*)entry_vkUpdateDescriptorSetWithTemplateKHR : nullptr;
    }
#endif
#ifdef VK_KHR_create_renderpass2
    if (!strcmp(name, "vkCreateRenderPass2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCreateRenderPass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdBeginRenderPass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdNextSubpass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdEndRenderPass2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFencePropertiesKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalFencePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_fd
    if (!strcmp(name, "vkImportFenceFdKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd");
        return hasExt ? (void*)entry_vkImportFenceFdKHR : nullptr;
    }
    if (!strcmp(name, "vkGetFenceFdKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd");
        return hasExt ? (void*)entry_vkGetFenceFdKHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_memory_requirements2
    if (!strcmp(name, "vkGetImageMemoryRequirements2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2");
        return hasExt ? (void*)entry_vkGetImageMemoryRequirements2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2");
        return hasExt ? (void*)entry_vkGetBufferMemoryRequirements2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2");
        return hasExt ? (void*)entry_vkGetImageSparseMemoryRequirements2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    if (!strcmp(name, "vkCreateSamplerYcbcrConversionKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion");
        return hasExt ? (void*)entry_vkCreateSamplerYcbcrConversionKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversionKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion");
        return hasExt ? (void*)entry_vkDestroySamplerYcbcrConversionKHR : nullptr;
    }
#endif
#ifdef VK_KHR_bind_memory2
    if (!strcmp(name, "vkBindBufferMemory2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_bind_memory2");
        return hasExt ? (void*)entry_vkBindBufferMemory2KHR : nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2KHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_bind_memory2");
        return hasExt ? (void*)entry_vkBindImageMemory2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_maintenance3
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupportKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_maintenance3");
        return hasExt ? (void*)entry_vkGetDescriptorSetLayoutSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address");
        return hasExt ? (void*)entry_vkGetBufferDeviceAddressKHR : nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddressKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address");
        return hasExt ? (void*)entry_vkGetBufferOpaqueCaptureAddressKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddressKHR")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address");
        return hasExt ? (void*)entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR : nullptr;
    }
#endif
#ifdef VK_KHR_pipeline_executable_properties
    if (!strcmp(name, "vkGetPipelineExecutablePropertiesKHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties");
        return hasExt ? (void*)entry_vkGetPipelineExecutablePropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableStatisticsKHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties");
        return hasExt ? (void*)entry_vkGetPipelineExecutableStatisticsKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableInternalRepresentationsKHR")) {
        bool hasExt =
            resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties");
        return hasExt ? (void*)entry_vkGetPipelineExecutableInternalRepresentationsKHR : nullptr;
    }
#endif
#ifdef VK_ANDROID_native_buffer
    if (!strcmp(name, "vkGetSwapchainGrallocUsageANDROID")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkGetSwapchainGrallocUsageANDROID : nullptr;
    }
    if (!strcmp(name, "vkAcquireImageANDROID")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkAcquireImageANDROID : nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROID")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkQueueSignalReleaseImageANDROID : nullptr;
    }
    if (!strcmp(name, "vkGetSwapchainGrallocUsage2ANDROID")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkGetSwapchainGrallocUsage2ANDROID : nullptr;
    }
#endif
#ifdef VK_EXT_transform_feedback
    if (!strcmp(name, "vkCmdBindTransformFeedbackBuffersEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBindTransformFeedbackBuffersEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginTransformFeedbackEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBeginTransformFeedbackEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndTransformFeedbackEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdEndTransformFeedbackEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginQueryIndexedEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBeginQueryIndexedEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndQueryIndexedEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdEndQueryIndexedEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndirectByteCountEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdDrawIndirectByteCountEXT : nullptr;
    }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (!strcmp(name, "vkGetAndroidHardwareBufferPropertiesANDROID")) {
        bool hasExt = resources->hasDeviceExtension(
            device, "VK_ANDROID_external_memory_android_hardware_buffer");
        return hasExt ? (void*)entry_vkGetAndroidHardwareBufferPropertiesANDROID : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryAndroidHardwareBufferANDROID")) {
        bool hasExt = resources->hasDeviceExtension(
            device, "VK_ANDROID_external_memory_android_hardware_buffer");
        return hasExt ? (void*)entry_vkGetMemoryAndroidHardwareBufferANDROID : nullptr;
    }
#endif
#ifdef VK_EXT_line_rasterization
    if (!strcmp(name, "vkCmdSetLineStippleEXT")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_line_rasterization");
        return hasExt ? (void*)entry_vkCmdSetLineStippleEXT : nullptr;
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    if (!strcmp(name, "vkMapMemoryIntoAddressSpaceGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkMapMemoryIntoAddressSpaceGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateSizedGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkBeginCommandBufferAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkBeginCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkEndCommandBufferAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkEndCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkResetCommandBufferAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkResetCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCommandBufferHostSyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCommandBufferHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateImageWithRequirementsGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCreateImageWithRequirementsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateBufferWithRequirementsGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCreateBufferWithRequirementsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryHostAddressInfoGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkGetMemoryHostAddressInfoGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkFreeMemorySyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkFreeMemorySyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueHostSyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueSubmitAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueSubmitAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueWaitIdleAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueWaitIdleAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueBindSparseAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueBindSparseAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayoutGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkGetLinearImageLayoutGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayout2GOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkGetLinearImageLayout2GOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueFlushCommandsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueCommitDescriptorSetUpdatesGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueCommitDescriptorSetUpdatesGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCollectDescriptorPoolIdsGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCollectDescriptorPoolIdsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROIDAsyncGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsFromAuxMemoryGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueFlushCommandsFromAuxMemoryGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetBlobGOOGLE")) {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkGetBlobGOOGLE : nullptr;
    }
#endif
    return nullptr;
}

}  // namespace vk
}  // namespace gfxstream
