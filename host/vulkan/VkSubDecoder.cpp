// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkSubDecoder
//
// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
//
// Please do not modify directly;
// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
// VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
//
// python3 $VULKAN_REGISTRY_SCRIPTS_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o
// $CEREAL_OUTPUT_DIR
//
#define MAX_STACK_ITEMS 16
#define MAX_PACKET_LENGTH (400 * 1024 * 1024)  // 400MB
size_t subDecode(VulkanMemReadingStream* readStream, VulkanDispatch* vk, void* boxed_dispatchHandle,
                 void* dispatchHandle, VkDeviceSize dataSize, const void* pData,
                 const VkDecoderContext& context) {
    auto& metricsLogger = *context.metricsLogger;
    uint32_t count = 0;
    unsigned char* buf = (unsigned char*)pData;
    android::base::BumpPool* pool = readStream->pool();
    unsigned char* ptr = (unsigned char*)pData;
    const unsigned char* const end = (const unsigned char*)buf + dataSize;
    VkDecoderGlobalState* globalstate = VkDecoderGlobalState::get();
    while (end - ptr >= 8) {
        uint32_t opcode = *(uint32_t*)ptr;
        uint32_t packetLen = *(uint32_t*)(ptr + 4);

        // packetLen should be at least 8 (op code and packet length) and should not be excessively
        // large
        if (packetLen < 8 || packetLen > MAX_PACKET_LENGTH) {
            WARN("Bad packet length %d detected, subdecode may fail", packetLen);
            metricsLogger.logMetricEvent(MetricEventBadPacketLength{.len = packetLen});
        }

        if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        readStream->setBuf((uint8_t*)(ptr + 8));
        uint8_t* readStreamPtr = readStream->getBuf();
        uint8_t** readStreamPtrPtr = &readStreamPtr;
        switch (opcode) {
#ifdef VK_VERSION_1_0
            case OP_vkBeginCommandBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkBeginCommandBuffer");
                const VkCommandBufferBeginInfo* pBeginInfo;
                VkCommandBufferBeginInfo stack_pBeginInfo[1];
                pBeginInfo = (VkCommandBufferBeginInfo*)stack_pBeginInfo;
                reservedunmarshal_VkCommandBufferBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkCommandBufferBeginInfo*)(pBeginInfo),
                                                           readStreamPtrPtr);
                if (pBeginInfo) {
                    transform_tohost_VkCommandBufferBeginInfo(
                        globalstate, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
                vkBeginCommandBuffer_VkResult_return = this->on_vkBeginCommandBuffer(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), pBeginInfo, context);
                if ((vkBeginCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                    this->on_DeviceLost();
                this->on_CheckOutOfMemory(vkBeginCommandBuffer_VkResult_return, opcode, context);
                break;
            }
            case OP_vkEndCommandBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkEndCommandBuffer");
                VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
                vkEndCommandBuffer_VkResult_return = this->on_vkEndCommandBuffer(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), context);
                if ((vkEndCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                    this->on_DeviceLost();
                this->on_CheckOutOfMemory(vkEndCommandBuffer_VkResult_return, opcode, context);
                break;
            }
            case OP_vkResetCommandBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkResetCommandBuffer");
                VkCommandBufferResetFlags flags;
                memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr,
                       sizeof(VkCommandBufferResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
                VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
                vkResetCommandBuffer_VkResult_return = this->on_vkResetCommandBuffer(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), flags);
                if ((vkResetCommandBuffer_VkResult_return) == VK_ERROR_DEVICE_LOST)
                    this->on_DeviceLost();
                this->on_CheckOutOfMemory(vkResetCommandBuffer_VkResult_return, opcode, context);
                break;
            }
            case OP_vkCmdBindPipeline: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindPipeline");
                VkPipelineBindPoint pipelineBindPoint;
                VkPipeline pipeline;
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr,
                       sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipeline*)&pipeline = (VkPipeline)unbox_VkPipeline((VkPipeline)(*&cgen_var_0));
                this->on_vkCmdBindPipeline(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                           pipelineBindPoint, pipeline);
                break;
            }
            case OP_vkCmdSetViewport: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetViewport");
                uint32_t firstViewport;
                uint32_t viewportCount;
                const VkViewport* pViewports;
                VkViewport stack_pViewports[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstViewport, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((viewportCount)) <= MAX_STACK_ITEMS) {
                    pViewports = (VkViewport*)stack_pViewports;
                } else {
                    readStream->alloc((void**)&pViewports,
                                      ((viewportCount)) * sizeof(const VkViewport));
                }
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i) {
                    reservedunmarshal_VkViewport(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                 (VkViewport*)(pViewports + i), readStreamPtrPtr);
                }
                if (pViewports) {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i) {
                        transform_tohost_VkViewport(globalstate, (VkViewport*)(pViewports + i));
                    }
                }
                vk->vkCmdSetViewport((VkCommandBuffer)dispatchHandle, firstViewport, viewportCount,
                                     pViewports);
                break;
            }
            case OP_vkCmdSetScissor: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetScissor");
                uint32_t firstScissor;
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                VkRect2D stack_pScissors[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstScissor, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&scissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((scissorCount)) <= MAX_STACK_ITEMS) {
                    pScissors = (VkRect2D*)stack_pScissors;
                } else {
                    readStream->alloc((void**)&pScissors,
                                      ((scissorCount)) * sizeof(const VkRect2D));
                }
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i) {
                    reservedunmarshal_VkRect2D(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkRect2D*)(pScissors + i), readStreamPtrPtr);
                }
                if (pScissors) {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i) {
                        transform_tohost_VkRect2D(globalstate, (VkRect2D*)(pScissors + i));
                    }
                }
                vk->vkCmdSetScissor((VkCommandBuffer)dispatchHandle, firstScissor, scissorCount,
                                    pScissors);
                break;
            }
            case OP_vkCmdSetLineWidth: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetLineWidth");
                float lineWidth;
                memcpy((float*)&lineWidth, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                vk->vkCmdSetLineWidth((VkCommandBuffer)dispatchHandle, lineWidth);
                break;
            }
            case OP_vkCmdSetDepthBias: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthBias");
                float depthBiasConstantFactor;
                float depthBiasClamp;
                float depthBiasSlopeFactor;
                memcpy((float*)&depthBiasConstantFactor, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&depthBiasClamp, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&depthBiasSlopeFactor, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                vk->vkCmdSetDepthBias((VkCommandBuffer)dispatchHandle, depthBiasConstantFactor,
                                      depthBiasClamp, depthBiasSlopeFactor);
                break;
            }
            case OP_vkCmdSetBlendConstants: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetBlendConstants");
                float blendConstants[4];
                memcpy((float*)blendConstants, *readStreamPtrPtr, 4 * sizeof(const float));
                *readStreamPtrPtr += 4 * sizeof(const float);
                vk->vkCmdSetBlendConstants((VkCommandBuffer)dispatchHandle, blendConstants);
                break;
            }
            case OP_vkCmdSetDepthBounds: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthBounds");
                float minDepthBounds;
                float maxDepthBounds;
                memcpy((float*)&minDepthBounds, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                memcpy((float*)&maxDepthBounds, *readStreamPtrPtr, sizeof(float));
                *readStreamPtrPtr += sizeof(float);
                vk->vkCmdSetDepthBounds((VkCommandBuffer)dispatchHandle, minDepthBounds,
                                        maxDepthBounds);
                break;
            }
            case OP_vkCmdSetStencilCompareMask: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilCompareMask");
                VkStencilFaceFlags faceMask;
                uint32_t compareMask;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr,
                       sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&compareMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdSetStencilCompareMask((VkCommandBuffer)dispatchHandle, faceMask,
                                               compareMask);
                break;
            }
            case OP_vkCmdSetStencilWriteMask: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilWriteMask");
                VkStencilFaceFlags faceMask;
                uint32_t writeMask;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr,
                       sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&writeMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdSetStencilWriteMask((VkCommandBuffer)dispatchHandle, faceMask, writeMask);
                break;
            }
            case OP_vkCmdSetStencilReference: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilReference");
                VkStencilFaceFlags faceMask;
                uint32_t reference;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr,
                       sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((uint32_t*)&reference, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdSetStencilReference((VkCommandBuffer)dispatchHandle, faceMask, reference);
                break;
            }
            case OP_vkCmdBindDescriptorSets: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindDescriptorSets");
                VkPipelineBindPoint pipelineBindPoint;
                VkPipelineLayout layout;
                uint32_t firstSet;
                uint32_t descriptorSetCount;
                const VkDescriptorSet* pDescriptorSets;
                VkDescriptorSet stack_pDescriptorSets[MAX_STACK_ITEMS];
                uint32_t dynamicOffsetCount;
                const uint32_t* pDynamicOffsets;
                uint32_t stack_pDynamicOffsets[MAX_STACK_ITEMS];
                memcpy((VkPipelineBindPoint*)&pipelineBindPoint, *readStreamPtrPtr,
                       sizeof(VkPipelineBindPoint));
                *readStreamPtrPtr += sizeof(VkPipelineBindPoint);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout =
                    (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
                memcpy((uint32_t*)&firstSet, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&descriptorSetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((descriptorSetCount)) <= MAX_STACK_ITEMS) {
                    pDescriptorSets = (VkDescriptorSet*)stack_pDescriptorSets;
                } else {
                    readStream->alloc((void**)&pDescriptorSets,
                                      ((descriptorSetCount)) * sizeof(const VkDescriptorSet));
                }
                if (((descriptorSetCount))) {
                    uint8_t* cgen_var_1_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((descriptorSetCount));
                    for (uint32_t k = 0; k < ((descriptorSetCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_1_ptr + k * 8, sizeof(uint64_t));
                        *(((VkDescriptorSet*)pDescriptorSets) + k) =
                            tmpval ? (VkDescriptorSet)unbox_VkDescriptorSet((VkDescriptorSet)tmpval)
                                   : VK_NULL_HANDLE;
                    }
                }
                memcpy((uint32_t*)&dynamicOffsetCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((dynamicOffsetCount)) <= MAX_STACK_ITEMS) {
                    pDynamicOffsets = (uint32_t*)stack_pDynamicOffsets;
                } else {
                    readStream->alloc((void**)&pDynamicOffsets,
                                      ((dynamicOffsetCount)) * sizeof(const uint32_t));
                }
                memcpy((uint32_t*)pDynamicOffsets, *readStreamPtrPtr,
                       ((dynamicOffsetCount)) * sizeof(const uint32_t));
                *readStreamPtrPtr += ((dynamicOffsetCount)) * sizeof(const uint32_t);
                this->on_vkCmdBindDescriptorSets(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                 pipelineBindPoint, layout, firstSet,
                                                 descriptorSetCount, pDescriptorSets,
                                                 dynamicOffsetCount, pDynamicOffsets);
                break;
            }
            case OP_vkCmdBindIndexBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindIndexBuffer");
                VkBuffer buffer;
                VkDeviceSize offset;
                VkIndexType indexType;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkIndexType*)&indexType, *readStreamPtrPtr, sizeof(VkIndexType));
                *readStreamPtrPtr += sizeof(VkIndexType);
                vk->vkCmdBindIndexBuffer((VkCommandBuffer)dispatchHandle, buffer, offset,
                                         indexType);
                break;
            }
            case OP_vkCmdBindVertexBuffers: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindVertexBuffers");
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                VkBuffer stack_pBuffers[MAX_STACK_ITEMS];
                const VkDeviceSize* pOffsets;
                VkDeviceSize stack_pOffsets[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((bindingCount)) <= MAX_STACK_ITEMS) {
                    pBuffers = (VkBuffer*)stack_pBuffers;
                } else {
                    readStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                }
                if (((bindingCount))) {
                    uint8_t* cgen_var_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((bindingCount));
                    for (uint32_t k = 0; k < ((bindingCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBuffer*)pBuffers) + k) =
                            tmpval ? (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval) : VK_NULL_HANDLE;
                    }
                }
                if (((bindingCount)) <= MAX_STACK_ITEMS) {
                    pOffsets = (VkDeviceSize*)stack_pOffsets;
                } else {
                    readStream->alloc((void**)&pOffsets,
                                      ((bindingCount)) * sizeof(const VkDeviceSize));
                }
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr,
                       ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                vk->vkCmdBindVertexBuffers((VkCommandBuffer)dispatchHandle, firstBinding,
                                           bindingCount, pBuffers, pOffsets);
                break;
            }
            case OP_vkCmdDraw: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY, "VkSubDecoder vkCmdDraw");
                uint32_t vertexCount;
                uint32_t instanceCount;
                uint32_t firstVertex;
                uint32_t firstInstance;
                memcpy((uint32_t*)&vertexCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstVertex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDraw((VkCommandBuffer)dispatchHandle, vertexCount, instanceCount,
                              firstVertex, firstInstance);
                break;
            }
            case OP_vkCmdDrawIndexed: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDrawIndexed");
                uint32_t indexCount;
                uint32_t instanceCount;
                uint32_t firstIndex;
                int32_t vertexOffset;
                uint32_t firstInstance;
                memcpy((uint32_t*)&indexCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstIndex, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((int32_t*)&vertexOffset, *readStreamPtrPtr, sizeof(int32_t));
                *readStreamPtrPtr += sizeof(int32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDrawIndexed((VkCommandBuffer)dispatchHandle, indexCount, instanceCount,
                                     firstIndex, vertexOffset, firstInstance);
                break;
            }
            case OP_vkCmdDrawIndirect: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDrawIndirect");
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDrawIndirect((VkCommandBuffer)dispatchHandle, buffer, offset, drawCount,
                                      stride);
                break;
            }
            case OP_vkCmdDrawIndexedIndirect: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDrawIndexedIndirect");
                VkBuffer buffer;
                VkDeviceSize offset;
                uint32_t drawCount;
                uint32_t stride;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&drawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDrawIndexedIndirect((VkCommandBuffer)dispatchHandle, buffer, offset,
                                             drawCount, stride);
                break;
            }
            case OP_vkCmdDispatch: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDispatch");
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDispatch((VkCommandBuffer)dispatchHandle, groupCountX, groupCountY,
                                  groupCountZ);
                break;
            }
            case OP_vkCmdDispatchIndirect: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDispatchIndirect");
                VkBuffer buffer;
                VkDeviceSize offset;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                vk->vkCmdDispatchIndirect((VkCommandBuffer)dispatchHandle, buffer, offset);
                break;
            }
            case OP_vkCmdCopyBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyBuffer");
                VkBuffer srcBuffer;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferCopy* pRegions;
                VkBufferCopy stack_pRegions[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((regionCount)) <= MAX_STACK_ITEMS) {
                    pRegions = (VkBufferCopy*)stack_pRegions;
                } else {
                    readStream->alloc((void**)&pRegions,
                                      ((regionCount)) * sizeof(const VkBufferCopy));
                }
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                    reservedunmarshal_VkBufferCopy(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkBufferCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions) {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                        transform_tohost_VkBufferCopy(globalstate, (VkBufferCopy*)(pRegions + i));
                    }
                }
                vk->vkCmdCopyBuffer((VkCommandBuffer)dispatchHandle, srcBuffer, dstBuffer,
                                    regionCount, pRegions);
                break;
            }
            case OP_vkCmdCopyImage: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyImage");
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageCopy* pRegions;
                VkImageCopy stack_pRegions[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((regionCount)) <= MAX_STACK_ITEMS) {
                    pRegions = (VkImageCopy*)stack_pRegions;
                } else {
                    readStream->alloc((void**)&pRegions,
                                      ((regionCount)) * sizeof(const VkImageCopy));
                }
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                    reservedunmarshal_VkImageCopy(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                  (VkImageCopy*)(pRegions + i), readStreamPtrPtr);
                }
                if (pRegions) {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                        transform_tohost_VkImageCopy(globalstate, (VkImageCopy*)(pRegions + i));
                    }
                }
                this->on_vkCmdCopyImage(pool, (VkCommandBuffer)(boxed_dispatchHandle), srcImage,
                                        srcImageLayout, dstImage, dstImageLayout, regionCount,
                                        pRegions);
                break;
            }
            case OP_vkCmdBlitImage: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBlitImage");
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageBlit* pRegions;
                VkImageBlit stack_pRegions[MAX_STACK_ITEMS];
                VkFilter filter;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((regionCount)) <= MAX_STACK_ITEMS) {
                    pRegions = (VkImageBlit*)stack_pRegions;
                } else {
                    readStream->alloc((void**)&pRegions,
                                      ((regionCount)) * sizeof(const VkImageBlit));
                }
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                    reservedunmarshal_VkImageBlit(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                  (VkImageBlit*)(pRegions + i), readStreamPtrPtr);
                }
                memcpy((VkFilter*)&filter, *readStreamPtrPtr, sizeof(VkFilter));
                *readStreamPtrPtr += sizeof(VkFilter);
                if (pRegions) {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                        transform_tohost_VkImageBlit(globalstate, (VkImageBlit*)(pRegions + i));
                    }
                }
                vk->vkCmdBlitImage((VkCommandBuffer)dispatchHandle, srcImage, srcImageLayout,
                                   dstImage, dstImageLayout, regionCount, pRegions, filter);
                break;
            }
            case OP_vkCmdCopyBufferToImage: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyBufferToImage");
                VkBuffer srcBuffer;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                VkBufferImageCopy stack_pRegions[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&srcBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((regionCount)) <= MAX_STACK_ITEMS) {
                    pRegions = (VkBufferImageCopy*)stack_pRegions;
                } else {
                    readStream->alloc((void**)&pRegions,
                                      ((regionCount)) * sizeof(const VkBufferImageCopy));
                }
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                    reservedunmarshal_VkBufferImageCopy(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkBufferImageCopy*)(pRegions + i),
                                                        readStreamPtrPtr);
                }
                if (pRegions) {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                        transform_tohost_VkBufferImageCopy(globalstate,
                                                           (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                this->on_vkCmdCopyBufferToImage(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                srcBuffer, dstImage, dstImageLayout, regionCount,
                                                pRegions, context);
                break;
            }
            case OP_vkCmdCopyImageToBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyImageToBuffer");
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkBuffer dstBuffer;
                uint32_t regionCount;
                const VkBufferImageCopy* pRegions;
                VkBufferImageCopy stack_pRegions[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((regionCount)) <= MAX_STACK_ITEMS) {
                    pRegions = (VkBufferImageCopy*)stack_pRegions;
                } else {
                    readStream->alloc((void**)&pRegions,
                                      ((regionCount)) * sizeof(const VkBufferImageCopy));
                }
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                    reservedunmarshal_VkBufferImageCopy(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkBufferImageCopy*)(pRegions + i),
                                                        readStreamPtrPtr);
                }
                if (pRegions) {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                        transform_tohost_VkBufferImageCopy(globalstate,
                                                           (VkBufferImageCopy*)(pRegions + i));
                    }
                }
                this->on_vkCmdCopyImageToBuffer(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                srcImage, srcImageLayout, dstBuffer, regionCount,
                                                pRegions);
                break;
            }
            case OP_vkCmdUpdateBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdUpdateBuffer");
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize dataSize;
                const void* pData;
                uint8_t* stack_pData[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&dataSize, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                if (((dataSize)) <= MAX_STACK_ITEMS) {
                    pData = (void*)stack_pData;
                } else {
                    readStream->alloc((void**)&pData, ((dataSize)) * sizeof(const uint8_t));
                }
                memcpy((void*)pData, *readStreamPtrPtr, ((dataSize)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((dataSize)) * sizeof(const uint8_t);
                vk->vkCmdUpdateBuffer((VkCommandBuffer)dispatchHandle, dstBuffer, dstOffset,
                                      dataSize, pData);
                break;
            }
            case OP_vkCmdFillBuffer: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdFillBuffer");
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize size;
                uint32_t data;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&size, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&data, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdFillBuffer((VkCommandBuffer)dispatchHandle, dstBuffer, dstOffset, size,
                                    data);
                break;
            }
            case OP_vkCmdClearColorImage: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdClearColorImage");
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearColorValue* pColor;
                VkClearColorValue stack_pColor[1];
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                VkImageSubresourceRange stack_pRanges[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                pColor = (VkClearColorValue*)stack_pColor;
                reservedunmarshal_VkClearColorValue(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkClearColorValue*)(pColor), readStreamPtrPtr);
                memcpy((uint32_t*)&rangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((rangeCount)) <= MAX_STACK_ITEMS) {
                    pRanges = (VkImageSubresourceRange*)stack_pRanges;
                } else {
                    readStream->alloc((void**)&pRanges,
                                      ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                }
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i) {
                    reservedunmarshal_VkImageSubresourceRange(
                        readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                        (VkImageSubresourceRange*)(pRanges + i), readStreamPtrPtr);
                }
                if (pColor) {
                    transform_tohost_VkClearColorValue(globalstate, (VkClearColorValue*)(pColor));
                }
                if (pRanges) {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i) {
                        transform_tohost_VkImageSubresourceRange(
                            globalstate, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                vk->vkCmdClearColorImage((VkCommandBuffer)dispatchHandle, image, imageLayout,
                                         pColor, rangeCount, pRanges);
                break;
            }
            case OP_vkCmdClearDepthStencilImage: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdClearDepthStencilImage");
                VkImage image;
                VkImageLayout imageLayout;
                const VkClearDepthStencilValue* pDepthStencil;
                VkClearDepthStencilValue stack_pDepthStencil[1];
                uint32_t rangeCount;
                const VkImageSubresourceRange* pRanges;
                VkImageSubresourceRange stack_pRanges[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&image = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                memcpy((VkImageLayout*)&imageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                pDepthStencil = (VkClearDepthStencilValue*)stack_pDepthStencil;
                reservedunmarshal_VkClearDepthStencilValue(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkClearDepthStencilValue*)(pDepthStencil), readStreamPtrPtr);
                memcpy((uint32_t*)&rangeCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((rangeCount)) <= MAX_STACK_ITEMS) {
                    pRanges = (VkImageSubresourceRange*)stack_pRanges;
                } else {
                    readStream->alloc((void**)&pRanges,
                                      ((rangeCount)) * sizeof(const VkImageSubresourceRange));
                }
                for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i) {
                    reservedunmarshal_VkImageSubresourceRange(
                        readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                        (VkImageSubresourceRange*)(pRanges + i), readStreamPtrPtr);
                }
                if (pDepthStencil) {
                    transform_tohost_VkClearDepthStencilValue(
                        globalstate, (VkClearDepthStencilValue*)(pDepthStencil));
                }
                if (pRanges) {
                    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i) {
                        transform_tohost_VkImageSubresourceRange(
                            globalstate, (VkImageSubresourceRange*)(pRanges + i));
                    }
                }
                vk->vkCmdClearDepthStencilImage((VkCommandBuffer)dispatchHandle, image, imageLayout,
                                                pDepthStencil, rangeCount, pRanges);
                break;
            }
            case OP_vkCmdClearAttachments: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdClearAttachments");
                uint32_t attachmentCount;
                const VkClearAttachment* pAttachments;
                VkClearAttachment stack_pAttachments[MAX_STACK_ITEMS];
                uint32_t rectCount;
                const VkClearRect* pRects;
                VkClearRect stack_pRects[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&attachmentCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((attachmentCount)) <= MAX_STACK_ITEMS) {
                    pAttachments = (VkClearAttachment*)stack_pAttachments;
                } else {
                    readStream->alloc((void**)&pAttachments,
                                      ((attachmentCount)) * sizeof(const VkClearAttachment));
                }
                for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i) {
                    reservedunmarshal_VkClearAttachment(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkClearAttachment*)(pAttachments + i),
                                                        readStreamPtrPtr);
                }
                memcpy((uint32_t*)&rectCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((rectCount)) <= MAX_STACK_ITEMS) {
                    pRects = (VkClearRect*)stack_pRects;
                } else {
                    readStream->alloc((void**)&pRects, ((rectCount)) * sizeof(const VkClearRect));
                }
                for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i) {
                    reservedunmarshal_VkClearRect(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                  (VkClearRect*)(pRects + i), readStreamPtrPtr);
                }
                if (pAttachments) {
                    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i) {
                        transform_tohost_VkClearAttachment(globalstate,
                                                           (VkClearAttachment*)(pAttachments + i));
                    }
                }
                if (pRects) {
                    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i) {
                        transform_tohost_VkClearRect(globalstate, (VkClearRect*)(pRects + i));
                    }
                }
                vk->vkCmdClearAttachments((VkCommandBuffer)dispatchHandle, attachmentCount,
                                          pAttachments, rectCount, pRects);
                break;
            }
            case OP_vkCmdResolveImage: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResolveImage");
                VkImage srcImage;
                VkImageLayout srcImageLayout;
                VkImage dstImage;
                VkImageLayout dstImageLayout;
                uint32_t regionCount;
                const VkImageResolve* pRegions;
                VkImageResolve stack_pRegions[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&srcImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_0));
                memcpy((VkImageLayout*)&srcImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkImage*)&dstImage = (VkImage)unbox_VkImage((VkImage)(*&cgen_var_1));
                memcpy((VkImageLayout*)&dstImageLayout, *readStreamPtrPtr, sizeof(VkImageLayout));
                *readStreamPtrPtr += sizeof(VkImageLayout);
                memcpy((uint32_t*)&regionCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((regionCount)) <= MAX_STACK_ITEMS) {
                    pRegions = (VkImageResolve*)stack_pRegions;
                } else {
                    readStream->alloc((void**)&pRegions,
                                      ((regionCount)) * sizeof(const VkImageResolve));
                }
                for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                    reservedunmarshal_VkImageResolve(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkImageResolve*)(pRegions + i),
                                                     readStreamPtrPtr);
                }
                if (pRegions) {
                    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i) {
                        transform_tohost_VkImageResolve(globalstate,
                                                        (VkImageResolve*)(pRegions + i));
                    }
                }
                vk->vkCmdResolveImage((VkCommandBuffer)dispatchHandle, srcImage, srcImageLayout,
                                      dstImage, dstImageLayout, regionCount, pRegions);
                break;
            }
            case OP_vkCmdSetEvent: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetEvent");
                VkEvent event;
                VkPipelineStageFlags stageMask;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_0));
                memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                vk->vkCmdSetEvent((VkCommandBuffer)dispatchHandle, event, stageMask);
                break;
            }
            case OP_vkCmdResetEvent: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResetEvent");
                VkEvent event;
                VkPipelineStageFlags stageMask;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_0));
                memcpy((VkPipelineStageFlags*)&stageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                vk->vkCmdResetEvent((VkCommandBuffer)dispatchHandle, event, stageMask);
                break;
            }
            case OP_vkCmdWaitEvents: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWaitEvents");
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkEvent stack_pEvents[MAX_STACK_ITEMS];
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                VkMemoryBarrier stack_pMemoryBarriers[MAX_STACK_ITEMS];
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                VkBufferMemoryBarrier stack_pBufferMemoryBarriers[MAX_STACK_ITEMS];
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                VkImageMemoryBarrier stack_pImageMemoryBarriers[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&eventCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((eventCount)) <= MAX_STACK_ITEMS) {
                    pEvents = (VkEvent*)stack_pEvents;
                } else {
                    readStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                }
                if (((eventCount))) {
                    uint8_t* cgen_var_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((eventCount));
                    for (uint32_t k = 0; k < ((eventCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkEvent*)pEvents) + k) =
                            tmpval ? (VkEvent)unbox_VkEvent((VkEvent)tmpval) : VK_NULL_HANDLE;
                    }
                }
                memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkPipelineStageFlags*)&dstStageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((uint32_t*)&memoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((memoryBarrierCount)) <= MAX_STACK_ITEMS) {
                    pMemoryBarriers = (VkMemoryBarrier*)stack_pMemoryBarriers;
                } else {
                    readStream->alloc((void**)&pMemoryBarriers,
                                      ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                }
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i) {
                    reservedunmarshal_VkMemoryBarrier(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkMemoryBarrier*)(pMemoryBarriers + i),
                                                      readStreamPtrPtr);
                }
                memcpy((uint32_t*)&bufferMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((bufferMemoryBarrierCount)) <= MAX_STACK_ITEMS) {
                    pBufferMemoryBarriers = (VkBufferMemoryBarrier*)stack_pBufferMemoryBarriers;
                } else {
                    readStream->alloc(
                        (void**)&pBufferMemoryBarriers,
                        ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                }
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i) {
                    reservedunmarshal_VkBufferMemoryBarrier(
                        readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                        (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&imageMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((imageMemoryBarrierCount)) <= MAX_STACK_ITEMS) {
                    pImageMemoryBarriers = (VkImageMemoryBarrier*)stack_pImageMemoryBarriers;
                } else {
                    readStream->alloc(
                        (void**)&pImageMemoryBarriers,
                        ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                }
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i) {
                    reservedunmarshal_VkImageMemoryBarrier(
                        readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                        (VkImageMemoryBarrier*)(pImageMemoryBarriers + i), readStreamPtrPtr);
                }
                if (pMemoryBarriers) {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i) {
                        transform_tohost_VkMemoryBarrier(globalstate,
                                                         (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers) {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i) {
                        transform_tohost_VkBufferMemoryBarrier(
                            globalstate, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers) {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i) {
                        transform_tohost_VkImageMemoryBarrier(
                            globalstate, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                vk->vkCmdWaitEvents((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
                                    srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers,
                                    bufferMemoryBarrierCount, pBufferMemoryBarriers,
                                    imageMemoryBarrierCount, pImageMemoryBarriers);
                break;
            }
            case OP_vkCmdPipelineBarrier: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdPipelineBarrier");
                VkPipelineStageFlags srcStageMask;
                VkPipelineStageFlags dstStageMask;
                VkDependencyFlags dependencyFlags;
                uint32_t memoryBarrierCount;
                const VkMemoryBarrier* pMemoryBarriers;
                VkMemoryBarrier stack_pMemoryBarriers[MAX_STACK_ITEMS];
                uint32_t bufferMemoryBarrierCount;
                const VkBufferMemoryBarrier* pBufferMemoryBarriers;
                VkBufferMemoryBarrier stack_pBufferMemoryBarriers[MAX_STACK_ITEMS];
                uint32_t imageMemoryBarrierCount;
                const VkImageMemoryBarrier* pImageMemoryBarriers;
                VkImageMemoryBarrier stack_pImageMemoryBarriers[MAX_STACK_ITEMS];
                memcpy((VkPipelineStageFlags*)&srcStageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkPipelineStageFlags*)&dstStageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags);
                memcpy((VkDependencyFlags*)&dependencyFlags, *readStreamPtrPtr,
                       sizeof(VkDependencyFlags));
                *readStreamPtrPtr += sizeof(VkDependencyFlags);
                memcpy((uint32_t*)&memoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((memoryBarrierCount)) <= MAX_STACK_ITEMS) {
                    pMemoryBarriers = (VkMemoryBarrier*)stack_pMemoryBarriers;
                } else {
                    readStream->alloc((void**)&pMemoryBarriers,
                                      ((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
                }
                for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i) {
                    reservedunmarshal_VkMemoryBarrier(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkMemoryBarrier*)(pMemoryBarriers + i),
                                                      readStreamPtrPtr);
                }
                memcpy((uint32_t*)&bufferMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((bufferMemoryBarrierCount)) <= MAX_STACK_ITEMS) {
                    pBufferMemoryBarriers = (VkBufferMemoryBarrier*)stack_pBufferMemoryBarriers;
                } else {
                    readStream->alloc(
                        (void**)&pBufferMemoryBarriers,
                        ((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
                }
                for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i) {
                    reservedunmarshal_VkBufferMemoryBarrier(
                        readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                        (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i), readStreamPtrPtr);
                }
                memcpy((uint32_t*)&imageMemoryBarrierCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((imageMemoryBarrierCount)) <= MAX_STACK_ITEMS) {
                    pImageMemoryBarriers = (VkImageMemoryBarrier*)stack_pImageMemoryBarriers;
                } else {
                    readStream->alloc(
                        (void**)&pImageMemoryBarriers,
                        ((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
                }
                for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i) {
                    reservedunmarshal_VkImageMemoryBarrier(
                        readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                        (VkImageMemoryBarrier*)(pImageMemoryBarriers + i), readStreamPtrPtr);
                }
                if (pMemoryBarriers) {
                    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i) {
                        transform_tohost_VkMemoryBarrier(globalstate,
                                                         (VkMemoryBarrier*)(pMemoryBarriers + i));
                    }
                }
                if (pBufferMemoryBarriers) {
                    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i) {
                        transform_tohost_VkBufferMemoryBarrier(
                            globalstate, (VkBufferMemoryBarrier*)(pBufferMemoryBarriers + i));
                    }
                }
                if (pImageMemoryBarriers) {
                    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i) {
                        transform_tohost_VkImageMemoryBarrier(
                            globalstate, (VkImageMemoryBarrier*)(pImageMemoryBarriers + i));
                    }
                }
                this->on_vkCmdPipelineBarrier(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), srcStageMask, dstStageMask,
                    dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount,
                    pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
                break;
            }
            case OP_vkCmdBeginQuery: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginQuery");
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((VkQueryControlFlags*)&flags, *readStreamPtrPtr,
                       sizeof(VkQueryControlFlags));
                *readStreamPtrPtr += sizeof(VkQueryControlFlags);
                vk->vkCmdBeginQuery((VkCommandBuffer)dispatchHandle, queryPool, query, flags);
                break;
            }
            case OP_vkCmdEndQuery: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndQuery");
                VkQueryPool queryPool;
                uint32_t query;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdEndQuery((VkCommandBuffer)dispatchHandle, queryPool, query);
                break;
            }
            case OP_vkCmdResetQueryPool: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResetQueryPool");
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdResetQueryPool((VkCommandBuffer)dispatchHandle, queryPool, firstQuery,
                                        queryCount);
                break;
            }
            case OP_vkCmdWriteTimestamp: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWriteTimestamp");
                VkPipelineStageFlagBits pipelineStage;
                VkQueryPool queryPool;
                uint32_t query;
                memcpy((VkPipelineStageFlagBits*)&pipelineStage, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlagBits));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlagBits);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdWriteTimestamp((VkCommandBuffer)dispatchHandle, pipelineStage, queryPool,
                                        query);
                break;
            }
            case OP_vkCmdCopyQueryPoolResults: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyQueryPoolResults");
                VkQueryPool queryPool;
                uint32_t firstQuery;
                uint32_t queryCount;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                VkDeviceSize stride;
                VkQueryResultFlags flags;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&firstQuery, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&queryCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&stride, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkQueryResultFlags*)&flags, *readStreamPtrPtr, sizeof(VkQueryResultFlags));
                *readStreamPtrPtr += sizeof(VkQueryResultFlags);
                this->on_vkCmdCopyQueryPoolResults(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                   queryPool, firstQuery, queryCount, dstBuffer,
                                                   dstOffset, stride, flags);
                break;
            }
            case OP_vkCmdPushConstants: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdPushConstants");
                VkPipelineLayout layout;
                VkShaderStageFlags stageFlags;
                uint32_t offset;
                uint32_t size;
                const void* pValues;
                uint8_t* stack_pValues[MAX_STACK_ITEMS];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkPipelineLayout*)&layout =
                    (VkPipelineLayout)unbox_VkPipelineLayout((VkPipelineLayout)(*&cgen_var_0));
                memcpy((VkShaderStageFlags*)&stageFlags, *readStreamPtrPtr,
                       sizeof(VkShaderStageFlags));
                *readStreamPtrPtr += sizeof(VkShaderStageFlags);
                memcpy((uint32_t*)&offset, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&size, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((size)) <= MAX_STACK_ITEMS) {
                    pValues = (void*)stack_pValues;
                } else {
                    readStream->alloc((void**)&pValues, ((size)) * sizeof(const uint8_t));
                }
                memcpy((void*)pValues, *readStreamPtrPtr, ((size)) * sizeof(const uint8_t));
                *readStreamPtrPtr += ((size)) * sizeof(const uint8_t);
                vk->vkCmdPushConstants((VkCommandBuffer)dispatchHandle, layout, stageFlags, offset,
                                       size, pValues);
                break;
            }
            case OP_vkCmdBeginRenderPass: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginRenderPass");
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkRenderPassBeginInfo stack_pRenderPassBegin[1];
                VkSubpassContents contents;
                pRenderPassBegin = (VkRenderPassBeginInfo*)stack_pRenderPassBegin;
                reservedunmarshal_VkRenderPassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkRenderPassBeginInfo*)(pRenderPassBegin),
                                                        readStreamPtrPtr);
                memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                *readStreamPtrPtr += sizeof(VkSubpassContents);
                if (pRenderPassBegin) {
                    transform_tohost_VkRenderPassBeginInfo(
                        globalstate, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                this->on_vkCmdBeginRenderPass(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                              pRenderPassBegin, contents);
                break;
            }
            case OP_vkCmdNextSubpass: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdNextSubpass");
                VkSubpassContents contents;
                memcpy((VkSubpassContents*)&contents, *readStreamPtrPtr, sizeof(VkSubpassContents));
                *readStreamPtrPtr += sizeof(VkSubpassContents);
                vk->vkCmdNextSubpass((VkCommandBuffer)dispatchHandle, contents);
                break;
            }
            case OP_vkCmdEndRenderPass: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndRenderPass");
                vk->vkCmdEndRenderPass((VkCommandBuffer)dispatchHandle);
                break;
            }
            case OP_vkCmdExecuteCommands: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdExecuteCommands");
                uint32_t commandBufferCount;
                const VkCommandBuffer* pCommandBuffers;
                VkCommandBuffer stack_pCommandBuffers[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&commandBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((commandBufferCount)) <= MAX_STACK_ITEMS) {
                    pCommandBuffers = (VkCommandBuffer*)stack_pCommandBuffers;
                } else {
                    readStream->alloc((void**)&pCommandBuffers,
                                      ((commandBufferCount)) * sizeof(const VkCommandBuffer));
                }
                if (((commandBufferCount))) {
                    uint8_t* cgen_var_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((commandBufferCount));
                    for (uint32_t k = 0; k < ((commandBufferCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkCommandBuffer*)pCommandBuffers) + k) =
                            tmpval ? (VkCommandBuffer)unbox_VkCommandBuffer((VkCommandBuffer)tmpval)
                                   : VK_NULL_HANDLE;
                    }
                }
                this->on_vkCmdExecuteCommands(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                              commandBufferCount, pCommandBuffers);
                break;
            }
#endif
#ifdef VK_VERSION_1_1
            case OP_vkCmdSetDeviceMask: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDeviceMask");
                uint32_t deviceMask;
                memcpy((uint32_t*)&deviceMask, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdSetDeviceMask((VkCommandBuffer)dispatchHandle, deviceMask);
                break;
            }
            case OP_vkCmdDispatchBase: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDispatchBase");
                uint32_t baseGroupX;
                uint32_t baseGroupY;
                uint32_t baseGroupZ;
                uint32_t groupCountX;
                uint32_t groupCountY;
                uint32_t groupCountZ;
                memcpy((uint32_t*)&baseGroupX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&baseGroupZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountX, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountY, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&groupCountZ, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDispatchBase((VkCommandBuffer)dispatchHandle, baseGroupX, baseGroupY,
                                      baseGroupZ, groupCountX, groupCountY, groupCountZ);
                break;
            }
#endif
#ifdef VK_VERSION_1_2
            case OP_vkCmdDrawIndirectCount: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDrawIndirectCount");
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDrawIndirectCount((VkCommandBuffer)dispatchHandle, buffer, offset,
                                           countBuffer, countBufferOffset, maxDrawCount, stride);
                break;
            }
            case OP_vkCmdDrawIndexedIndirectCount: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDrawIndexedIndirectCount");
                VkBuffer buffer;
                VkDeviceSize offset;
                VkBuffer countBuffer;
                VkDeviceSize countBufferOffset;
                uint32_t maxDrawCount;
                uint32_t stride;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                uint64_t cgen_var_1;
                memcpy((uint64_t*)&cgen_var_1, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&countBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_1));
                memcpy((VkDeviceSize*)&countBufferOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&maxDrawCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&stride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDrawIndexedIndirectCount((VkCommandBuffer)dispatchHandle, buffer, offset,
                                                  countBuffer, countBufferOffset, maxDrawCount,
                                                  stride);
                break;
            }
            case OP_vkCmdBeginRenderPass2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginRenderPass2");
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkRenderPassBeginInfo stack_pRenderPassBegin[1];
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                VkSubpassBeginInfo stack_pSubpassBeginInfo[1];
                pRenderPassBegin = (VkRenderPassBeginInfo*)stack_pRenderPassBegin;
                reservedunmarshal_VkRenderPassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkRenderPassBeginInfo*)(pRenderPassBegin),
                                                        readStreamPtrPtr);
                pSubpassBeginInfo = (VkSubpassBeginInfo*)stack_pSubpassBeginInfo;
                reservedunmarshal_VkSubpassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkSubpassBeginInfo*)(pSubpassBeginInfo),
                                                     readStreamPtrPtr);
                if (pRenderPassBegin) {
                    transform_tohost_VkRenderPassBeginInfo(
                        globalstate, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo) {
                    transform_tohost_VkSubpassBeginInfo(globalstate,
                                                        (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                this->on_vkCmdBeginRenderPass2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                               pRenderPassBegin, pSubpassBeginInfo);
                break;
            }
            case OP_vkCmdNextSubpass2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdNextSubpass2");
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                VkSubpassBeginInfo stack_pSubpassBeginInfo[1];
                const VkSubpassEndInfo* pSubpassEndInfo;
                VkSubpassEndInfo stack_pSubpassEndInfo[1];
                pSubpassBeginInfo = (VkSubpassBeginInfo*)stack_pSubpassBeginInfo;
                reservedunmarshal_VkSubpassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkSubpassBeginInfo*)(pSubpassBeginInfo),
                                                     readStreamPtrPtr);
                pSubpassEndInfo = (VkSubpassEndInfo*)stack_pSubpassEndInfo;
                reservedunmarshal_VkSubpassEndInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkSubpassEndInfo*)(pSubpassEndInfo),
                                                   readStreamPtrPtr);
                if (pSubpassBeginInfo) {
                    transform_tohost_VkSubpassBeginInfo(globalstate,
                                                        (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo) {
                    transform_tohost_VkSubpassEndInfo(globalstate,
                                                      (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                vk->vkCmdNextSubpass2((VkCommandBuffer)dispatchHandle, pSubpassBeginInfo,
                                      pSubpassEndInfo);
                break;
            }
            case OP_vkCmdEndRenderPass2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndRenderPass2");
                const VkSubpassEndInfo* pSubpassEndInfo;
                VkSubpassEndInfo stack_pSubpassEndInfo[1];
                pSubpassEndInfo = (VkSubpassEndInfo*)stack_pSubpassEndInfo;
                reservedunmarshal_VkSubpassEndInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkSubpassEndInfo*)(pSubpassEndInfo),
                                                   readStreamPtrPtr);
                if (pSubpassEndInfo) {
                    transform_tohost_VkSubpassEndInfo(globalstate,
                                                      (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                vk->vkCmdEndRenderPass2((VkCommandBuffer)dispatchHandle, pSubpassEndInfo);
                break;
            }
#endif
#ifdef VK_VERSION_1_3
            case OP_vkCmdSetEvent2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetEvent2");
                VkEvent event;
                const VkDependencyInfo* pDependencyInfo;
                VkDependencyInfo stack_pDependencyInfo[1];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_0));
                pDependencyInfo = (VkDependencyInfo*)stack_pDependencyInfo;
                reservedunmarshal_VkDependencyInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkDependencyInfo*)(pDependencyInfo),
                                                   readStreamPtrPtr);
                if (pDependencyInfo) {
                    transform_tohost_VkDependencyInfo(globalstate,
                                                      (VkDependencyInfo*)(pDependencyInfo));
                }
                vk->vkCmdSetEvent2((VkCommandBuffer)dispatchHandle, event, pDependencyInfo);
                break;
            }
            case OP_vkCmdResetEvent2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResetEvent2");
                VkEvent event;
                VkPipelineStageFlags2 stageMask;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_0));
                memcpy((VkPipelineStageFlags2*)&stageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags2));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
                vk->vkCmdResetEvent2((VkCommandBuffer)dispatchHandle, event, stageMask);
                break;
            }
            case OP_vkCmdWaitEvents2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWaitEvents2");
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkEvent stack_pEvents[MAX_STACK_ITEMS];
                const VkDependencyInfo* pDependencyInfos;
                VkDependencyInfo stack_pDependencyInfos[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&eventCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((eventCount)) <= MAX_STACK_ITEMS) {
                    pEvents = (VkEvent*)stack_pEvents;
                } else {
                    readStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                }
                if (((eventCount))) {
                    uint8_t* cgen_var_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((eventCount));
                    for (uint32_t k = 0; k < ((eventCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkEvent*)pEvents) + k) =
                            tmpval ? (VkEvent)unbox_VkEvent((VkEvent)tmpval) : VK_NULL_HANDLE;
                    }
                }
                if (((eventCount)) <= MAX_STACK_ITEMS) {
                    pDependencyInfos = (VkDependencyInfo*)stack_pDependencyInfos;
                } else {
                    readStream->alloc((void**)&pDependencyInfos,
                                      ((eventCount)) * sizeof(const VkDependencyInfo));
                }
                for (uint32_t i = 0; i < (uint32_t)((eventCount)); ++i) {
                    reservedunmarshal_VkDependencyInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                       (VkDependencyInfo*)(pDependencyInfos + i),
                                                       readStreamPtrPtr);
                }
                if (pDependencyInfos) {
                    for (uint32_t i = 0; i < (uint32_t)((eventCount)); ++i) {
                        transform_tohost_VkDependencyInfo(
                            globalstate, (VkDependencyInfo*)(pDependencyInfos + i));
                    }
                }
                vk->vkCmdWaitEvents2((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
                                     pDependencyInfos);
                break;
            }
            case OP_vkCmdPipelineBarrier2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdPipelineBarrier2");
                const VkDependencyInfo* pDependencyInfo;
                VkDependencyInfo stack_pDependencyInfo[1];
                pDependencyInfo = (VkDependencyInfo*)stack_pDependencyInfo;
                reservedunmarshal_VkDependencyInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkDependencyInfo*)(pDependencyInfo),
                                                   readStreamPtrPtr);
                if (pDependencyInfo) {
                    transform_tohost_VkDependencyInfo(globalstate,
                                                      (VkDependencyInfo*)(pDependencyInfo));
                }
                this->on_vkCmdPipelineBarrier2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                               pDependencyInfo);
                break;
            }
            case OP_vkCmdWriteTimestamp2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWriteTimestamp2");
                VkPipelineStageFlags2 stage;
                VkQueryPool queryPool;
                uint32_t query;
                memcpy((VkPipelineStageFlags2*)&stage, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags2));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdWriteTimestamp2((VkCommandBuffer)dispatchHandle, stage, queryPool, query);
                break;
            }
            case OP_vkCmdCopyBuffer2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyBuffer2");
                const VkCopyBufferInfo2* pCopyBufferInfo;
                VkCopyBufferInfo2 stack_pCopyBufferInfo[1];
                pCopyBufferInfo = (VkCopyBufferInfo2*)stack_pCopyBufferInfo;
                reservedunmarshal_VkCopyBufferInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkCopyBufferInfo2*)(pCopyBufferInfo),
                                                    readStreamPtrPtr);
                if (pCopyBufferInfo) {
                    transform_tohost_VkCopyBufferInfo2(globalstate,
                                                       (VkCopyBufferInfo2*)(pCopyBufferInfo));
                }
                vk->vkCmdCopyBuffer2((VkCommandBuffer)dispatchHandle, pCopyBufferInfo);
                break;
            }
            case OP_vkCmdCopyImage2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyImage2");
                const VkCopyImageInfo2* pCopyImageInfo;
                VkCopyImageInfo2 stack_pCopyImageInfo[1];
                pCopyImageInfo = (VkCopyImageInfo2*)stack_pCopyImageInfo;
                reservedunmarshal_VkCopyImageInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkCopyImageInfo2*)(pCopyImageInfo),
                                                   readStreamPtrPtr);
                if (pCopyImageInfo) {
                    transform_tohost_VkCopyImageInfo2(globalstate,
                                                      (VkCopyImageInfo2*)(pCopyImageInfo));
                }
                this->on_vkCmdCopyImage2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                         pCopyImageInfo);
                break;
            }
            case OP_vkCmdCopyBufferToImage2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyBufferToImage2");
                const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo;
                VkCopyBufferToImageInfo2 stack_pCopyBufferToImageInfo[1];
                pCopyBufferToImageInfo = (VkCopyBufferToImageInfo2*)stack_pCopyBufferToImageInfo;
                reservedunmarshal_VkCopyBufferToImageInfo2(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkCopyBufferToImageInfo2*)(pCopyBufferToImageInfo), readStreamPtrPtr);
                if (pCopyBufferToImageInfo) {
                    transform_tohost_VkCopyBufferToImageInfo2(
                        globalstate, (VkCopyBufferToImageInfo2*)(pCopyBufferToImageInfo));
                }
                this->on_vkCmdCopyBufferToImage2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                 pCopyBufferToImageInfo, context);
                break;
            }
            case OP_vkCmdCopyImageToBuffer2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyImageToBuffer2");
                const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo;
                VkCopyImageToBufferInfo2 stack_pCopyImageToBufferInfo[1];
                pCopyImageToBufferInfo = (VkCopyImageToBufferInfo2*)stack_pCopyImageToBufferInfo;
                reservedunmarshal_VkCopyImageToBufferInfo2(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkCopyImageToBufferInfo2*)(pCopyImageToBufferInfo), readStreamPtrPtr);
                if (pCopyImageToBufferInfo) {
                    transform_tohost_VkCopyImageToBufferInfo2(
                        globalstate, (VkCopyImageToBufferInfo2*)(pCopyImageToBufferInfo));
                }
                this->on_vkCmdCopyImageToBuffer2(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                 pCopyImageToBufferInfo);
                break;
            }
            case OP_vkCmdBlitImage2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBlitImage2");
                const VkBlitImageInfo2* pBlitImageInfo;
                VkBlitImageInfo2 stack_pBlitImageInfo[1];
                pBlitImageInfo = (VkBlitImageInfo2*)stack_pBlitImageInfo;
                reservedunmarshal_VkBlitImageInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkBlitImageInfo2*)(pBlitImageInfo),
                                                   readStreamPtrPtr);
                if (pBlitImageInfo) {
                    transform_tohost_VkBlitImageInfo2(globalstate,
                                                      (VkBlitImageInfo2*)(pBlitImageInfo));
                }
                vk->vkCmdBlitImage2((VkCommandBuffer)dispatchHandle, pBlitImageInfo);
                break;
            }
            case OP_vkCmdResolveImage2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResolveImage2");
                const VkResolveImageInfo2* pResolveImageInfo;
                VkResolveImageInfo2 stack_pResolveImageInfo[1];
                pResolveImageInfo = (VkResolveImageInfo2*)stack_pResolveImageInfo;
                reservedunmarshal_VkResolveImageInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkResolveImageInfo2*)(pResolveImageInfo),
                                                      readStreamPtrPtr);
                if (pResolveImageInfo) {
                    transform_tohost_VkResolveImageInfo2(globalstate,
                                                         (VkResolveImageInfo2*)(pResolveImageInfo));
                }
                vk->vkCmdResolveImage2((VkCommandBuffer)dispatchHandle, pResolveImageInfo);
                break;
            }
            case OP_vkCmdBeginRendering: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginRendering");
                const VkRenderingInfo* pRenderingInfo;
                VkRenderingInfo stack_pRenderingInfo[1];
                pRenderingInfo = (VkRenderingInfo*)stack_pRenderingInfo;
                reservedunmarshal_VkRenderingInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                  (VkRenderingInfo*)(pRenderingInfo),
                                                  readStreamPtrPtr);
                if (pRenderingInfo) {
                    transform_tohost_VkRenderingInfo(globalstate,
                                                     (VkRenderingInfo*)(pRenderingInfo));
                }
                vk->vkCmdBeginRendering((VkCommandBuffer)dispatchHandle, pRenderingInfo);
                break;
            }
            case OP_vkCmdEndRendering: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndRendering");
                vk->vkCmdEndRendering((VkCommandBuffer)dispatchHandle);
                break;
            }
            case OP_vkCmdSetCullMode: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetCullMode");
                VkCullModeFlags cullMode;
                memcpy((VkCullModeFlags*)&cullMode, *readStreamPtrPtr, sizeof(VkCullModeFlags));
                *readStreamPtrPtr += sizeof(VkCullModeFlags);
                vk->vkCmdSetCullMode((VkCommandBuffer)dispatchHandle, cullMode);
                break;
            }
            case OP_vkCmdSetFrontFace: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetFrontFace");
                VkFrontFace frontFace;
                memcpy((VkFrontFace*)&frontFace, *readStreamPtrPtr, sizeof(VkFrontFace));
                *readStreamPtrPtr += sizeof(VkFrontFace);
                vk->vkCmdSetFrontFace((VkCommandBuffer)dispatchHandle, frontFace);
                break;
            }
            case OP_vkCmdSetPrimitiveTopology: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetPrimitiveTopology");
                VkPrimitiveTopology primitiveTopology;
                memcpy((VkPrimitiveTopology*)&primitiveTopology, *readStreamPtrPtr,
                       sizeof(VkPrimitiveTopology));
                *readStreamPtrPtr += sizeof(VkPrimitiveTopology);
                vk->vkCmdSetPrimitiveTopology((VkCommandBuffer)dispatchHandle, primitiveTopology);
                break;
            }
            case OP_vkCmdSetViewportWithCount: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetViewportWithCount");
                uint32_t viewportCount;
                const VkViewport* pViewports;
                VkViewport stack_pViewports[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((viewportCount)) <= MAX_STACK_ITEMS) {
                    pViewports = (VkViewport*)stack_pViewports;
                } else {
                    readStream->alloc((void**)&pViewports,
                                      ((viewportCount)) * sizeof(const VkViewport));
                }
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i) {
                    reservedunmarshal_VkViewport(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                 (VkViewport*)(pViewports + i), readStreamPtrPtr);
                }
                if (pViewports) {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i) {
                        transform_tohost_VkViewport(globalstate, (VkViewport*)(pViewports + i));
                    }
                }
                vk->vkCmdSetViewportWithCount((VkCommandBuffer)dispatchHandle, viewportCount,
                                              pViewports);
                break;
            }
            case OP_vkCmdSetScissorWithCount: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetScissorWithCount");
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                VkRect2D stack_pScissors[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&scissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((scissorCount)) <= MAX_STACK_ITEMS) {
                    pScissors = (VkRect2D*)stack_pScissors;
                } else {
                    readStream->alloc((void**)&pScissors,
                                      ((scissorCount)) * sizeof(const VkRect2D));
                }
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i) {
                    reservedunmarshal_VkRect2D(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkRect2D*)(pScissors + i), readStreamPtrPtr);
                }
                if (pScissors) {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i) {
                        transform_tohost_VkRect2D(globalstate, (VkRect2D*)(pScissors + i));
                    }
                }
                vk->vkCmdSetScissorWithCount((VkCommandBuffer)dispatchHandle, scissorCount,
                                             pScissors);
                break;
            }
            case OP_vkCmdBindVertexBuffers2: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindVertexBuffers2");
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                VkBuffer stack_pBuffers[MAX_STACK_ITEMS];
                const VkDeviceSize* pOffsets;
                VkDeviceSize stack_pOffsets[MAX_STACK_ITEMS];
                const VkDeviceSize* pSizes;
                VkDeviceSize stack_pSizes[MAX_STACK_ITEMS];
                const VkDeviceSize* pStrides;
                VkDeviceSize stack_pStrides[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkBuffer**)&pBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBuffers);
                *readStreamPtrPtr += 8;
                if (pBuffers) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pBuffers = (VkBuffer*)stack_pBuffers;
                    } else {
                        readStream->alloc((void**)&pBuffers,
                                          ((bindingCount)) * sizeof(const VkBuffer));
                    }
                    if (((bindingCount))) {
                        uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((bindingCount));
                        for (uint32_t k = 0; k < ((bindingCount)); ++k) {
                            uint64_t tmpval;
                            memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBuffer*)pBuffers) + k) =
                                tmpval ? (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval)
                                       : VK_NULL_HANDLE;
                        }
                    }
                }
                if (((bindingCount)) <= MAX_STACK_ITEMS) {
                    pOffsets = (VkDeviceSize*)stack_pOffsets;
                } else {
                    readStream->alloc((void**)&pOffsets,
                                      ((bindingCount)) * sizeof(const VkDeviceSize));
                }
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr,
                       ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pSizes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSizes);
                *readStreamPtrPtr += 8;
                if (pSizes) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pSizes = (VkDeviceSize*)stack_pSizes;
                    } else {
                        readStream->alloc((void**)&pSizes,
                                          ((bindingCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pSizes, *readStreamPtrPtr,
                           ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pStrides, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pStrides);
                *readStreamPtrPtr += 8;
                if (pStrides) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pStrides = (VkDeviceSize*)stack_pStrides;
                    } else {
                        readStream->alloc((void**)&pStrides,
                                          ((bindingCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pStrides, *readStreamPtrPtr,
                           ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                vk->vkCmdBindVertexBuffers2((VkCommandBuffer)dispatchHandle, firstBinding,
                                            bindingCount, pBuffers, pOffsets, pSizes, pStrides);
                break;
            }
            case OP_vkCmdSetDepthTestEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthTestEnable");
                VkBool32 depthTestEnable;
                memcpy((VkBool32*)&depthTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthTestEnable((VkCommandBuffer)dispatchHandle, depthTestEnable);
                break;
            }
            case OP_vkCmdSetDepthWriteEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthWriteEnable");
                VkBool32 depthWriteEnable;
                memcpy((VkBool32*)&depthWriteEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthWriteEnable((VkCommandBuffer)dispatchHandle, depthWriteEnable);
                break;
            }
            case OP_vkCmdSetDepthCompareOp: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthCompareOp");
                VkCompareOp depthCompareOp;
                memcpy((VkCompareOp*)&depthCompareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                *readStreamPtrPtr += sizeof(VkCompareOp);
                vk->vkCmdSetDepthCompareOp((VkCommandBuffer)dispatchHandle, depthCompareOp);
                break;
            }
            case OP_vkCmdSetDepthBoundsTestEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthBoundsTestEnable");
                VkBool32 depthBoundsTestEnable;
                memcpy((VkBool32*)&depthBoundsTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthBoundsTestEnable((VkCommandBuffer)dispatchHandle,
                                                  depthBoundsTestEnable);
                break;
            }
            case OP_vkCmdSetStencilTestEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilTestEnable");
                VkBool32 stencilTestEnable;
                memcpy((VkBool32*)&stencilTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetStencilTestEnable((VkCommandBuffer)dispatchHandle, stencilTestEnable);
                break;
            }
            case OP_vkCmdSetStencilOp: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilOp");
                VkStencilFaceFlags faceMask;
                VkStencilOp failOp;
                VkStencilOp passOp;
                VkStencilOp depthFailOp;
                VkCompareOp compareOp;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr,
                       sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((VkStencilOp*)&failOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkStencilOp*)&passOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkStencilOp*)&depthFailOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkCompareOp*)&compareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                *readStreamPtrPtr += sizeof(VkCompareOp);
                vk->vkCmdSetStencilOp((VkCommandBuffer)dispatchHandle, faceMask, failOp, passOp,
                                      depthFailOp, compareOp);
                break;
            }
            case OP_vkCmdSetRasterizerDiscardEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetRasterizerDiscardEnable");
                VkBool32 rasterizerDiscardEnable;
                memcpy((VkBool32*)&rasterizerDiscardEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetRasterizerDiscardEnable((VkCommandBuffer)dispatchHandle,
                                                    rasterizerDiscardEnable);
                break;
            }
            case OP_vkCmdSetDepthBiasEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthBiasEnable");
                VkBool32 depthBiasEnable;
                memcpy((VkBool32*)&depthBiasEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthBiasEnable((VkCommandBuffer)dispatchHandle, depthBiasEnable);
                break;
            }
            case OP_vkCmdSetPrimitiveRestartEnable: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetPrimitiveRestartEnable");
                VkBool32 primitiveRestartEnable;
                memcpy((VkBool32*)&primitiveRestartEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetPrimitiveRestartEnable((VkCommandBuffer)dispatchHandle,
                                                   primitiveRestartEnable);
                break;
            }
#endif
#ifdef VK_KHR_dynamic_rendering
            case OP_vkCmdBeginRenderingKHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginRenderingKHR");
                const VkRenderingInfo* pRenderingInfo;
                VkRenderingInfo stack_pRenderingInfo[1];
                pRenderingInfo = (VkRenderingInfo*)stack_pRenderingInfo;
                reservedunmarshal_VkRenderingInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                  (VkRenderingInfo*)(pRenderingInfo),
                                                  readStreamPtrPtr);
                if (pRenderingInfo) {
                    transform_tohost_VkRenderingInfo(globalstate,
                                                     (VkRenderingInfo*)(pRenderingInfo));
                }
                vk->vkCmdBeginRenderingKHR((VkCommandBuffer)dispatchHandle, pRenderingInfo);
                break;
            }
            case OP_vkCmdEndRenderingKHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndRenderingKHR");
                vk->vkCmdEndRenderingKHR((VkCommandBuffer)dispatchHandle);
                break;
            }
#endif
#ifdef VK_KHR_create_renderpass2
            case OP_vkCmdBeginRenderPass2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginRenderPass2KHR");
                const VkRenderPassBeginInfo* pRenderPassBegin;
                VkRenderPassBeginInfo stack_pRenderPassBegin[1];
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                VkSubpassBeginInfo stack_pSubpassBeginInfo[1];
                pRenderPassBegin = (VkRenderPassBeginInfo*)stack_pRenderPassBegin;
                reservedunmarshal_VkRenderPassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                        (VkRenderPassBeginInfo*)(pRenderPassBegin),
                                                        readStreamPtrPtr);
                pSubpassBeginInfo = (VkSubpassBeginInfo*)stack_pSubpassBeginInfo;
                reservedunmarshal_VkSubpassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkSubpassBeginInfo*)(pSubpassBeginInfo),
                                                     readStreamPtrPtr);
                if (pRenderPassBegin) {
                    transform_tohost_VkRenderPassBeginInfo(
                        globalstate, (VkRenderPassBeginInfo*)(pRenderPassBegin));
                }
                if (pSubpassBeginInfo) {
                    transform_tohost_VkSubpassBeginInfo(globalstate,
                                                        (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                this->on_vkCmdBeginRenderPass2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                  pRenderPassBegin, pSubpassBeginInfo);
                break;
            }
            case OP_vkCmdNextSubpass2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdNextSubpass2KHR");
                const VkSubpassBeginInfo* pSubpassBeginInfo;
                VkSubpassBeginInfo stack_pSubpassBeginInfo[1];
                const VkSubpassEndInfo* pSubpassEndInfo;
                VkSubpassEndInfo stack_pSubpassEndInfo[1];
                pSubpassBeginInfo = (VkSubpassBeginInfo*)stack_pSubpassBeginInfo;
                reservedunmarshal_VkSubpassBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                     (VkSubpassBeginInfo*)(pSubpassBeginInfo),
                                                     readStreamPtrPtr);
                pSubpassEndInfo = (VkSubpassEndInfo*)stack_pSubpassEndInfo;
                reservedunmarshal_VkSubpassEndInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkSubpassEndInfo*)(pSubpassEndInfo),
                                                   readStreamPtrPtr);
                if (pSubpassBeginInfo) {
                    transform_tohost_VkSubpassBeginInfo(globalstate,
                                                        (VkSubpassBeginInfo*)(pSubpassBeginInfo));
                }
                if (pSubpassEndInfo) {
                    transform_tohost_VkSubpassEndInfo(globalstate,
                                                      (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                vk->vkCmdNextSubpass2KHR((VkCommandBuffer)dispatchHandle, pSubpassBeginInfo,
                                         pSubpassEndInfo);
                break;
            }
            case OP_vkCmdEndRenderPass2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndRenderPass2KHR");
                const VkSubpassEndInfo* pSubpassEndInfo;
                VkSubpassEndInfo stack_pSubpassEndInfo[1];
                pSubpassEndInfo = (VkSubpassEndInfo*)stack_pSubpassEndInfo;
                reservedunmarshal_VkSubpassEndInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkSubpassEndInfo*)(pSubpassEndInfo),
                                                   readStreamPtrPtr);
                if (pSubpassEndInfo) {
                    transform_tohost_VkSubpassEndInfo(globalstate,
                                                      (VkSubpassEndInfo*)(pSubpassEndInfo));
                }
                vk->vkCmdEndRenderPass2KHR((VkCommandBuffer)dispatchHandle, pSubpassEndInfo);
                break;
            }
#endif
#ifdef VK_KHR_synchronization2
            case OP_vkCmdSetEvent2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetEvent2KHR");
                VkEvent event;
                const VkDependencyInfo* pDependencyInfo;
                VkDependencyInfo stack_pDependencyInfo[1];
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_0));
                pDependencyInfo = (VkDependencyInfo*)stack_pDependencyInfo;
                reservedunmarshal_VkDependencyInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkDependencyInfo*)(pDependencyInfo),
                                                   readStreamPtrPtr);
                if (pDependencyInfo) {
                    transform_tohost_VkDependencyInfo(globalstate,
                                                      (VkDependencyInfo*)(pDependencyInfo));
                }
                vk->vkCmdSetEvent2KHR((VkCommandBuffer)dispatchHandle, event, pDependencyInfo);
                break;
            }
            case OP_vkCmdResetEvent2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResetEvent2KHR");
                VkEvent event;
                VkPipelineStageFlags2 stageMask;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkEvent*)&event = (VkEvent)unbox_VkEvent((VkEvent)(*&cgen_var_0));
                memcpy((VkPipelineStageFlags2*)&stageMask, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags2));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
                vk->vkCmdResetEvent2KHR((VkCommandBuffer)dispatchHandle, event, stageMask);
                break;
            }
            case OP_vkCmdWaitEvents2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWaitEvents2KHR");
                uint32_t eventCount;
                const VkEvent* pEvents;
                VkEvent stack_pEvents[MAX_STACK_ITEMS];
                const VkDependencyInfo* pDependencyInfos;
                VkDependencyInfo stack_pDependencyInfos[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&eventCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((eventCount)) <= MAX_STACK_ITEMS) {
                    pEvents = (VkEvent*)stack_pEvents;
                } else {
                    readStream->alloc((void**)&pEvents, ((eventCount)) * sizeof(const VkEvent));
                }
                if (((eventCount))) {
                    uint8_t* cgen_var_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((eventCount));
                    for (uint32_t k = 0; k < ((eventCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkEvent*)pEvents) + k) =
                            tmpval ? (VkEvent)unbox_VkEvent((VkEvent)tmpval) : VK_NULL_HANDLE;
                    }
                }
                if (((eventCount)) <= MAX_STACK_ITEMS) {
                    pDependencyInfos = (VkDependencyInfo*)stack_pDependencyInfos;
                } else {
                    readStream->alloc((void**)&pDependencyInfos,
                                      ((eventCount)) * sizeof(const VkDependencyInfo));
                }
                for (uint32_t i = 0; i < (uint32_t)((eventCount)); ++i) {
                    reservedunmarshal_VkDependencyInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                       (VkDependencyInfo*)(pDependencyInfos + i),
                                                       readStreamPtrPtr);
                }
                if (pDependencyInfos) {
                    for (uint32_t i = 0; i < (uint32_t)((eventCount)); ++i) {
                        transform_tohost_VkDependencyInfo(
                            globalstate, (VkDependencyInfo*)(pDependencyInfos + i));
                    }
                }
                vk->vkCmdWaitEvents2KHR((VkCommandBuffer)dispatchHandle, eventCount, pEvents,
                                        pDependencyInfos);
                break;
            }
            case OP_vkCmdPipelineBarrier2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdPipelineBarrier2KHR");
                const VkDependencyInfo* pDependencyInfo;
                VkDependencyInfo stack_pDependencyInfo[1];
                pDependencyInfo = (VkDependencyInfo*)stack_pDependencyInfo;
                reservedunmarshal_VkDependencyInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkDependencyInfo*)(pDependencyInfo),
                                                   readStreamPtrPtr);
                if (pDependencyInfo) {
                    transform_tohost_VkDependencyInfo(globalstate,
                                                      (VkDependencyInfo*)(pDependencyInfo));
                }
                vk->vkCmdPipelineBarrier2KHR((VkCommandBuffer)dispatchHandle, pDependencyInfo);
                break;
            }
            case OP_vkCmdWriteTimestamp2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWriteTimestamp2KHR");
                VkPipelineStageFlags2 stage;
                VkQueryPool queryPool;
                uint32_t query;
                memcpy((VkPipelineStageFlags2*)&stage, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags2));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdWriteTimestamp2KHR((VkCommandBuffer)dispatchHandle, stage, queryPool,
                                            query);
                break;
            }
            case OP_vkCmdWriteBufferMarker2AMD: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdWriteBufferMarker2AMD");
                VkPipelineStageFlags2 stage;
                VkBuffer dstBuffer;
                VkDeviceSize dstOffset;
                uint32_t marker;
                memcpy((VkPipelineStageFlags2*)&stage, *readStreamPtrPtr,
                       sizeof(VkPipelineStageFlags2));
                *readStreamPtrPtr += sizeof(VkPipelineStageFlags2);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&dstBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&dstOffset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&marker, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdWriteBufferMarker2AMD((VkCommandBuffer)dispatchHandle, stage, dstBuffer,
                                               dstOffset, marker);
                break;
            }
#endif
#ifdef VK_KHR_copy_commands2
            case OP_vkCmdCopyBuffer2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyBuffer2KHR");
                const VkCopyBufferInfo2* pCopyBufferInfo;
                VkCopyBufferInfo2 stack_pCopyBufferInfo[1];
                pCopyBufferInfo = (VkCopyBufferInfo2*)stack_pCopyBufferInfo;
                reservedunmarshal_VkCopyBufferInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                    (VkCopyBufferInfo2*)(pCopyBufferInfo),
                                                    readStreamPtrPtr);
                if (pCopyBufferInfo) {
                    transform_tohost_VkCopyBufferInfo2(globalstate,
                                                       (VkCopyBufferInfo2*)(pCopyBufferInfo));
                }
                vk->vkCmdCopyBuffer2KHR((VkCommandBuffer)dispatchHandle, pCopyBufferInfo);
                break;
            }
            case OP_vkCmdCopyImage2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyImage2KHR");
                const VkCopyImageInfo2* pCopyImageInfo;
                VkCopyImageInfo2 stack_pCopyImageInfo[1];
                pCopyImageInfo = (VkCopyImageInfo2*)stack_pCopyImageInfo;
                reservedunmarshal_VkCopyImageInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkCopyImageInfo2*)(pCopyImageInfo),
                                                   readStreamPtrPtr);
                if (pCopyImageInfo) {
                    transform_tohost_VkCopyImageInfo2(globalstate,
                                                      (VkCopyImageInfo2*)(pCopyImageInfo));
                }
                this->on_vkCmdCopyImage2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                            pCopyImageInfo);
                break;
            }
            case OP_vkCmdCopyBufferToImage2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyBufferToImage2KHR");
                const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo;
                VkCopyBufferToImageInfo2 stack_pCopyBufferToImageInfo[1];
                pCopyBufferToImageInfo = (VkCopyBufferToImageInfo2*)stack_pCopyBufferToImageInfo;
                reservedunmarshal_VkCopyBufferToImageInfo2(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkCopyBufferToImageInfo2*)(pCopyBufferToImageInfo), readStreamPtrPtr);
                if (pCopyBufferToImageInfo) {
                    transform_tohost_VkCopyBufferToImageInfo2(
                        globalstate, (VkCopyBufferToImageInfo2*)(pCopyBufferToImageInfo));
                }
                this->on_vkCmdCopyBufferToImage2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                    pCopyBufferToImageInfo, context);
                break;
            }
            case OP_vkCmdCopyImageToBuffer2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdCopyImageToBuffer2KHR");
                const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo;
                VkCopyImageToBufferInfo2 stack_pCopyImageToBufferInfo[1];
                pCopyImageToBufferInfo = (VkCopyImageToBufferInfo2*)stack_pCopyImageToBufferInfo;
                reservedunmarshal_VkCopyImageToBufferInfo2(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkCopyImageToBufferInfo2*)(pCopyImageToBufferInfo), readStreamPtrPtr);
                if (pCopyImageToBufferInfo) {
                    transform_tohost_VkCopyImageToBufferInfo2(
                        globalstate, (VkCopyImageToBufferInfo2*)(pCopyImageToBufferInfo));
                }
                this->on_vkCmdCopyImageToBuffer2KHR(pool, (VkCommandBuffer)(boxed_dispatchHandle),
                                                    pCopyImageToBufferInfo);
                break;
            }
            case OP_vkCmdBlitImage2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBlitImage2KHR");
                const VkBlitImageInfo2* pBlitImageInfo;
                VkBlitImageInfo2 stack_pBlitImageInfo[1];
                pBlitImageInfo = (VkBlitImageInfo2*)stack_pBlitImageInfo;
                reservedunmarshal_VkBlitImageInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                   (VkBlitImageInfo2*)(pBlitImageInfo),
                                                   readStreamPtrPtr);
                if (pBlitImageInfo) {
                    transform_tohost_VkBlitImageInfo2(globalstate,
                                                      (VkBlitImageInfo2*)(pBlitImageInfo));
                }
                vk->vkCmdBlitImage2KHR((VkCommandBuffer)dispatchHandle, pBlitImageInfo);
                break;
            }
            case OP_vkCmdResolveImage2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdResolveImage2KHR");
                const VkResolveImageInfo2* pResolveImageInfo;
                VkResolveImageInfo2 stack_pResolveImageInfo[1];
                pResolveImageInfo = (VkResolveImageInfo2*)stack_pResolveImageInfo;
                reservedunmarshal_VkResolveImageInfo2(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                      (VkResolveImageInfo2*)(pResolveImageInfo),
                                                      readStreamPtrPtr);
                if (pResolveImageInfo) {
                    transform_tohost_VkResolveImageInfo2(globalstate,
                                                         (VkResolveImageInfo2*)(pResolveImageInfo));
                }
                vk->vkCmdResolveImage2KHR((VkCommandBuffer)dispatchHandle, pResolveImageInfo);
                break;
            }
#endif
#ifdef VK_KHR_maintenance5
            case OP_vkCmdBindIndexBuffer2KHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindIndexBuffer2KHR");
                VkBuffer buffer;
                VkDeviceSize offset;
                VkDeviceSize size;
                VkIndexType indexType;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&buffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&offset, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkDeviceSize*)&size, *readStreamPtrPtr, sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((VkIndexType*)&indexType, *readStreamPtrPtr, sizeof(VkIndexType));
                *readStreamPtrPtr += sizeof(VkIndexType);
                vk->vkCmdBindIndexBuffer2KHR((VkCommandBuffer)dispatchHandle, buffer, offset, size,
                                             indexType);
                break;
            }
#endif
#ifdef VK_EXT_transform_feedback
            case OP_vkCmdBindTransformFeedbackBuffersEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindTransformFeedbackBuffersEXT");
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                VkBuffer stack_pBuffers[MAX_STACK_ITEMS];
                const VkDeviceSize* pOffsets;
                VkDeviceSize stack_pOffsets[MAX_STACK_ITEMS];
                const VkDeviceSize* pSizes;
                VkDeviceSize stack_pSizes[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((bindingCount)) <= MAX_STACK_ITEMS) {
                    pBuffers = (VkBuffer*)stack_pBuffers;
                } else {
                    readStream->alloc((void**)&pBuffers, ((bindingCount)) * sizeof(const VkBuffer));
                }
                if (((bindingCount))) {
                    uint8_t* cgen_var_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                    *readStreamPtrPtr += 8 * ((bindingCount));
                    for (uint32_t k = 0; k < ((bindingCount)); ++k) {
                        uint64_t tmpval;
                        memcpy(&tmpval, cgen_var_0_ptr + k * 8, sizeof(uint64_t));
                        *(((VkBuffer*)pBuffers) + k) =
                            tmpval ? (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval) : VK_NULL_HANDLE;
                    }
                }
                if (((bindingCount)) <= MAX_STACK_ITEMS) {
                    pOffsets = (VkDeviceSize*)stack_pOffsets;
                } else {
                    readStream->alloc((void**)&pOffsets,
                                      ((bindingCount)) * sizeof(const VkDeviceSize));
                }
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr,
                       ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pSizes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSizes);
                *readStreamPtrPtr += 8;
                if (pSizes) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pSizes = (VkDeviceSize*)stack_pSizes;
                    } else {
                        readStream->alloc((void**)&pSizes,
                                          ((bindingCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pSizes, *readStreamPtrPtr,
                           ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                vk->vkCmdBindTransformFeedbackBuffersEXT((VkCommandBuffer)dispatchHandle,
                                                         firstBinding, bindingCount, pBuffers,
                                                         pOffsets, pSizes);
                break;
            }
            case OP_vkCmdBeginTransformFeedbackEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginTransformFeedbackEXT");
                uint32_t firstCounterBuffer;
                uint32_t counterBufferCount;
                const VkBuffer* pCounterBuffers;
                VkBuffer stack_pCounterBuffers[MAX_STACK_ITEMS];
                const VkDeviceSize* pCounterBufferOffsets;
                VkDeviceSize stack_pCounterBufferOffsets[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstCounterBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&counterBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkBuffer**)&pCounterBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBuffers);
                *readStreamPtrPtr += 8;
                if (pCounterBuffers) {
                    if (((counterBufferCount)) <= MAX_STACK_ITEMS) {
                        pCounterBuffers = (VkBuffer*)stack_pCounterBuffers;
                    } else {
                        readStream->alloc((void**)&pCounterBuffers,
                                          ((counterBufferCount)) * sizeof(const VkBuffer));
                    }
                    if (((counterBufferCount))) {
                        uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((counterBufferCount));
                        for (uint32_t k = 0; k < ((counterBufferCount)); ++k) {
                            uint64_t tmpval;
                            memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBuffer*)pCounterBuffers) + k) =
                                tmpval ? (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval)
                                       : VK_NULL_HANDLE;
                        }
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pCounterBufferOffsets, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBufferOffsets);
                *readStreamPtrPtr += 8;
                if (pCounterBufferOffsets) {
                    if (((counterBufferCount)) <= MAX_STACK_ITEMS) {
                        pCounterBufferOffsets = (VkDeviceSize*)stack_pCounterBufferOffsets;
                    } else {
                        readStream->alloc((void**)&pCounterBufferOffsets,
                                          ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pCounterBufferOffsets, *readStreamPtrPtr,
                           ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((counterBufferCount)) * sizeof(const VkDeviceSize);
                }
                vk->vkCmdBeginTransformFeedbackEXT((VkCommandBuffer)dispatchHandle,
                                                   firstCounterBuffer, counterBufferCount,
                                                   pCounterBuffers, pCounterBufferOffsets);
                break;
            }
            case OP_vkCmdEndTransformFeedbackEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndTransformFeedbackEXT");
                uint32_t firstCounterBuffer;
                uint32_t counterBufferCount;
                const VkBuffer* pCounterBuffers;
                VkBuffer stack_pCounterBuffers[MAX_STACK_ITEMS];
                const VkDeviceSize* pCounterBufferOffsets;
                VkDeviceSize stack_pCounterBufferOffsets[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstCounterBuffer, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&counterBufferCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkBuffer**)&pCounterBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBuffers);
                *readStreamPtrPtr += 8;
                if (pCounterBuffers) {
                    if (((counterBufferCount)) <= MAX_STACK_ITEMS) {
                        pCounterBuffers = (VkBuffer*)stack_pCounterBuffers;
                    } else {
                        readStream->alloc((void**)&pCounterBuffers,
                                          ((counterBufferCount)) * sizeof(const VkBuffer));
                    }
                    if (((counterBufferCount))) {
                        uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((counterBufferCount));
                        for (uint32_t k = 0; k < ((counterBufferCount)); ++k) {
                            uint64_t tmpval;
                            memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBuffer*)pCounterBuffers) + k) =
                                tmpval ? (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval)
                                       : VK_NULL_HANDLE;
                        }
                    }
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pCounterBufferOffsets, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pCounterBufferOffsets);
                *readStreamPtrPtr += 8;
                if (pCounterBufferOffsets) {
                    if (((counterBufferCount)) <= MAX_STACK_ITEMS) {
                        pCounterBufferOffsets = (VkDeviceSize*)stack_pCounterBufferOffsets;
                    } else {
                        readStream->alloc((void**)&pCounterBufferOffsets,
                                          ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pCounterBufferOffsets, *readStreamPtrPtr,
                           ((counterBufferCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((counterBufferCount)) * sizeof(const VkDeviceSize);
                }
                vk->vkCmdEndTransformFeedbackEXT((VkCommandBuffer)dispatchHandle,
                                                 firstCounterBuffer, counterBufferCount,
                                                 pCounterBuffers, pCounterBufferOffsets);
                break;
            }
            case OP_vkCmdBeginQueryIndexedEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginQueryIndexedEXT");
                VkQueryPool queryPool;
                uint32_t query;
                VkQueryControlFlags flags;
                uint32_t index;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((VkQueryControlFlags*)&flags, *readStreamPtrPtr,
                       sizeof(VkQueryControlFlags));
                *readStreamPtrPtr += sizeof(VkQueryControlFlags);
                memcpy((uint32_t*)&index, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdBeginQueryIndexedEXT((VkCommandBuffer)dispatchHandle, queryPool, query,
                                              flags, index);
                break;
            }
            case OP_vkCmdEndQueryIndexedEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndQueryIndexedEXT");
                VkQueryPool queryPool;
                uint32_t query;
                uint32_t index;
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkQueryPool*)&queryPool =
                    (VkQueryPool)unbox_VkQueryPool((VkQueryPool)(*&cgen_var_0));
                memcpy((uint32_t*)&query, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&index, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdEndQueryIndexedEXT((VkCommandBuffer)dispatchHandle, queryPool, query,
                                            index);
                break;
            }
            case OP_vkCmdDrawIndirectByteCountEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdDrawIndirectByteCountEXT");
                uint32_t instanceCount;
                uint32_t firstInstance;
                VkBuffer counterBuffer;
                VkDeviceSize counterBufferOffset;
                uint32_t counterOffset;
                uint32_t vertexStride;
                memcpy((uint32_t*)&instanceCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&firstInstance, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                uint64_t cgen_var_0;
                memcpy((uint64_t*)&cgen_var_0, *readStreamPtrPtr, 1 * 8);
                *readStreamPtrPtr += 1 * 8;
                *(VkBuffer*)&counterBuffer = (VkBuffer)unbox_VkBuffer((VkBuffer)(*&cgen_var_0));
                memcpy((VkDeviceSize*)&counterBufferOffset, *readStreamPtrPtr,
                       sizeof(VkDeviceSize));
                *readStreamPtrPtr += sizeof(VkDeviceSize);
                memcpy((uint32_t*)&counterOffset, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&vertexStride, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdDrawIndirectByteCountEXT((VkCommandBuffer)dispatchHandle, instanceCount,
                                                  firstInstance, counterBuffer, counterBufferOffset,
                                                  counterOffset, vertexStride);
                break;
            }
#endif
#ifdef VK_EXT_debug_utils
            case OP_vkCmdBeginDebugUtilsLabelEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBeginDebugUtilsLabelEXT");
                const VkDebugUtilsLabelEXT* pLabelInfo;
                VkDebugUtilsLabelEXT stack_pLabelInfo[1];
                pLabelInfo = (VkDebugUtilsLabelEXT*)stack_pLabelInfo;
                reservedunmarshal_VkDebugUtilsLabelEXT(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                       (VkDebugUtilsLabelEXT*)(pLabelInfo),
                                                       readStreamPtrPtr);
                if (pLabelInfo) {
                    transform_tohost_VkDebugUtilsLabelEXT(globalstate,
                                                          (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                vk->vkCmdBeginDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle, pLabelInfo);
                break;
            }
            case OP_vkCmdEndDebugUtilsLabelEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdEndDebugUtilsLabelEXT");
                vk->vkCmdEndDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle);
                break;
            }
            case OP_vkCmdInsertDebugUtilsLabelEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdInsertDebugUtilsLabelEXT");
                const VkDebugUtilsLabelEXT* pLabelInfo;
                VkDebugUtilsLabelEXT stack_pLabelInfo[1];
                pLabelInfo = (VkDebugUtilsLabelEXT*)stack_pLabelInfo;
                reservedunmarshal_VkDebugUtilsLabelEXT(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                       (VkDebugUtilsLabelEXT*)(pLabelInfo),
                                                       readStreamPtrPtr);
                if (pLabelInfo) {
                    transform_tohost_VkDebugUtilsLabelEXT(globalstate,
                                                          (VkDebugUtilsLabelEXT*)(pLabelInfo));
                }
                vk->vkCmdInsertDebugUtilsLabelEXT((VkCommandBuffer)dispatchHandle, pLabelInfo);
                break;
            }
#endif
#ifdef VK_EXT_line_rasterization
            case OP_vkCmdSetLineStippleEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetLineStippleEXT");
                uint32_t lineStippleFactor;
                uint16_t lineStipplePattern;
                memcpy((uint32_t*)&lineStippleFactor, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint16_t*)&lineStipplePattern, *readStreamPtrPtr, sizeof(uint16_t));
                *readStreamPtrPtr += sizeof(uint16_t);
                vk->vkCmdSetLineStippleEXT((VkCommandBuffer)dispatchHandle, lineStippleFactor,
                                           lineStipplePattern);
                break;
            }
#endif
#ifdef VK_EXT_extended_dynamic_state
            case OP_vkCmdSetCullModeEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetCullModeEXT");
                VkCullModeFlags cullMode;
                memcpy((VkCullModeFlags*)&cullMode, *readStreamPtrPtr, sizeof(VkCullModeFlags));
                *readStreamPtrPtr += sizeof(VkCullModeFlags);
                vk->vkCmdSetCullModeEXT((VkCommandBuffer)dispatchHandle, cullMode);
                break;
            }
            case OP_vkCmdSetFrontFaceEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetFrontFaceEXT");
                VkFrontFace frontFace;
                memcpy((VkFrontFace*)&frontFace, *readStreamPtrPtr, sizeof(VkFrontFace));
                *readStreamPtrPtr += sizeof(VkFrontFace);
                vk->vkCmdSetFrontFaceEXT((VkCommandBuffer)dispatchHandle, frontFace);
                break;
            }
            case OP_vkCmdSetPrimitiveTopologyEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetPrimitiveTopologyEXT");
                VkPrimitiveTopology primitiveTopology;
                memcpy((VkPrimitiveTopology*)&primitiveTopology, *readStreamPtrPtr,
                       sizeof(VkPrimitiveTopology));
                *readStreamPtrPtr += sizeof(VkPrimitiveTopology);
                vk->vkCmdSetPrimitiveTopologyEXT((VkCommandBuffer)dispatchHandle,
                                                 primitiveTopology);
                break;
            }
            case OP_vkCmdSetViewportWithCountEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetViewportWithCountEXT");
                uint32_t viewportCount;
                const VkViewport* pViewports;
                VkViewport stack_pViewports[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&viewportCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((viewportCount)) <= MAX_STACK_ITEMS) {
                    pViewports = (VkViewport*)stack_pViewports;
                } else {
                    readStream->alloc((void**)&pViewports,
                                      ((viewportCount)) * sizeof(const VkViewport));
                }
                for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i) {
                    reservedunmarshal_VkViewport(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                 (VkViewport*)(pViewports + i), readStreamPtrPtr);
                }
                if (pViewports) {
                    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i) {
                        transform_tohost_VkViewport(globalstate, (VkViewport*)(pViewports + i));
                    }
                }
                vk->vkCmdSetViewportWithCountEXT((VkCommandBuffer)dispatchHandle, viewportCount,
                                                 pViewports);
                break;
            }
            case OP_vkCmdSetScissorWithCountEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetScissorWithCountEXT");
                uint32_t scissorCount;
                const VkRect2D* pScissors;
                VkRect2D stack_pScissors[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&scissorCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((scissorCount)) <= MAX_STACK_ITEMS) {
                    pScissors = (VkRect2D*)stack_pScissors;
                } else {
                    readStream->alloc((void**)&pScissors,
                                      ((scissorCount)) * sizeof(const VkRect2D));
                }
                for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i) {
                    reservedunmarshal_VkRect2D(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                               (VkRect2D*)(pScissors + i), readStreamPtrPtr);
                }
                if (pScissors) {
                    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i) {
                        transform_tohost_VkRect2D(globalstate, (VkRect2D*)(pScissors + i));
                    }
                }
                vk->vkCmdSetScissorWithCountEXT((VkCommandBuffer)dispatchHandle, scissorCount,
                                                pScissors);
                break;
            }
            case OP_vkCmdBindVertexBuffers2EXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdBindVertexBuffers2EXT");
                uint32_t firstBinding;
                uint32_t bindingCount;
                const VkBuffer* pBuffers;
                VkBuffer stack_pBuffers[MAX_STACK_ITEMS];
                const VkDeviceSize* pOffsets;
                VkDeviceSize stack_pOffsets[MAX_STACK_ITEMS];
                const VkDeviceSize* pSizes;
                VkDeviceSize stack_pSizes[MAX_STACK_ITEMS];
                const VkDeviceSize* pStrides;
                VkDeviceSize stack_pStrides[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&firstBinding, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&bindingCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                // WARNING PTR CHECK
                memcpy((VkBuffer**)&pBuffers, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pBuffers);
                *readStreamPtrPtr += 8;
                if (pBuffers) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pBuffers = (VkBuffer*)stack_pBuffers;
                    } else {
                        readStream->alloc((void**)&pBuffers,
                                          ((bindingCount)) * sizeof(const VkBuffer));
                    }
                    if (((bindingCount))) {
                        uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*readStreamPtrPtr);
                        *readStreamPtrPtr += 8 * ((bindingCount));
                        for (uint32_t k = 0; k < ((bindingCount)); ++k) {
                            uint64_t tmpval;
                            memcpy(&tmpval, cgen_var_0_0_ptr + k * 8, sizeof(uint64_t));
                            *(((VkBuffer*)pBuffers) + k) =
                                tmpval ? (VkBuffer)unbox_VkBuffer((VkBuffer)tmpval)
                                       : VK_NULL_HANDLE;
                        }
                    }
                }
                if (((bindingCount)) <= MAX_STACK_ITEMS) {
                    pOffsets = (VkDeviceSize*)stack_pOffsets;
                } else {
                    readStream->alloc((void**)&pOffsets,
                                      ((bindingCount)) * sizeof(const VkDeviceSize));
                }
                memcpy((VkDeviceSize*)pOffsets, *readStreamPtrPtr,
                       ((bindingCount)) * sizeof(const VkDeviceSize));
                *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pSizes, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pSizes);
                *readStreamPtrPtr += 8;
                if (pSizes) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pSizes = (VkDeviceSize*)stack_pSizes;
                    } else {
                        readStream->alloc((void**)&pSizes,
                                          ((bindingCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pSizes, *readStreamPtrPtr,
                           ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                // WARNING PTR CHECK
                memcpy((VkDeviceSize**)&pStrides, (*readStreamPtrPtr), 8);
                android::base::Stream::fromBe64((uint8_t*)&pStrides);
                *readStreamPtrPtr += 8;
                if (pStrides) {
                    if (((bindingCount)) <= MAX_STACK_ITEMS) {
                        pStrides = (VkDeviceSize*)stack_pStrides;
                    } else {
                        readStream->alloc((void**)&pStrides,
                                          ((bindingCount)) * sizeof(const VkDeviceSize));
                    }
                    memcpy((VkDeviceSize*)pStrides, *readStreamPtrPtr,
                           ((bindingCount)) * sizeof(const VkDeviceSize));
                    *readStreamPtrPtr += ((bindingCount)) * sizeof(const VkDeviceSize);
                }
                vk->vkCmdBindVertexBuffers2EXT((VkCommandBuffer)dispatchHandle, firstBinding,
                                               bindingCount, pBuffers, pOffsets, pSizes, pStrides);
                break;
            }
            case OP_vkCmdSetDepthTestEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthTestEnableEXT");
                VkBool32 depthTestEnable;
                memcpy((VkBool32*)&depthTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthTestEnableEXT((VkCommandBuffer)dispatchHandle, depthTestEnable);
                break;
            }
            case OP_vkCmdSetDepthWriteEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthWriteEnableEXT");
                VkBool32 depthWriteEnable;
                memcpy((VkBool32*)&depthWriteEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthWriteEnableEXT((VkCommandBuffer)dispatchHandle, depthWriteEnable);
                break;
            }
            case OP_vkCmdSetDepthCompareOpEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthCompareOpEXT");
                VkCompareOp depthCompareOp;
                memcpy((VkCompareOp*)&depthCompareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                *readStreamPtrPtr += sizeof(VkCompareOp);
                vk->vkCmdSetDepthCompareOpEXT((VkCommandBuffer)dispatchHandle, depthCompareOp);
                break;
            }
            case OP_vkCmdSetDepthBoundsTestEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthBoundsTestEnableEXT");
                VkBool32 depthBoundsTestEnable;
                memcpy((VkBool32*)&depthBoundsTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthBoundsTestEnableEXT((VkCommandBuffer)dispatchHandle,
                                                     depthBoundsTestEnable);
                break;
            }
            case OP_vkCmdSetStencilTestEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilTestEnableEXT");
                VkBool32 stencilTestEnable;
                memcpy((VkBool32*)&stencilTestEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetStencilTestEnableEXT((VkCommandBuffer)dispatchHandle,
                                                 stencilTestEnable);
                break;
            }
            case OP_vkCmdSetStencilOpEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetStencilOpEXT");
                VkStencilFaceFlags faceMask;
                VkStencilOp failOp;
                VkStencilOp passOp;
                VkStencilOp depthFailOp;
                VkCompareOp compareOp;
                memcpy((VkStencilFaceFlags*)&faceMask, *readStreamPtrPtr,
                       sizeof(VkStencilFaceFlags));
                *readStreamPtrPtr += sizeof(VkStencilFaceFlags);
                memcpy((VkStencilOp*)&failOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkStencilOp*)&passOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkStencilOp*)&depthFailOp, *readStreamPtrPtr, sizeof(VkStencilOp));
                *readStreamPtrPtr += sizeof(VkStencilOp);
                memcpy((VkCompareOp*)&compareOp, *readStreamPtrPtr, sizeof(VkCompareOp));
                *readStreamPtrPtr += sizeof(VkCompareOp);
                vk->vkCmdSetStencilOpEXT((VkCommandBuffer)dispatchHandle, faceMask, failOp, passOp,
                                         depthFailOp, compareOp);
                break;
            }
#endif
#ifdef VK_EXT_extended_dynamic_state2
            case OP_vkCmdSetPatchControlPointsEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetPatchControlPointsEXT");
                uint32_t patchControlPoints;
                memcpy((uint32_t*)&patchControlPoints, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdSetPatchControlPointsEXT((VkCommandBuffer)dispatchHandle,
                                                  patchControlPoints);
                break;
            }
            case OP_vkCmdSetRasterizerDiscardEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetRasterizerDiscardEnableEXT");
                VkBool32 rasterizerDiscardEnable;
                memcpy((VkBool32*)&rasterizerDiscardEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetRasterizerDiscardEnableEXT((VkCommandBuffer)dispatchHandle,
                                                       rasterizerDiscardEnable);
                break;
            }
            case OP_vkCmdSetDepthBiasEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetDepthBiasEnableEXT");
                VkBool32 depthBiasEnable;
                memcpy((VkBool32*)&depthBiasEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetDepthBiasEnableEXT((VkCommandBuffer)dispatchHandle, depthBiasEnable);
                break;
            }
            case OP_vkCmdSetLogicOpEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetLogicOpEXT");
                VkLogicOp logicOp;
                memcpy((VkLogicOp*)&logicOp, *readStreamPtrPtr, sizeof(VkLogicOp));
                *readStreamPtrPtr += sizeof(VkLogicOp);
                vk->vkCmdSetLogicOpEXT((VkCommandBuffer)dispatchHandle, logicOp);
                break;
            }
            case OP_vkCmdSetPrimitiveRestartEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetPrimitiveRestartEnableEXT");
                VkBool32 primitiveRestartEnable;
                memcpy((VkBool32*)&primitiveRestartEnable, *readStreamPtrPtr, sizeof(VkBool32));
                *readStreamPtrPtr += sizeof(VkBool32);
                vk->vkCmdSetPrimitiveRestartEnableEXT((VkCommandBuffer)dispatchHandle,
                                                      primitiveRestartEnable);
                break;
            }
#endif
#ifdef VK_EXT_color_write_enable
            case OP_vkCmdSetColorWriteEnableEXT: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetColorWriteEnableEXT");
                uint32_t attachmentCount;
                const VkBool32* pColorWriteEnables;
                VkBool32 stack_pColorWriteEnables[MAX_STACK_ITEMS];
                memcpy((uint32_t*)&attachmentCount, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (((attachmentCount)) <= MAX_STACK_ITEMS) {
                    pColorWriteEnables = (VkBool32*)stack_pColorWriteEnables;
                } else {
                    readStream->alloc((void**)&pColorWriteEnables,
                                      ((attachmentCount)) * sizeof(const VkBool32));
                }
                memcpy((VkBool32*)pColorWriteEnables, *readStreamPtrPtr,
                       ((attachmentCount)) * sizeof(const VkBool32));
                *readStreamPtrPtr += ((attachmentCount)) * sizeof(const VkBool32);
                vk->vkCmdSetColorWriteEnableEXT((VkCommandBuffer)dispatchHandle, attachmentCount,
                                                pColorWriteEnables);
                break;
            }
#endif
#ifdef VK_GOOGLE_gfxstream
            case OP_vkBeginCommandBufferAsyncGOOGLE: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkBeginCommandBufferAsyncGOOGLE");
                const VkCommandBufferBeginInfo* pBeginInfo;
                VkCommandBufferBeginInfo stack_pBeginInfo[1];
                pBeginInfo = (VkCommandBufferBeginInfo*)stack_pBeginInfo;
                reservedunmarshal_VkCommandBufferBeginInfo(readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                                                           (VkCommandBufferBeginInfo*)(pBeginInfo),
                                                           readStreamPtrPtr);
                if (pBeginInfo) {
                    transform_tohost_VkCommandBufferBeginInfo(
                        globalstate, (VkCommandBufferBeginInfo*)(pBeginInfo));
                }
                this->on_vkBeginCommandBufferAsyncGOOGLE(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), pBeginInfo, context);
                break;
            }
            case OP_vkEndCommandBufferAsyncGOOGLE: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkEndCommandBufferAsyncGOOGLE");
                this->on_vkEndCommandBufferAsyncGOOGLE(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), context);
                break;
            }
            case OP_vkResetCommandBufferAsyncGOOGLE: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkResetCommandBufferAsyncGOOGLE");
                VkCommandBufferResetFlags flags;
                memcpy((VkCommandBufferResetFlags*)&flags, *readStreamPtrPtr,
                       sizeof(VkCommandBufferResetFlags));
                *readStreamPtrPtr += sizeof(VkCommandBufferResetFlags);
                this->on_vkResetCommandBufferAsyncGOOGLE(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), flags);
                break;
            }
            case OP_vkCommandBufferHostSyncGOOGLE: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCommandBufferHostSyncGOOGLE");
                uint32_t needHostSync;
                uint32_t sequenceNumber;
                memcpy((uint32_t*)&needHostSync, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&sequenceNumber, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                this->on_vkCommandBufferHostSyncGOOGLE(
                    pool, (VkCommandBuffer)(boxed_dispatchHandle), needHostSync, sequenceNumber);
                break;
            }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
            case OP_vkCmdTraceRaysKHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdTraceRaysKHR");
                const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pRaygenShaderBindingTable[1];
                const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pMissShaderBindingTable[1];
                const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pHitShaderBindingTable[1];
                const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pCallableShaderBindingTable[1];
                uint32_t width;
                uint32_t height;
                uint32_t depth;
                pRaygenShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pRaygenShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable),
                    readStreamPtrPtr);
                pMissShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pMissShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable), readStreamPtrPtr);
                pHitShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pHitShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable), readStreamPtrPtr);
                pCallableShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pCallableShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable),
                    readStreamPtrPtr);
                memcpy((uint32_t*)&width, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&height, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                memcpy((uint32_t*)&depth, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                if (pRaygenShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate, (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable));
                }
                if (pMissShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate, (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable));
                }
                if (pHitShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate, (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable));
                }
                if (pCallableShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate,
                        (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable));
                }
                vk->vkCmdTraceRaysKHR((VkCommandBuffer)dispatchHandle, pRaygenShaderBindingTable,
                                      pMissShaderBindingTable, pHitShaderBindingTable,
                                      pCallableShaderBindingTable, width, height, depth);
                break;
            }
            case OP_vkCmdTraceRaysIndirectKHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdTraceRaysIndirectKHR");
                const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pRaygenShaderBindingTable[1];
                const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pMissShaderBindingTable[1];
                const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pHitShaderBindingTable[1];
                const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
                VkStridedDeviceAddressRegionKHR stack_pCallableShaderBindingTable[1];
                VkDeviceAddress indirectDeviceAddress;
                pRaygenShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pRaygenShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable),
                    readStreamPtrPtr);
                pMissShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pMissShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable), readStreamPtrPtr);
                pHitShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pHitShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable), readStreamPtrPtr);
                pCallableShaderBindingTable =
                    (VkStridedDeviceAddressRegionKHR*)stack_pCallableShaderBindingTable;
                reservedunmarshal_VkStridedDeviceAddressRegionKHR(
                    readStream, VK_STRUCTURE_TYPE_MAX_ENUM,
                    (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable),
                    readStreamPtrPtr);
                memcpy((VkDeviceAddress*)&indirectDeviceAddress, *readStreamPtrPtr,
                       sizeof(VkDeviceAddress));
                *readStreamPtrPtr += sizeof(VkDeviceAddress);
                if (pRaygenShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate, (VkStridedDeviceAddressRegionKHR*)(pRaygenShaderBindingTable));
                }
                if (pMissShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate, (VkStridedDeviceAddressRegionKHR*)(pMissShaderBindingTable));
                }
                if (pHitShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate, (VkStridedDeviceAddressRegionKHR*)(pHitShaderBindingTable));
                }
                if (pCallableShaderBindingTable) {
                    transform_tohost_VkStridedDeviceAddressRegionKHR(
                        globalstate,
                        (VkStridedDeviceAddressRegionKHR*)(pCallableShaderBindingTable));
                }
                vk->vkCmdTraceRaysIndirectKHR((VkCommandBuffer)dispatchHandle,
                                              pRaygenShaderBindingTable, pMissShaderBindingTable,
                                              pHitShaderBindingTable, pCallableShaderBindingTable,
                                              indirectDeviceAddress);
                break;
            }
            case OP_vkCmdSetRayTracingPipelineStackSizeKHR: {
                GFXSTREAM_TRACE_EVENT(GFXSTREAM_TRACE_DECODER_CATEGORY,
                                      "VkSubDecoder vkCmdSetRayTracingPipelineStackSizeKHR");
                uint32_t pipelineStackSize;
                memcpy((uint32_t*)&pipelineStackSize, *readStreamPtrPtr, sizeof(uint32_t));
                *readStreamPtrPtr += sizeof(uint32_t);
                vk->vkCmdSetRayTracingPipelineStackSizeKHR((VkCommandBuffer)dispatchHandle,
                                                           pipelineStackSize);
                break;
            }
#endif
            default: {
                GFXSTREAM_ABORT(::emugl::FatalError(::emugl::ABORT_REASON_OTHER))
                    << "Unrecognized opcode " << opcode;
            }
        }
        ++count;
        if (count % 1000 == 0) {
            pool->freeAll();
        };
        ptr += packetLen;
    }
    pool->freeAll();
    return ptr - (unsigned char*)buf;
    ;
}
