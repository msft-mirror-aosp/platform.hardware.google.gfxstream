// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_handlemap
//
// (impl) generated by codegen/vulkan/scripts/genvk.py -registry codegen/vulkan/xml/vk.xml
// -registryGfxstream codegen/vulkan/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
//
// Please do not modify directly;
// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
// VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
//
// python3 $VULKAN_REGISTRY_SCRIPTS_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o
// $CEREAL_OUTPUT_DIR
//

#include "goldfish_vk_handlemap.h"

#include <string.h>

#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"

namespace gfxstream {
namespace vk {

void handlemap_extension_struct(VulkanHandleMapping* handlemap, void* structExtension_out);

#ifdef VK_VERSION_1_0
void handlemap_VkExtent2D(VulkanHandleMapping* handlemap, VkExtent2D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkExtent3D(VulkanHandleMapping* handlemap, VkExtent3D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkOffset2D(VulkanHandleMapping* handlemap, VkOffset2D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkOffset3D(VulkanHandleMapping* handlemap, VkOffset3D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRect2D(VulkanHandleMapping* handlemap, VkRect2D* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->offset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->extent));
}

void handlemap_VkBaseInStructure(VulkanHandleMapping* handlemap, VkBaseInStructure* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBaseOutStructure(VulkanHandleMapping* handlemap, VkBaseOutStructure* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferMemoryBarrier(VulkanHandleMapping* handlemap, VkBufferMemoryBarrier* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDispatchIndirectCommand(VulkanHandleMapping* handlemap,
                                         VkDispatchIndirectCommand* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrawIndexedIndirectCommand(VulkanHandleMapping* handlemap,
                                            VkDrawIndexedIndirectCommand* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrawIndirectCommand(VulkanHandleMapping* handlemap, VkDrawIndirectCommand* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageSubresourceRange(VulkanHandleMapping* handlemap,
                                       VkImageSubresourceRange* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageMemoryBarrier(VulkanHandleMapping* handlemap, VkImageMemoryBarrier* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkMemoryBarrier(VulkanHandleMapping* handlemap, VkMemoryBarrier* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCacheHeaderVersionOne(VulkanHandleMapping* handlemap,
                                               VkPipelineCacheHeaderVersionOne* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAllocationCallbacks(VulkanHandleMapping* handlemap, VkAllocationCallbacks* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkApplicationInfo(VulkanHandleMapping* handlemap, VkApplicationInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFormatProperties(VulkanHandleMapping* handlemap, VkFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageFormatProperties(VulkanHandleMapping* handlemap,
                                       VkImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->maxExtent));
}

void handlemap_VkInstanceCreateInfo(VulkanHandleMapping* handlemap, VkInstanceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pApplicationInfo) {
        handlemap_VkApplicationInfo(handlemap, (VkApplicationInfo*)(toMap->pApplicationInfo));
    }
}

void handlemap_VkMemoryHeap(VulkanHandleMapping* handlemap, VkMemoryHeap* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkMemoryType(VulkanHandleMapping* handlemap, VkMemoryType* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceFeatures(VulkanHandleMapping* handlemap,
                                        VkPhysicalDeviceFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceLimits(VulkanHandleMapping* handlemap,
                                      VkPhysicalDeviceLimits* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceMemoryProperties(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceMemoryProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i) {
        handlemap_VkMemoryType(handlemap, (VkMemoryType*)(toMap->memoryTypes + i));
    }
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i) {
        handlemap_VkMemoryHeap(handlemap, (VkMemoryHeap*)(toMap->memoryHeaps + i));
    }
}

void handlemap_VkPhysicalDeviceSparseProperties(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceSparseProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceProperties(VulkanHandleMapping* handlemap,
                                          VkPhysicalDeviceProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkPhysicalDeviceLimits(handlemap, (VkPhysicalDeviceLimits*)(&toMap->limits));
    handlemap_VkPhysicalDeviceSparseProperties(
        handlemap, (VkPhysicalDeviceSparseProperties*)(&toMap->sparseProperties));
}

void handlemap_VkQueueFamilyProperties(VulkanHandleMapping* handlemap,
                                       VkQueueFamilyProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->minImageTransferGranularity));
}

void handlemap_VkDeviceQueueCreateInfo(VulkanHandleMapping* handlemap,
                                       VkDeviceQueueCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceCreateInfo(VulkanHandleMapping* handlemap, VkDeviceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pQueueCreateInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->queueCreateInfoCount; ++i) {
                handlemap_VkDeviceQueueCreateInfo(
                    handlemap, (VkDeviceQueueCreateInfo*)(toMap->pQueueCreateInfos + i));
            }
        }
    }
    if (toMap->pEnabledFeatures) {
        handlemap_VkPhysicalDeviceFeatures(handlemap,
                                           (VkPhysicalDeviceFeatures*)(toMap->pEnabledFeatures));
    }
}

void handlemap_VkExtensionProperties(VulkanHandleMapping* handlemap, VkExtensionProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkLayerProperties(VulkanHandleMapping* handlemap, VkLayerProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSubmitInfo(VulkanHandleMapping* handlemap, VkSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores,
                                          toMap->waitSemaphoreCount);
    }
    if (toMap->pCommandBuffers) {
        handlemap->mapHandles_VkCommandBuffer((VkCommandBuffer*)toMap->pCommandBuffers,
                                              toMap->commandBufferCount);
    }
    if (toMap->pSignalSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSignalSemaphores,
                                          toMap->signalSemaphoreCount);
    }
}

void handlemap_VkMappedMemoryRange(VulkanHandleMapping* handlemap, VkMappedMemoryRange* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkMemoryAllocateInfo(VulkanHandleMapping* handlemap, VkMemoryAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryRequirements(VulkanHandleMapping* handlemap, VkMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSparseMemoryBind(VulkanHandleMapping* handlemap, VkSparseMemoryBind* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkSparseBufferMemoryBindInfo(VulkanHandleMapping* handlemap,
                                            VkSparseBufferMemoryBindInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
    if (toMap) {
        if (toMap->pBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i) {
                handlemap_VkSparseMemoryBind(handlemap, (VkSparseMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkSparseImageOpaqueMemoryBindInfo(VulkanHandleMapping* handlemap,
                                                 VkSparseImageOpaqueMemoryBindInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    if (toMap) {
        if (toMap->pBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i) {
                handlemap_VkSparseMemoryBind(handlemap, (VkSparseMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkImageSubresource(VulkanHandleMapping* handlemap, VkImageSubresource* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSparseImageMemoryBind(VulkanHandleMapping* handlemap,
                                       VkSparseImageMemoryBind* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresource(handlemap, (VkImageSubresource*)(&toMap->subresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->offset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkSparseImageMemoryBindInfo(VulkanHandleMapping* handlemap,
                                           VkSparseImageMemoryBindInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    if (toMap) {
        if (toMap->pBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i) {
                handlemap_VkSparseImageMemoryBind(handlemap,
                                                  (VkSparseImageMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkBindSparseInfo(VulkanHandleMapping* handlemap, VkBindSparseInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores,
                                          toMap->waitSemaphoreCount);
    }
    if (toMap) {
        if (toMap->pBufferBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bufferBindCount; ++i) {
                handlemap_VkSparseBufferMemoryBindInfo(
                    handlemap, (VkSparseBufferMemoryBindInfo*)(toMap->pBufferBinds + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pImageOpaqueBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageOpaqueBindCount; ++i) {
                handlemap_VkSparseImageOpaqueMemoryBindInfo(
                    handlemap, (VkSparseImageOpaqueMemoryBindInfo*)(toMap->pImageOpaqueBinds + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pImageBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageBindCount; ++i) {
                handlemap_VkSparseImageMemoryBindInfo(
                    handlemap, (VkSparseImageMemoryBindInfo*)(toMap->pImageBinds + i));
            }
        }
    }
    if (toMap->pSignalSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSignalSemaphores,
                                          toMap->signalSemaphoreCount);
    }
}

void handlemap_VkSparseImageFormatProperties(VulkanHandleMapping* handlemap,
                                             VkSparseImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageGranularity));
}

void handlemap_VkSparseImageMemoryRequirements(VulkanHandleMapping* handlemap,
                                               VkSparseImageMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkSparseImageFormatProperties(
        handlemap, (VkSparseImageFormatProperties*)(&toMap->formatProperties));
}

void handlemap_VkFenceCreateInfo(VulkanHandleMapping* handlemap, VkFenceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreCreateInfo(VulkanHandleMapping* handlemap, VkSemaphoreCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkEventCreateInfo(VulkanHandleMapping* handlemap, VkEventCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolCreateInfo(VulkanHandleMapping* handlemap, VkQueryPoolCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferCreateInfo(VulkanHandleMapping* handlemap, VkBufferCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferViewCreateInfo(VulkanHandleMapping* handlemap,
                                      VkBufferViewCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageCreateInfo(VulkanHandleMapping* handlemap, VkImageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkSubresourceLayout(VulkanHandleMapping* handlemap, VkSubresourceLayout* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkComponentMapping(VulkanHandleMapping* handlemap, VkComponentMapping* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageViewCreateInfo(VulkanHandleMapping* handlemap, VkImageViewCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkShaderModuleCreateInfo(VulkanHandleMapping* handlemap,
                                        VkShaderModuleCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCacheCreateInfo(VulkanHandleMapping* handlemap,
                                         VkPipelineCacheCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSpecializationMapEntry(VulkanHandleMapping* handlemap,
                                        VkSpecializationMapEntry* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSpecializationInfo(VulkanHandleMapping* handlemap, VkSpecializationInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pMapEntries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->mapEntryCount; ++i) {
                handlemap_VkSpecializationMapEntry(
                    handlemap, (VkSpecializationMapEntry*)(toMap->pMapEntries + i));
            }
        }
    }
}

void handlemap_VkPipelineShaderStageCreateInfo(VulkanHandleMapping* handlemap,
                                               VkPipelineShaderStageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkShaderModule((VkShaderModule*)&toMap->module);
    if (toMap->pSpecializationInfo) {
        handlemap_VkSpecializationInfo(handlemap,
                                       (VkSpecializationInfo*)(toMap->pSpecializationInfo));
    }
}

void handlemap_VkComputePipelineCreateInfo(VulkanHandleMapping* handlemap,
                                           VkComputePipelineCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPipelineShaderStageCreateInfo(handlemap,
                                              (VkPipelineShaderStageCreateInfo*)(&toMap->stage));
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkVertexInputBindingDescription(VulkanHandleMapping* handlemap,
                                               VkVertexInputBindingDescription* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVertexInputAttributeDescription(VulkanHandleMapping* handlemap,
                                                 VkVertexInputAttributeDescription* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineVertexInputStateCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkPipelineVertexInputStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pVertexBindingDescriptions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexBindingDescriptionCount; ++i) {
                handlemap_VkVertexInputBindingDescription(
                    handlemap,
                    (VkVertexInputBindingDescription*)(toMap->pVertexBindingDescriptions + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pVertexAttributeDescriptions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexAttributeDescriptionCount; ++i) {
                handlemap_VkVertexInputAttributeDescription(
                    handlemap,
                    (VkVertexInputAttributeDescription*)(toMap->pVertexAttributeDescriptions + i));
            }
        }
    }
}

void handlemap_VkPipelineInputAssemblyStateCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineInputAssemblyStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineTessellationStateCreateInfo(VulkanHandleMapping* handlemap,
                                                     VkPipelineTessellationStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkViewport(VulkanHandleMapping* handlemap, VkViewport* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportStateCreateInfo(VulkanHandleMapping* handlemap,
                                                 VkPipelineViewportStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pViewports) {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i) {
                handlemap_VkViewport(handlemap, (VkViewport*)(toMap->pViewports + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pScissors) {
            for (uint32_t i = 0; i < (uint32_t)toMap->scissorCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pScissors + i));
            }
        }
    }
}

void handlemap_VkPipelineRasterizationStateCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineMultisampleStateCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkPipelineMultisampleStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkStencilOpState(VulkanHandleMapping* handlemap, VkStencilOpState* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineDepthStencilStateCreateInfo(VulkanHandleMapping* handlemap,
                                                     VkPipelineDepthStencilStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkStencilOpState(handlemap, (VkStencilOpState*)(&toMap->front));
    handlemap_VkStencilOpState(handlemap, (VkStencilOpState*)(&toMap->back));
}

void handlemap_VkPipelineColorBlendAttachmentState(VulkanHandleMapping* handlemap,
                                                   VkPipelineColorBlendAttachmentState* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineColorBlendStateCreateInfo(VulkanHandleMapping* handlemap,
                                                   VkPipelineColorBlendStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i) {
                handlemap_VkPipelineColorBlendAttachmentState(
                    handlemap, (VkPipelineColorBlendAttachmentState*)(toMap->pAttachments + i));
            }
        }
    }
}

void handlemap_VkPipelineDynamicStateCreateInfo(VulkanHandleMapping* handlemap,
                                                VkPipelineDynamicStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsPipelineCreateInfo(VulkanHandleMapping* handlemap,
                                            VkGraphicsPipelineCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pStages) {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i) {
                handlemap_VkPipelineShaderStageCreateInfo(
                    handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap->pVertexInputState) {
        handlemap_VkPipelineVertexInputStateCreateInfo(
            handlemap, (VkPipelineVertexInputStateCreateInfo*)(toMap->pVertexInputState));
    }
    if (toMap->pInputAssemblyState) {
        handlemap_VkPipelineInputAssemblyStateCreateInfo(
            handlemap, (VkPipelineInputAssemblyStateCreateInfo*)(toMap->pInputAssemblyState));
    }
    if (toMap->pTessellationState) {
        handlemap_VkPipelineTessellationStateCreateInfo(
            handlemap, (VkPipelineTessellationStateCreateInfo*)(toMap->pTessellationState));
    }
    if (toMap->pViewportState) {
        handlemap_VkPipelineViewportStateCreateInfo(
            handlemap, (VkPipelineViewportStateCreateInfo*)(toMap->pViewportState));
    }
    if (toMap->pRasterizationState) {
        handlemap_VkPipelineRasterizationStateCreateInfo(
            handlemap, (VkPipelineRasterizationStateCreateInfo*)(toMap->pRasterizationState));
    }
    if (toMap->pMultisampleState) {
        handlemap_VkPipelineMultisampleStateCreateInfo(
            handlemap, (VkPipelineMultisampleStateCreateInfo*)(toMap->pMultisampleState));
    }
    if (toMap->pDepthStencilState) {
        handlemap_VkPipelineDepthStencilStateCreateInfo(
            handlemap, (VkPipelineDepthStencilStateCreateInfo*)(toMap->pDepthStencilState));
    }
    if (toMap->pColorBlendState) {
        handlemap_VkPipelineColorBlendStateCreateInfo(
            handlemap, (VkPipelineColorBlendStateCreateInfo*)(toMap->pColorBlendState));
    }
    if (toMap->pDynamicState) {
        handlemap_VkPipelineDynamicStateCreateInfo(
            handlemap, (VkPipelineDynamicStateCreateInfo*)(toMap->pDynamicState));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkPushConstantRange(VulkanHandleMapping* handlemap, VkPushConstantRange* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineLayoutCreateInfo(VulkanHandleMapping* handlemap,
                                          VkPipelineLayoutCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSetLayouts) {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts,
                                                    toMap->setLayoutCount);
    }
    if (toMap) {
        if (toMap->pPushConstantRanges) {
            for (uint32_t i = 0; i < (uint32_t)toMap->pushConstantRangeCount; ++i) {
                handlemap_VkPushConstantRange(
                    handlemap, (VkPushConstantRange*)(toMap->pPushConstantRanges + i));
            }
        }
    }
}

void handlemap_VkSamplerCreateInfo(VulkanHandleMapping* handlemap, VkSamplerCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyDescriptorSet(VulkanHandleMapping* handlemap, VkCopyDescriptorSet* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->srcSet);
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->dstSet);
}

void handlemap_VkDescriptorBufferInfo(VulkanHandleMapping* handlemap,
                                      VkDescriptorBufferInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDescriptorImageInfo(VulkanHandleMapping* handlemap, VkDescriptorImageInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkSampler((VkSampler*)&toMap->sampler);
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
}

void handlemap_VkDescriptorPoolSize(VulkanHandleMapping* handlemap, VkDescriptorPoolSize* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDescriptorPoolCreateInfo(VulkanHandleMapping* handlemap,
                                          VkDescriptorPoolCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pPoolSizes) {
            for (uint32_t i = 0; i < (uint32_t)toMap->poolSizeCount; ++i) {
                handlemap_VkDescriptorPoolSize(handlemap,
                                               (VkDescriptorPoolSize*)(toMap->pPoolSizes + i));
            }
        }
    }
}

void handlemap_VkDescriptorSetAllocateInfo(VulkanHandleMapping* handlemap,
                                           VkDescriptorSetAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorPool((VkDescriptorPool*)&toMap->descriptorPool);
    if (toMap->pSetLayouts) {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts,
                                                    toMap->descriptorSetCount);
    }
}

void handlemap_VkDescriptorSetLayoutBinding(VulkanHandleMapping* handlemap,
                                            VkDescriptorSetLayoutBinding* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pImmutableSamplers) {
        handlemap->mapHandles_VkSampler((VkSampler*)toMap->pImmutableSamplers,
                                        toMap->descriptorCount);
    }
}

void handlemap_VkDescriptorSetLayoutCreateInfo(VulkanHandleMapping* handlemap,
                                               VkDescriptorSetLayoutCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pBindings) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindingCount; ++i) {
                handlemap_VkDescriptorSetLayoutBinding(
                    handlemap, (VkDescriptorSetLayoutBinding*)(toMap->pBindings + i));
            }
        }
    }
}

void handlemap_VkWriteDescriptorSet(VulkanHandleMapping* handlemap, VkWriteDescriptorSet* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->dstSet);
    if (toMap) {
        if (toMap->pImageInfo) {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorCount; ++i) {
                handlemap_VkDescriptorImageInfo(handlemap,
                                                (VkDescriptorImageInfo*)(toMap->pImageInfo + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pBufferInfo) {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorCount; ++i) {
                handlemap_VkDescriptorBufferInfo(handlemap,
                                                 (VkDescriptorBufferInfo*)(toMap->pBufferInfo + i));
            }
        }
    }
    if (toMap->pTexelBufferView) {
        handlemap->mapHandles_VkBufferView((VkBufferView*)toMap->pTexelBufferView,
                                           toMap->descriptorCount);
    }
}

void handlemap_VkAttachmentDescription(VulkanHandleMapping* handlemap,
                                       VkAttachmentDescription* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAttachmentReference(VulkanHandleMapping* handlemap, VkAttachmentReference* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkFramebufferCreateInfo(VulkanHandleMapping* handlemap,
                                       VkFramebufferCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    if (toMap->pAttachments) {
        handlemap->mapHandles_VkImageView((VkImageView*)toMap->pAttachments,
                                          toMap->attachmentCount);
    }
}

void handlemap_VkSubpassDescription(VulkanHandleMapping* handlemap, VkSubpassDescription* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pInputAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->inputAttachmentCount; ++i) {
                handlemap_VkAttachmentReference(
                    handlemap, (VkAttachmentReference*)(toMap->pInputAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pColorAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference(
                    handlemap, (VkAttachmentReference*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pResolveAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference(
                    handlemap, (VkAttachmentReference*)(toMap->pResolveAttachments + i));
            }
        }
    }
    if (toMap->pDepthStencilAttachment) {
        handlemap_VkAttachmentReference(handlemap,
                                        (VkAttachmentReference*)(toMap->pDepthStencilAttachment));
    }
}

void handlemap_VkSubpassDependency(VulkanHandleMapping* handlemap, VkSubpassDependency* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassCreateInfo(VulkanHandleMapping* handlemap,
                                      VkRenderPassCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i) {
                handlemap_VkAttachmentDescription(
                    handlemap, (VkAttachmentDescription*)(toMap->pAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pSubpasses) {
            for (uint32_t i = 0; i < (uint32_t)toMap->subpassCount; ++i) {
                handlemap_VkSubpassDescription(handlemap,
                                               (VkSubpassDescription*)(toMap->pSubpasses + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pDependencies) {
            for (uint32_t i = 0; i < (uint32_t)toMap->dependencyCount; ++i) {
                handlemap_VkSubpassDependency(handlemap,
                                              (VkSubpassDependency*)(toMap->pDependencies + i));
            }
        }
    }
}

void handlemap_VkCommandPoolCreateInfo(VulkanHandleMapping* handlemap,
                                       VkCommandPoolCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferAllocateInfo(VulkanHandleMapping* handlemap,
                                           VkCommandBufferAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCommandPool((VkCommandPool*)&toMap->commandPool);
}

void handlemap_VkCommandBufferInheritanceInfo(VulkanHandleMapping* handlemap,
                                              VkCommandBufferInheritanceInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkFramebuffer((VkFramebuffer*)&toMap->framebuffer);
}

void handlemap_VkCommandBufferBeginInfo(VulkanHandleMapping* handlemap,
                                        VkCommandBufferBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pInheritanceInfo) {
        handlemap_VkCommandBufferInheritanceInfo(
            handlemap, (VkCommandBufferInheritanceInfo*)(toMap->pInheritanceInfo));
    }
}

void handlemap_VkBufferCopy(VulkanHandleMapping* handlemap, VkBufferCopy* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageSubresourceLayers(VulkanHandleMapping* handlemap,
                                        VkImageSubresourceLayers* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBufferImageCopy(VulkanHandleMapping* handlemap, VkBufferImageCopy* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkClearColorValue(VulkanHandleMapping* handlemap, VkClearColorValue* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkClearDepthStencilValue(VulkanHandleMapping* handlemap,
                                        VkClearDepthStencilValue* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkClearValue(VulkanHandleMapping* handlemap, VkClearValue* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkClearColorValue(handlemap, (VkClearColorValue*)(&toMap->color));
    handlemap_VkClearDepthStencilValue(handlemap,
                                       (VkClearDepthStencilValue*)(&toMap->depthStencil));
}

void handlemap_VkClearAttachment(VulkanHandleMapping* handlemap, VkClearAttachment* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkClearValue(handlemap, (VkClearValue*)(&toMap->clearValue));
}

void handlemap_VkClearRect(VulkanHandleMapping* handlemap, VkClearRect* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->rect));
}

void handlemap_VkImageBlit(VulkanHandleMapping* handlemap, VkImageBlit* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->srcOffsets + i));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->dstOffsets + i));
    }
}

void handlemap_VkImageCopy(VulkanHandleMapping* handlemap, VkImageCopy* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkImageResolve(VulkanHandleMapping* handlemap, VkImageResolve* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkRenderPassBeginInfo(VulkanHandleMapping* handlemap, VkRenderPassBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkFramebuffer((VkFramebuffer*)&toMap->framebuffer);
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
    if (toMap) {
        if (toMap->pClearValues) {
            for (uint32_t i = 0; i < (uint32_t)toMap->clearValueCount; ++i) {
                handlemap_VkClearValue(handlemap, (VkClearValue*)(toMap->pClearValues + i));
            }
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void handlemap_VkPhysicalDeviceSubgroupProperties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceSubgroupProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindBufferMemoryInfo(VulkanHandleMapping* handlemap,
                                      VkBindBufferMemoryInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkBindImageMemoryInfo(VulkanHandleMapping* handlemap, VkBindImageMemoryInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkPhysicalDevice16BitStorageFeatures(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDevice16BitStorageFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryDedicatedRequirements(VulkanHandleMapping* handlemap,
                                             VkMemoryDedicatedRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryDedicatedAllocateInfo(VulkanHandleMapping* handlemap,
                                             VkMemoryDedicatedAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkMemoryAllocateFlagsInfo(VulkanHandleMapping* handlemap,
                                         VkMemoryAllocateFlagsInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupRenderPassBeginInfo(VulkanHandleMapping* handlemap,
                                                VkDeviceGroupRenderPassBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDeviceRenderAreas) {
            for (uint32_t i = 0; i < (uint32_t)toMap->deviceRenderAreaCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pDeviceRenderAreas + i));
            }
        }
    }
}

void handlemap_VkDeviceGroupCommandBufferBeginInfo(VulkanHandleMapping* handlemap,
                                                   VkDeviceGroupCommandBufferBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupSubmitInfo(VulkanHandleMapping* handlemap,
                                       VkDeviceGroupSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupBindSparseInfo(VulkanHandleMapping* handlemap,
                                           VkDeviceGroupBindSparseInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindBufferMemoryDeviceGroupInfo(VulkanHandleMapping* handlemap,
                                                 VkBindBufferMemoryDeviceGroupInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindImageMemoryDeviceGroupInfo(VulkanHandleMapping* handlemap,
                                                VkBindImageMemoryDeviceGroupInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pSplitInstanceBindRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->splitInstanceBindRegionCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pSplitInstanceBindRegions + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceGroupProperties(VulkanHandleMapping* handlemap,
                                               VkPhysicalDeviceGroupProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)toMap->physicalDevices,
                                           VK_MAX_DEVICE_GROUP_SIZE);
}

void handlemap_VkDeviceGroupDeviceCreateInfo(VulkanHandleMapping* handlemap,
                                             VkDeviceGroupDeviceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPhysicalDevices) {
        handlemap->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)toMap->pPhysicalDevices,
                                               toMap->physicalDeviceCount);
    }
}

void handlemap_VkBufferMemoryRequirementsInfo2(VulkanHandleMapping* handlemap,
                                               VkBufferMemoryRequirementsInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageMemoryRequirementsInfo2(VulkanHandleMapping* handlemap,
                                              VkImageMemoryRequirementsInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkImageSparseMemoryRequirementsInfo2(VulkanHandleMapping* handlemap,
                                                    VkImageSparseMemoryRequirementsInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkMemoryRequirements2(VulkanHandleMapping* handlemap, VkMemoryRequirements2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkMemoryRequirements(handlemap, (VkMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkSparseImageMemoryRequirements2(VulkanHandleMapping* handlemap,
                                                VkSparseImageMemoryRequirements2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSparseImageMemoryRequirements(
        handlemap, (VkSparseImageMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkPhysicalDeviceFeatures2(VulkanHandleMapping* handlemap,
                                         VkPhysicalDeviceFeatures2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceFeatures(handlemap, (VkPhysicalDeviceFeatures*)(&toMap->features));
}

void handlemap_VkPhysicalDeviceProperties2(VulkanHandleMapping* handlemap,
                                           VkPhysicalDeviceProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceProperties(handlemap,
                                         (VkPhysicalDeviceProperties*)(&toMap->properties));
}

void handlemap_VkFormatProperties2(VulkanHandleMapping* handlemap, VkFormatProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkFormatProperties(handlemap, (VkFormatProperties*)(&toMap->formatProperties));
}

void handlemap_VkImageFormatProperties2(VulkanHandleMapping* handlemap,
                                        VkImageFormatProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageFormatProperties(handlemap,
                                      (VkImageFormatProperties*)(&toMap->imageFormatProperties));
}

void handlemap_VkPhysicalDeviceImageFormatInfo2(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceImageFormatInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueueFamilyProperties2(VulkanHandleMapping* handlemap,
                                        VkQueueFamilyProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkQueueFamilyProperties(handlemap,
                                      (VkQueueFamilyProperties*)(&toMap->queueFamilyProperties));
}

void handlemap_VkPhysicalDeviceMemoryProperties2(VulkanHandleMapping* handlemap,
                                                 VkPhysicalDeviceMemoryProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceMemoryProperties(
        handlemap, (VkPhysicalDeviceMemoryProperties*)(&toMap->memoryProperties));
}

void handlemap_VkSparseImageFormatProperties2(VulkanHandleMapping* handlemap,
                                              VkSparseImageFormatProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSparseImageFormatProperties(handlemap,
                                            (VkSparseImageFormatProperties*)(&toMap->properties));
}

void handlemap_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSparseImageFormatInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePointClippingProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePointClippingProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkInputAttachmentAspectReference(VulkanHandleMapping* handlemap,
                                                VkInputAttachmentAspectReference* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanHandleMapping* handlemap, VkRenderPassInputAttachmentAspectCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAspectReferences) {
            for (uint32_t i = 0; i < (uint32_t)toMap->aspectReferenceCount; ++i) {
                handlemap_VkInputAttachmentAspectReference(
                    handlemap, (VkInputAttachmentAspectReference*)(toMap->pAspectReferences + i));
            }
        }
    }
}

void handlemap_VkImageViewUsageCreateInfo(VulkanHandleMapping* handlemap,
                                          VkImageViewUsageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineTessellationDomainOriginStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassMultiviewCreateInfo(VulkanHandleMapping* handlemap,
                                               VkRenderPassMultiviewCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiviewFeatures(VulkanHandleMapping* handlemap,
                                                 VkPhysicalDeviceMultiviewFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiviewProperties(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDeviceMultiviewProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVariablePointersFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVariablePointersFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProtectedMemoryFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProtectedMemoryProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceQueueInfo2(VulkanHandleMapping* handlemap, VkDeviceQueueInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkProtectedSubmitInfo(VulkanHandleMapping* handlemap, VkProtectedSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerYcbcrConversionCreateInfo(VulkanHandleMapping* handlemap,
                                                  VkSamplerYcbcrConversionCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
}

void handlemap_VkSamplerYcbcrConversionInfo(VulkanHandleMapping* handlemap,
                                            VkSamplerYcbcrConversionInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&toMap->conversion);
}

void handlemap_VkBindImagePlaneMemoryInfo(VulkanHandleMapping* handlemap,
                                          VkBindImagePlaneMemoryInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImagePlaneMemoryRequirementsInfo(VulkanHandleMapping* handlemap,
                                                  VkImagePlaneMemoryRequirementsInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSamplerYcbcrConversionFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanHandleMapping* handlemap, VkSamplerYcbcrConversionImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorUpdateTemplateEntry(VulkanHandleMapping* handlemap,
                                               VkDescriptorUpdateTemplateEntry* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDescriptorUpdateTemplateCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkDescriptorUpdateTemplateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDescriptorUpdateEntries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorUpdateEntryCount; ++i) {
                handlemap_VkDescriptorUpdateTemplateEntry(
                    handlemap,
                    (VkDescriptorUpdateTemplateEntry*)(toMap->pDescriptorUpdateEntries + i));
            }
        }
    }
    handlemap->mapHandles_VkDescriptorSetLayout(
        (VkDescriptorSetLayout*)&toMap->descriptorSetLayout);
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->pipelineLayout);
}

void handlemap_VkExternalMemoryProperties(VulkanHandleMapping* handlemap,
                                          VkExternalMemoryProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExternalImageFormatInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalImageFormatProperties(VulkanHandleMapping* handlemap,
                                               VkExternalImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExternalMemoryProperties(
        handlemap, (VkExternalMemoryProperties*)(&toMap->externalMemoryProperties));
}

void handlemap_VkPhysicalDeviceExternalBufferInfo(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceExternalBufferInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalBufferProperties(VulkanHandleMapping* handlemap,
                                          VkExternalBufferProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExternalMemoryProperties(
        handlemap, (VkExternalMemoryProperties*)(&toMap->externalMemoryProperties));
}

void handlemap_VkPhysicalDeviceIDProperties(VulkanHandleMapping* handlemap,
                                            VkPhysicalDeviceIDProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalMemoryImageCreateInfo(VulkanHandleMapping* handlemap,
                                               VkExternalMemoryImageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalMemoryBufferCreateInfo(VulkanHandleMapping* handlemap,
                                                VkExternalMemoryBufferCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryAllocateInfo(VulkanHandleMapping* handlemap,
                                          VkExportMemoryAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalFenceInfo(VulkanHandleMapping* handlemap,
                                                 VkPhysicalDeviceExternalFenceInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalFenceProperties(VulkanHandleMapping* handlemap,
                                         VkExternalFenceProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportFenceCreateInfo(VulkanHandleMapping* handlemap,
                                       VkExportFenceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportSemaphoreCreateInfo(VulkanHandleMapping* handlemap,
                                           VkExportSemaphoreCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalSemaphoreInfo(VulkanHandleMapping* handlemap,
                                                     VkPhysicalDeviceExternalSemaphoreInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalSemaphoreProperties(VulkanHandleMapping* handlemap,
                                             VkExternalSemaphoreProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance3Properties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMaintenance3Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetLayoutSupport(VulkanHandleMapping* handlemap,
                                            VkDescriptorSetLayoutSupport* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderDrawParametersFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_VERSION_1_2
void handlemap_VkPhysicalDeviceVulkan11Features(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceVulkan11Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan11Properties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVulkan11Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan12Features(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceVulkan12Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkConformanceVersion(VulkanHandleMapping* handlemap, VkConformanceVersion* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceVulkan12Properties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVulkan12Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkConformanceVersion(handlemap, (VkConformanceVersion*)(&toMap->conformanceVersion));
}

void handlemap_VkImageFormatListCreateInfo(VulkanHandleMapping* handlemap,
                                           VkImageFormatListCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentDescription2(VulkanHandleMapping* handlemap,
                                        VkAttachmentDescription2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentReference2(VulkanHandleMapping* handlemap,
                                      VkAttachmentReference2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassDescription2(VulkanHandleMapping* handlemap, VkSubpassDescription2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pInputAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->inputAttachmentCount; ++i) {
                handlemap_VkAttachmentReference2(
                    handlemap, (VkAttachmentReference2*)(toMap->pInputAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pColorAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference2(
                    handlemap, (VkAttachmentReference2*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pResolveAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference2(
                    handlemap, (VkAttachmentReference2*)(toMap->pResolveAttachments + i));
            }
        }
    }
    if (toMap->pDepthStencilAttachment) {
        handlemap_VkAttachmentReference2(handlemap,
                                         (VkAttachmentReference2*)(toMap->pDepthStencilAttachment));
    }
}

void handlemap_VkSubpassDependency2(VulkanHandleMapping* handlemap, VkSubpassDependency2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassCreateInfo2(VulkanHandleMapping* handlemap,
                                       VkRenderPassCreateInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i) {
                handlemap_VkAttachmentDescription2(
                    handlemap, (VkAttachmentDescription2*)(toMap->pAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pSubpasses) {
            for (uint32_t i = 0; i < (uint32_t)toMap->subpassCount; ++i) {
                handlemap_VkSubpassDescription2(handlemap,
                                                (VkSubpassDescription2*)(toMap->pSubpasses + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pDependencies) {
            for (uint32_t i = 0; i < (uint32_t)toMap->dependencyCount; ++i) {
                handlemap_VkSubpassDependency2(handlemap,
                                               (VkSubpassDependency2*)(toMap->pDependencies + i));
            }
        }
    }
}

void handlemap_VkSubpassBeginInfo(VulkanHandleMapping* handlemap, VkSubpassBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassEndInfo(VulkanHandleMapping* handlemap, VkSubpassEndInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevice8BitStorageFeatures(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDevice8BitStorageFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDriverProperties(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceDriverProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkConformanceVersion(handlemap, (VkConformanceVersion*)(&toMap->conformanceVersion));
}

void handlemap_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderAtomicInt64Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderFloat16Int8Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFloatControlsProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFloatControlsProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanHandleMapping* handlemap, VkDescriptorSetLayoutBindingFlagsCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorIndexingFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorIndexingProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanHandleMapping* handlemap, VkDescriptorSetVariableDescriptorCountAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanHandleMapping* handlemap, VkDescriptorSetVariableDescriptorCountLayoutSupport* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassDescriptionDepthStencilResolve(
    VulkanHandleMapping* handlemap, VkSubpassDescriptionDepthStencilResolve* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pDepthStencilResolveAttachment) {
        handlemap_VkAttachmentReference2(
            handlemap, (VkAttachmentReference2*)(toMap->pDepthStencilResolveAttachment));
    }
}

void handlemap_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDepthStencilResolveProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceScalarBlockLayoutFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageStencilUsageCreateInfo(VulkanHandleMapping* handlemap,
                                             VkImageStencilUsageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerReductionModeCreateInfo(VulkanHandleMapping* handlemap,
                                                VkSamplerReductionModeCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSamplerFilterMinmaxProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVulkanMemoryModelFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImagelessFramebufferFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferAttachmentImageInfo(VulkanHandleMapping* handlemap,
                                                VkFramebufferAttachmentImageInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferAttachmentsCreateInfo(VulkanHandleMapping* handlemap,
                                                  VkFramebufferAttachmentsCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachmentImageInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentImageInfoCount; ++i) {
                handlemap_VkFramebufferAttachmentImageInfo(
                    handlemap,
                    (VkFramebufferAttachmentImageInfo*)(toMap->pAttachmentImageInfos + i));
            }
        }
    }
}

void handlemap_VkRenderPassAttachmentBeginInfo(VulkanHandleMapping* handlemap,
                                               VkRenderPassAttachmentBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAttachments) {
        handlemap->mapHandles_VkImageView((VkImageView*)toMap->pAttachments,
                                          toMap->attachmentCount);
    }
}

void handlemap_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceUniformBufferStandardLayoutFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentReferenceStencilLayout(VulkanHandleMapping* handlemap,
                                                  VkAttachmentReferenceStencilLayout* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentDescriptionStencilLayout(VulkanHandleMapping* handlemap,
                                                    VkAttachmentDescriptionStencilLayout* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceHostQueryResetFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTimelineSemaphoreFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTimelineSemaphoreProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreTypeCreateInfo(VulkanHandleMapping* handlemap,
                                         VkSemaphoreTypeCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTimelineSemaphoreSubmitInfo(VulkanHandleMapping* handlemap,
                                             VkTimelineSemaphoreSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreWaitInfo(VulkanHandleMapping* handlemap, VkSemaphoreWaitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSemaphores, toMap->semaphoreCount);
    }
}

void handlemap_VkSemaphoreSignalInfo(VulkanHandleMapping* handlemap, VkSemaphoreSignalInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceBufferDeviceAddressFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferDeviceAddressInfo(VulkanHandleMapping* handlemap,
                                         VkBufferDeviceAddressInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanHandleMapping* handlemap, VkBufferOpaqueCaptureAddressCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanHandleMapping* handlemap, VkMemoryOpaqueCaptureAddressAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanHandleMapping* handlemap, VkDeviceMemoryOpaqueCaptureAddressInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_VERSION_1_3
void handlemap_VkPhysicalDeviceVulkan13Features(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceVulkan13Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan13Properties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVulkan13Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCreationFeedback(VulkanHandleMapping* handlemap,
                                          VkPipelineCreationFeedback* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineCreationFeedbackCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkPipelineCreationFeedbackCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPipelineCreationFeedback) {
        handlemap_VkPipelineCreationFeedback(
            handlemap, (VkPipelineCreationFeedback*)(toMap->pPipelineCreationFeedback));
    }
    if (toMap) {
        if (toMap->pPipelineStageCreationFeedbacks) {
            for (uint32_t i = 0; i < (uint32_t)toMap->pipelineStageCreationFeedbackCount; ++i) {
                handlemap_VkPipelineCreationFeedback(
                    handlemap,
                    (VkPipelineCreationFeedback*)(toMap->pPipelineStageCreationFeedbacks + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceShaderTerminateInvocationFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderTerminateInvocationFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceToolProperties(VulkanHandleMapping* handlemap,
                                              VkPhysicalDeviceToolProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePrivateDataFeatures(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDevicePrivateDataFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDevicePrivateDataCreateInfo(VulkanHandleMapping* handlemap,
                                             VkDevicePrivateDataCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPrivateDataSlotCreateInfo(VulkanHandleMapping* handlemap,
                                           VkPrivateDataSlotCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePipelineCreationCacheControlFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelineCreationCacheControlFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryBarrier2(VulkanHandleMapping* handlemap, VkMemoryBarrier2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferMemoryBarrier2(VulkanHandleMapping* handlemap,
                                      VkBufferMemoryBarrier2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageMemoryBarrier2(VulkanHandleMapping* handlemap, VkImageMemoryBarrier2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkDependencyInfo(VulkanHandleMapping* handlemap, VkDependencyInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pMemoryBarriers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->memoryBarrierCount; ++i) {
                handlemap_VkMemoryBarrier2(handlemap,
                                           (VkMemoryBarrier2*)(toMap->pMemoryBarriers + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pBufferMemoryBarriers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bufferMemoryBarrierCount; ++i) {
                handlemap_VkBufferMemoryBarrier2(
                    handlemap, (VkBufferMemoryBarrier2*)(toMap->pBufferMemoryBarriers + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pImageMemoryBarriers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageMemoryBarrierCount; ++i) {
                handlemap_VkImageMemoryBarrier2(
                    handlemap, (VkImageMemoryBarrier2*)(toMap->pImageMemoryBarriers + i));
            }
        }
    }
}

void handlemap_VkSemaphoreSubmitInfo(VulkanHandleMapping* handlemap, VkSemaphoreSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkCommandBufferSubmitInfo(VulkanHandleMapping* handlemap,
                                         VkCommandBufferSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCommandBuffer((VkCommandBuffer*)&toMap->commandBuffer);
}

void handlemap_VkSubmitInfo2(VulkanHandleMapping* handlemap, VkSubmitInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pWaitSemaphoreInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->waitSemaphoreInfoCount; ++i) {
                handlemap_VkSemaphoreSubmitInfo(
                    handlemap, (VkSemaphoreSubmitInfo*)(toMap->pWaitSemaphoreInfos + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pCommandBufferInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->commandBufferInfoCount; ++i) {
                handlemap_VkCommandBufferSubmitInfo(
                    handlemap, (VkCommandBufferSubmitInfo*)(toMap->pCommandBufferInfos + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pSignalSemaphoreInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->signalSemaphoreInfoCount; ++i) {
                handlemap_VkSemaphoreSubmitInfo(
                    handlemap, (VkSemaphoreSubmitInfo*)(toMap->pSignalSemaphoreInfos + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceSynchronization2Features(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSynchronization2Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceImageRobustnessFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageRobustnessFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferCopy2(VulkanHandleMapping* handlemap, VkBufferCopy2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyBufferInfo2(VulkanHandleMapping* handlemap, VkCopyBufferInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkBufferCopy2(handlemap, (VkBufferCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageCopy2(VulkanHandleMapping* handlemap, VkImageCopy2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkCopyImageInfo2(VulkanHandleMapping* handlemap, VkCopyImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageCopy2(handlemap, (VkImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkBufferImageCopy2(VulkanHandleMapping* handlemap, VkBufferImageCopy2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkCopyBufferToImageInfo2(VulkanHandleMapping* handlemap,
                                        VkCopyBufferToImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkBufferImageCopy2(handlemap, (VkBufferImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkCopyImageToBufferInfo2(VulkanHandleMapping* handlemap,
                                        VkCopyImageToBufferInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkBufferImageCopy2(handlemap, (VkBufferImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageBlit2(VulkanHandleMapping* handlemap, VkImageBlit2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->srcOffsets + i));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->dstOffsets + i));
    }
}

void handlemap_VkBlitImageInfo2(VulkanHandleMapping* handlemap, VkBlitImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageBlit2(handlemap, (VkImageBlit2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageResolve2(VulkanHandleMapping* handlemap, VkImageResolve2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkResolveImageInfo2(VulkanHandleMapping* handlemap, VkResolveImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageResolve2(handlemap, (VkImageResolve2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceSubgroupSizeControlFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubgroupSizeControlFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSubgroupSizeControlProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubgroupSizeControlProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceInlineUniformBlockFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceInlineUniformBlockFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceInlineUniformBlockProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceInlineUniformBlockProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkWriteDescriptorSetInlineUniformBlock(
    VulkanHandleMapping* handlemap, VkWriteDescriptorSetInlineUniformBlock* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorPoolInlineUniformBlockCreateInfo(
    VulkanHandleMapping* handlemap, VkDescriptorPoolInlineUniformBlockCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTextureCompressionASTCHDRFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderingAttachmentInfo(VulkanHandleMapping* handlemap,
                                         VkRenderingAttachmentInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->resolveImageView);
    handlemap_VkClearValue(handlemap, (VkClearValue*)(&toMap->clearValue));
}

void handlemap_VkRenderingInfo(VulkanHandleMapping* handlemap, VkRenderingInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
    if (toMap) {
        if (toMap->pColorAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkRenderingAttachmentInfo(
                    handlemap, (VkRenderingAttachmentInfo*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap->pDepthAttachment) {
        handlemap_VkRenderingAttachmentInfo(handlemap,
                                            (VkRenderingAttachmentInfo*)(toMap->pDepthAttachment));
    }
    if (toMap->pStencilAttachment) {
        handlemap_VkRenderingAttachmentInfo(
            handlemap, (VkRenderingAttachmentInfo*)(toMap->pStencilAttachment));
    }
}

void handlemap_VkPipelineRenderingCreateInfo(VulkanHandleMapping* handlemap,
                                             VkPipelineRenderingCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDynamicRenderingFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDynamicRenderingFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceRenderingInfo(
    VulkanHandleMapping* handlemap, VkCommandBufferInheritanceRenderingInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderIntegerDotProductFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderIntegerDotProductFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderIntegerDotProductProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderIntegerDotProductProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTexelBufferAlignmentProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTexelBufferAlignmentProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFormatProperties3(VulkanHandleMapping* handlemap, VkFormatProperties3* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance4Features(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDeviceMaintenance4Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance4Properties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMaintenance4Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceBufferMemoryRequirements(VulkanHandleMapping* handlemap,
                                                VkDeviceBufferMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pCreateInfo) {
        handlemap_VkBufferCreateInfo(handlemap, (VkBufferCreateInfo*)(toMap->pCreateInfo));
    }
}

void handlemap_VkDeviceImageMemoryRequirements(VulkanHandleMapping* handlemap,
                                               VkDeviceImageMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pCreateInfo) {
        handlemap_VkImageCreateInfo(handlemap, (VkImageCreateInfo*)(toMap->pCreateInfo));
    }
}

#endif
#ifdef VK_KHR_surface
void handlemap_VkSurfaceCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                        VkSurfaceCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->currentExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minImageExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxImageExtent));
}

void handlemap_VkSurfaceFormatKHR(VulkanHandleMapping* handlemap, VkSurfaceFormatKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_KHR_swapchain
void handlemap_VkSwapchainCreateInfoKHR(VulkanHandleMapping* handlemap,
                                        VkSwapchainCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&toMap->surface);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->imageExtent));
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->oldSwapchain);
}

void handlemap_VkPresentInfoKHR(VulkanHandleMapping* handlemap, VkPresentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores,
                                          toMap->waitSemaphoreCount);
    }
    if (toMap->pSwapchains) {
        handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)toMap->pSwapchains,
                                             toMap->swapchainCount);
    }
}

void handlemap_VkImageSwapchainCreateInfoKHR(VulkanHandleMapping* handlemap,
                                             VkImageSwapchainCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

void handlemap_VkBindImageMemorySwapchainInfoKHR(VulkanHandleMapping* handlemap,
                                                 VkBindImageMemorySwapchainInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

void handlemap_VkAcquireNextImageInfoKHR(VulkanHandleMapping* handlemap,
                                         VkAcquireNextImageInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkDeviceGroupPresentCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                                   VkDeviceGroupPresentCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupPresentInfoKHR(VulkanHandleMapping* handlemap,
                                           VkDeviceGroupPresentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupSwapchainCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                   VkDeviceGroupSwapchainCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_display
void handlemap_VkDisplayModeParametersKHR(VulkanHandleMapping* handlemap,
                                          VkDisplayModeParametersKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->visibleRegion));
}

void handlemap_VkDisplayModeCreateInfoKHR(VulkanHandleMapping* handlemap,
                                          VkDisplayModeCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayModeParametersKHR(handlemap,
                                         (VkDisplayModeParametersKHR*)(&toMap->parameters));
}

void handlemap_VkDisplayModePropertiesKHR(VulkanHandleMapping* handlemap,
                                          VkDisplayModePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)&toMap->displayMode);
    handlemap_VkDisplayModeParametersKHR(handlemap,
                                         (VkDisplayModeParametersKHR*)(&toMap->parameters));
}

void handlemap_VkDisplayPlaneCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                             VkDisplayPlaneCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->minSrcPosition));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->maxSrcPosition));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minSrcExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxSrcExtent));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->minDstPosition));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->maxDstPosition));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minDstExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxDstExtent));
}

void handlemap_VkDisplayPlanePropertiesKHR(VulkanHandleMapping* handlemap,
                                           VkDisplayPlanePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDisplayKHR((VkDisplayKHR*)&toMap->currentDisplay);
}

void handlemap_VkDisplayPropertiesKHR(VulkanHandleMapping* handlemap,
                                      VkDisplayPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDisplayKHR((VkDisplayKHR*)&toMap->display);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->physicalDimensions));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->physicalResolution));
}

void handlemap_VkDisplaySurfaceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                             VkDisplaySurfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)&toMap->displayMode);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void handlemap_VkDisplayPresentInfoKHR(VulkanHandleMapping* handlemap,
                                       VkDisplayPresentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->srcRect));
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->dstRect));
}

#endif
#ifdef VK_KHR_xlib_surface
void handlemap_VkXlibSurfaceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                          VkXlibSurfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_xcb_surface
void handlemap_VkXcbSurfaceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                         VkXcbSurfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_wayland_surface
void handlemap_VkWaylandSurfaceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                             VkWaylandSurfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_android_surface
void handlemap_VkAndroidSurfaceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                             VkAndroidSurfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_win32_surface
void handlemap_VkWin32SurfaceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                           VkWin32SurfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_video_queue
void handlemap_VkQueueFamilyQueryResultStatusPropertiesKHR(
    VulkanHandleMapping* handlemap, VkQueueFamilyQueryResultStatusPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueueFamilyVideoPropertiesKHR(VulkanHandleMapping* handlemap,
                                               VkQueueFamilyVideoPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoProfileInfoKHR(VulkanHandleMapping* handlemap, VkVideoProfileInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoProfileListInfoKHR(VulkanHandleMapping* handlemap,
                                         VkVideoProfileListInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pProfiles) {
            for (uint32_t i = 0; i < (uint32_t)toMap->profileCount; ++i) {
                handlemap_VkVideoProfileInfoKHR(handlemap,
                                                (VkVideoProfileInfoKHR*)(toMap->pProfiles + i));
            }
        }
    }
}

void handlemap_VkVideoCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                      VkVideoCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->pictureAccessGranularity));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minCodedExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxCodedExtent));
    handlemap_VkExtensionProperties(handlemap, (VkExtensionProperties*)(&toMap->stdHeaderVersion));
}

void handlemap_VkPhysicalDeviceVideoFormatInfoKHR(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVideoFormatInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoFormatPropertiesKHR(VulkanHandleMapping* handlemap,
                                          VkVideoFormatPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->componentMapping));
}

void handlemap_VkVideoPictureResourceInfoKHR(VulkanHandleMapping* handlemap,
                                             VkVideoPictureResourceInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->codedOffset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->codedExtent));
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageViewBinding);
}

void handlemap_VkVideoReferenceSlotInfoKHR(VulkanHandleMapping* handlemap,
                                           VkVideoReferenceSlotInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPictureResource) {
        handlemap_VkVideoPictureResourceInfoKHR(
            handlemap, (VkVideoPictureResourceInfoKHR*)(toMap->pPictureResource));
    }
}

void handlemap_VkVideoSessionMemoryRequirementsKHR(VulkanHandleMapping* handlemap,
                                                   VkVideoSessionMemoryRequirementsKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkMemoryRequirements(handlemap, (VkMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkBindVideoSessionMemoryInfoKHR(VulkanHandleMapping* handlemap,
                                               VkBindVideoSessionMemoryInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkVideoSessionCreateInfoKHR(VulkanHandleMapping* handlemap,
                                           VkVideoSessionCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pVideoProfile) {
        handlemap_VkVideoProfileInfoKHR(handlemap, (VkVideoProfileInfoKHR*)(toMap->pVideoProfile));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxCodedExtent));
    if (toMap->pStdHeaderVersion) {
        handlemap_VkExtensionProperties(handlemap,
                                        (VkExtensionProperties*)(toMap->pStdHeaderVersion));
    }
}

void handlemap_VkVideoSessionParametersCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                     VkVideoSessionParametersCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkVideoSessionParametersKHR(
        (VkVideoSessionParametersKHR*)&toMap->videoSessionParametersTemplate);
    handlemap->mapHandles_VkVideoSessionKHR((VkVideoSessionKHR*)&toMap->videoSession);
}

void handlemap_VkVideoSessionParametersUpdateInfoKHR(VulkanHandleMapping* handlemap,
                                                     VkVideoSessionParametersUpdateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoBeginCodingInfoKHR(VulkanHandleMapping* handlemap,
                                         VkVideoBeginCodingInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkVideoSessionKHR((VkVideoSessionKHR*)&toMap->videoSession);
    handlemap->mapHandles_VkVideoSessionParametersKHR(
        (VkVideoSessionParametersKHR*)&toMap->videoSessionParameters);
    if (toMap) {
        if (toMap->pReferenceSlots) {
            for (uint32_t i = 0; i < (uint32_t)toMap->referenceSlotCount; ++i) {
                handlemap_VkVideoReferenceSlotInfoKHR(
                    handlemap, (VkVideoReferenceSlotInfoKHR*)(toMap->pReferenceSlots + i));
            }
        }
    }
}

void handlemap_VkVideoEndCodingInfoKHR(VulkanHandleMapping* handlemap,
                                       VkVideoEndCodingInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoCodingControlInfoKHR(VulkanHandleMapping* handlemap,
                                           VkVideoCodingControlInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_video_decode_queue
void handlemap_VkVideoDecodeCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                            VkVideoDecodeCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeUsageInfoKHR(VulkanHandleMapping* handlemap,
                                         VkVideoDecodeUsageInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeInfoKHR(VulkanHandleMapping* handlemap, VkVideoDecodeInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap_VkVideoPictureResourceInfoKHR(
        handlemap, (VkVideoPictureResourceInfoKHR*)(&toMap->dstPictureResource));
    if (toMap->pSetupReferenceSlot) {
        handlemap_VkVideoReferenceSlotInfoKHR(
            handlemap, (VkVideoReferenceSlotInfoKHR*)(toMap->pSetupReferenceSlot));
    }
    if (toMap) {
        if (toMap->pReferenceSlots) {
            for (uint32_t i = 0; i < (uint32_t)toMap->referenceSlotCount; ++i) {
                handlemap_VkVideoReferenceSlotInfoKHR(
                    handlemap, (VkVideoReferenceSlotInfoKHR*)(toMap->pReferenceSlots + i));
            }
        }
    }
}

#endif
#ifdef VK_KHR_video_decode_h264
void handlemap_VkVideoDecodeH264ProfileInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoDecodeH264ProfileInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH264CapabilitiesKHR(VulkanHandleMapping* handlemap,
                                                VkVideoDecodeH264CapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->fieldOffsetGranularity));
}

void handlemap_VkVideoDecodeH264SessionParametersAddInfoKHR(
    VulkanHandleMapping* handlemap, VkVideoDecodeH264SessionParametersAddInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH264SessionParametersCreateInfoKHR(
    VulkanHandleMapping* handlemap, VkVideoDecodeH264SessionParametersCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pParametersAddInfo) {
        handlemap_VkVideoDecodeH264SessionParametersAddInfoKHR(
            handlemap, (VkVideoDecodeH264SessionParametersAddInfoKHR*)(toMap->pParametersAddInfo));
    }
}

void handlemap_VkVideoDecodeH264PictureInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoDecodeH264PictureInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH264DpbSlotInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoDecodeH264DpbSlotInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_dynamic_rendering
void handlemap_VkRenderingFragmentShadingRateAttachmentInfoKHR(
    VulkanHandleMapping* handlemap, VkRenderingFragmentShadingRateAttachmentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->shadingRateAttachmentTexelSize));
}

void handlemap_VkRenderingFragmentDensityMapAttachmentInfoEXT(
    VulkanHandleMapping* handlemap, VkRenderingFragmentDensityMapAttachmentInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
}

void handlemap_VkAttachmentSampleCountInfoAMD(VulkanHandleMapping* handlemap,
                                              VkAttachmentSampleCountInfoAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMultiviewPerViewAttributesInfoNVX(VulkanHandleMapping* handlemap,
                                                   VkMultiviewPerViewAttributesInfoNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void handlemap_VkImportMemoryWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                                VkImportMemoryWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                                VkExportMemoryWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryWin32HandlePropertiesKHR(VulkanHandleMapping* handlemap,
                                                VkMemoryWin32HandlePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                             VkMemoryGetWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_KHR_external_memory_fd
void handlemap_VkImportMemoryFdInfoKHR(VulkanHandleMapping* handlemap,
                                       VkImportMemoryFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryFdPropertiesKHR(VulkanHandleMapping* handlemap,
                                       VkMemoryFdPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetFdInfoKHR(VulkanHandleMapping* handlemap, VkMemoryGetFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void handlemap_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanHandleMapping* handlemap, VkWin32KeyedMutexAcquireReleaseInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAcquireSyncs) {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pAcquireSyncs,
                                             toMap->acquireCount);
    }
    if (toMap->pReleaseSyncs) {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pReleaseSyncs,
                                             toMap->releaseCount);
    }
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void handlemap_VkImportSemaphoreWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                                   VkImportSemaphoreWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkExportSemaphoreWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                                   VkExportSemaphoreWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkD3D12FenceSubmitInfoKHR(VulkanHandleMapping* handlemap,
                                         VkD3D12FenceSubmitInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreGetWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                                VkSemaphoreGetWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void handlemap_VkImportSemaphoreFdInfoKHR(VulkanHandleMapping* handlemap,
                                          VkImportSemaphoreFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkSemaphoreGetFdInfoKHR(VulkanHandleMapping* handlemap,
                                       VkSemaphoreGetFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

#endif
#ifdef VK_KHR_push_descriptor
void handlemap_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePushDescriptorPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void handlemap_VkRectLayerKHR(VulkanHandleMapping* handlemap, VkRectLayerKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->offset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->extent));
}

void handlemap_VkPresentRegionKHR(VulkanHandleMapping* handlemap, VkPresentRegionKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pRectangles) {
            for (uint32_t i = 0; i < (uint32_t)toMap->rectangleCount; ++i) {
                handlemap_VkRectLayerKHR(handlemap, (VkRectLayerKHR*)(toMap->pRectangles + i));
            }
        }
    }
}

void handlemap_VkPresentRegionsKHR(VulkanHandleMapping* handlemap, VkPresentRegionsKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->swapchainCount; ++i) {
                handlemap_VkPresentRegionKHR(handlemap, (VkPresentRegionKHR*)(toMap->pRegions + i));
            }
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void handlemap_VkSharedPresentSurfaceCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                                     VkSharedPresentSurfaceCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void handlemap_VkImportFenceWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                               VkImportFenceWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkExportFenceWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                               VkExportFenceWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFenceGetWin32HandleInfoKHR(VulkanHandleMapping* handlemap,
                                            VkFenceGetWin32HandleInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

#endif
#ifdef VK_KHR_external_fence_fd
void handlemap_VkImportFenceFdInfoKHR(VulkanHandleMapping* handlemap,
                                      VkImportFenceFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkFenceGetFdInfoKHR(VulkanHandleMapping* handlemap, VkFenceGetFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

#endif
#ifdef VK_KHR_performance_query
void handlemap_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePerformanceQueryFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePerformanceQueryPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceCounterKHR(VulkanHandleMapping* handlemap,
                                       VkPerformanceCounterKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceCounterDescriptionKHR(VulkanHandleMapping* handlemap,
                                                  VkPerformanceCounterDescriptionKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolPerformanceCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                   VkQueryPoolPerformanceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceCounterResultKHR(VulkanHandleMapping* handlemap,
                                             VkPerformanceCounterResultKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAcquireProfilingLockInfoKHR(VulkanHandleMapping* handlemap,
                                             VkAcquireProfilingLockInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceQuerySubmitInfoKHR(VulkanHandleMapping* handlemap,
                                               VkPerformanceQuerySubmitInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void handlemap_VkPhysicalDeviceSurfaceInfo2KHR(VulkanHandleMapping* handlemap,
                                               VkPhysicalDeviceSurfaceInfo2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&toMap->surface);
}

void handlemap_VkSurfaceCapabilities2KHR(VulkanHandleMapping* handlemap,
                                         VkSurfaceCapabilities2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSurfaceCapabilitiesKHR(handlemap,
                                       (VkSurfaceCapabilitiesKHR*)(&toMap->surfaceCapabilities));
}

void handlemap_VkSurfaceFormat2KHR(VulkanHandleMapping* handlemap, VkSurfaceFormat2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSurfaceFormatKHR(handlemap, (VkSurfaceFormatKHR*)(&toMap->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void handlemap_VkDisplayProperties2KHR(VulkanHandleMapping* handlemap,
                                       VkDisplayProperties2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayPropertiesKHR(handlemap,
                                     (VkDisplayPropertiesKHR*)(&toMap->displayProperties));
}

void handlemap_VkDisplayPlaneProperties2KHR(VulkanHandleMapping* handlemap,
                                            VkDisplayPlaneProperties2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayPlanePropertiesKHR(
        handlemap, (VkDisplayPlanePropertiesKHR*)(&toMap->displayPlaneProperties));
}

void handlemap_VkDisplayModeProperties2KHR(VulkanHandleMapping* handlemap,
                                           VkDisplayModeProperties2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayModePropertiesKHR(
        handlemap, (VkDisplayModePropertiesKHR*)(&toMap->displayModeProperties));
}

void handlemap_VkDisplayPlaneInfo2KHR(VulkanHandleMapping* handlemap,
                                      VkDisplayPlaneInfo2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDisplayModeKHR((VkDisplayModeKHR*)&toMap->mode);
}

void handlemap_VkDisplayPlaneCapabilities2KHR(VulkanHandleMapping* handlemap,
                                              VkDisplayPlaneCapabilities2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDisplayPlaneCapabilitiesKHR(handlemap,
                                            (VkDisplayPlaneCapabilitiesKHR*)(&toMap->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void handlemap_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePortabilitySubsetFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePortabilitySubsetPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void handlemap_VkPhysicalDeviceShaderClockFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderClockFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_video_decode_h265
void handlemap_VkVideoDecodeH265ProfileInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoDecodeH265ProfileInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH265CapabilitiesKHR(VulkanHandleMapping* handlemap,
                                                VkVideoDecodeH265CapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH265SessionParametersAddInfoKHR(
    VulkanHandleMapping* handlemap, VkVideoDecodeH265SessionParametersAddInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH265SessionParametersCreateInfoKHR(
    VulkanHandleMapping* handlemap, VkVideoDecodeH265SessionParametersCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pParametersAddInfo) {
        handlemap_VkVideoDecodeH265SessionParametersAddInfoKHR(
            handlemap, (VkVideoDecodeH265SessionParametersAddInfoKHR*)(toMap->pParametersAddInfo));
    }
}

void handlemap_VkVideoDecodeH265PictureInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoDecodeH265PictureInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoDecodeH265DpbSlotInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoDecodeH265DpbSlotInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_global_priority
void handlemap_VkDeviceQueueGlobalPriorityCreateInfoKHR(
    VulkanHandleMapping* handlemap, VkDeviceQueueGlobalPriorityCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueueFamilyGlobalPriorityPropertiesKHR(
    VulkanHandleMapping* handlemap, VkQueueFamilyGlobalPriorityPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_fragment_shading_rate
void handlemap_VkFragmentShadingRateAttachmentInfoKHR(
    VulkanHandleMapping* handlemap, VkFragmentShadingRateAttachmentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pFragmentShadingRateAttachment) {
        handlemap_VkAttachmentReference2(
            handlemap, (VkAttachmentReference2*)(toMap->pFragmentShadingRateAttachment));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->shadingRateAttachmentTexelSize));
}

void handlemap_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    VulkanHandleMapping* handlemap, VkPipelineFragmentShadingRateStateCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->fragmentSize));
}

void handlemap_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShadingRateFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShadingRatePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap,
                         (VkExtent2D*)(&toMap->minFragmentShadingRateAttachmentTexelSize));
    handlemap_VkExtent2D(handlemap,
                         (VkExtent2D*)(&toMap->maxFragmentShadingRateAttachmentTexelSize));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxFragmentSize));
}

void handlemap_VkPhysicalDeviceFragmentShadingRateKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShadingRateKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->fragmentSize));
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void handlemap_VkSurfaceProtectedCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                                 VkSurfaceProtectedCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_present_wait
void handlemap_VkPhysicalDevicePresentWaitFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePresentWaitFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void handlemap_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineInfoKHR(VulkanHandleMapping* handlemap, VkPipelineInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
}

void handlemap_VkPipelineExecutablePropertiesKHR(VulkanHandleMapping* handlemap,
                                                 VkPipelineExecutablePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineExecutableInfoKHR(VulkanHandleMapping* handlemap,
                                           VkPipelineExecutableInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
}

void handlemap_VkPipelineExecutableStatisticValueKHR(VulkanHandleMapping* handlemap,
                                                     VkPipelineExecutableStatisticValueKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineExecutableStatisticKHR(VulkanHandleMapping* handlemap,
                                                VkPipelineExecutableStatisticKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPipelineExecutableStatisticValueKHR(
        handlemap, (VkPipelineExecutableStatisticValueKHR*)(&toMap->value));
}

void handlemap_VkPipelineExecutableInternalRepresentationKHR(
    VulkanHandleMapping* handlemap, VkPipelineExecutableInternalRepresentationKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_map_memory2
void handlemap_VkMemoryMapInfoKHR(VulkanHandleMapping* handlemap, VkMemoryMapInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkMemoryUnmapInfoKHR(VulkanHandleMapping* handlemap, VkMemoryUnmapInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_KHR_shader_integer_dot_product
#endif
#ifdef VK_KHR_pipeline_library
void handlemap_VkPipelineLibraryCreateInfoKHR(VulkanHandleMapping* handlemap,
                                              VkPipelineLibraryCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pLibraries) {
        handlemap->mapHandles_VkPipeline((VkPipeline*)toMap->pLibraries, toMap->libraryCount);
    }
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_present_id
void handlemap_VkPresentIdKHR(VulkanHandleMapping* handlemap, VkPresentIdKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePresentIdFeaturesKHR(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDevicePresentIdFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_video_encode_queue
void handlemap_VkVideoEncodeInfoKHR(VulkanHandleMapping* handlemap, VkVideoEncodeInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    handlemap_VkVideoPictureResourceInfoKHR(
        handlemap, (VkVideoPictureResourceInfoKHR*)(&toMap->srcPictureResource));
    if (toMap->pSetupReferenceSlot) {
        handlemap_VkVideoReferenceSlotInfoKHR(
            handlemap, (VkVideoReferenceSlotInfoKHR*)(toMap->pSetupReferenceSlot));
    }
    if (toMap) {
        if (toMap->pReferenceSlots) {
            for (uint32_t i = 0; i < (uint32_t)toMap->referenceSlotCount; ++i) {
                handlemap_VkVideoReferenceSlotInfoKHR(
                    handlemap, (VkVideoReferenceSlotInfoKHR*)(toMap->pReferenceSlots + i));
            }
        }
    }
}

void handlemap_VkVideoEncodeCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                            VkVideoEncodeCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->inputImageDataFillAlignment));
}

void handlemap_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(
    VulkanHandleMapping* handlemap, VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeUsageInfoKHR(VulkanHandleMapping* handlemap,
                                         VkVideoEncodeUsageInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeRateControlLayerInfoKHR(VulkanHandleMapping* handlemap,
                                                    VkVideoEncodeRateControlLayerInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeRateControlInfoKHR(VulkanHandleMapping* handlemap,
                                               VkVideoEncodeRateControlInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pLayers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->layerCount; ++i) {
                handlemap_VkVideoEncodeRateControlLayerInfoKHR(
                    handlemap, (VkVideoEncodeRateControlLayerInfoKHR*)(toMap->pLayers + i));
            }
        }
    }
}

#endif
#ifdef VK_KHR_synchronization2
void handlemap_VkQueueFamilyCheckpointProperties2NV(VulkanHandleMapping* handlemap,
                                                    VkQueueFamilyCheckpointProperties2NV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCheckpointData2NV(VulkanHandleMapping* handlemap, VkCheckpointData2NV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_fragment_shader_barycentric
void handlemap_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
void handlemap_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_zero_initialize_workgroup_memory
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
void handlemap_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_copy_commands2
#endif
#ifdef VK_KHR_format_feature_flags2
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
void handlemap_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTraceRaysIndirectCommand2KHR(VulkanHandleMapping* handlemap,
                                              VkTraceRaysIndirectCommand2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_KHR_portability_enumeration
#endif
#ifdef VK_KHR_maintenance4
#endif
#ifdef VK_KHR_ray_tracing_position_fetch
void handlemap_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void handlemap_VkNativeBufferUsage2ANDROID(VulkanHandleMapping* handlemap,
                                           VkNativeBufferUsage2ANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkNativeBufferANDROID(VulkanHandleMapping* handlemap, VkNativeBufferANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkNativeBufferUsage2ANDROID(handlemap,
                                          (VkNativeBufferUsage2ANDROID*)(&toMap->usage2));
}

void handlemap_VkSwapchainImageCreateInfoANDROID(VulkanHandleMapping* handlemap,
                                                 VkSwapchainImageCreateInfoANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePresentationPropertiesANDROID(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePresentationPropertiesANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_debug_report
void handlemap_VkDebugReportCallbackCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                  VkDebugReportCallbackCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void handlemap_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationStateRasterizationOrderAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void handlemap_VkDebugMarkerObjectNameInfoEXT(VulkanHandleMapping* handlemap,
                                              VkDebugMarkerObjectNameInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugMarkerObjectTagInfoEXT(VulkanHandleMapping* handlemap,
                                             VkDebugMarkerObjectTagInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugMarkerMarkerInfoEXT(VulkanHandleMapping* handlemap,
                                          VkDebugMarkerMarkerInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void handlemap_VkDedicatedAllocationImageCreateInfoNV(
    VulkanHandleMapping* handlemap, VkDedicatedAllocationImageCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanHandleMapping* handlemap, VkDedicatedAllocationBufferCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanHandleMapping* handlemap, VkDedicatedAllocationMemoryAllocateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

#endif
#ifdef VK_EXT_transform_feedback
void handlemap_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTransformFeedbackFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTransformFeedbackPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationStateStreamCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NVX_binary_import
void handlemap_VkCuModuleCreateInfoNVX(VulkanHandleMapping* handlemap,
                                       VkCuModuleCreateInfoNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCuFunctionCreateInfoNVX(VulkanHandleMapping* handlemap,
                                         VkCuFunctionCreateInfoNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCuModuleNVX((VkCuModuleNVX*)&toMap->module);
}

void handlemap_VkCuLaunchInfoNVX(VulkanHandleMapping* handlemap, VkCuLaunchInfoNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCuFunctionNVX((VkCuFunctionNVX*)&toMap->function);
}

#endif
#ifdef VK_NVX_image_view_handle
void handlemap_VkImageViewHandleInfoNVX(VulkanHandleMapping* handlemap,
                                        VkImageViewHandleInfoNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap->mapHandles_VkSampler((VkSampler*)&toMap->sampler);
}

void handlemap_VkImageViewAddressPropertiesNVX(VulkanHandleMapping* handlemap,
                                               VkImageViewAddressPropertiesNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_EXT_video_encode_h264
void handlemap_VkVideoEncodeH264CapabilitiesEXT(VulkanHandleMapping* handlemap,
                                                VkVideoEncodeH264CapabilitiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH264SessionParametersAddInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH264SessionParametersAddInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH264SessionParametersCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH264SessionParametersCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pParametersAddInfo) {
        handlemap_VkVideoEncodeH264SessionParametersAddInfoEXT(
            handlemap, (VkVideoEncodeH264SessionParametersAddInfoEXT*)(toMap->pParametersAddInfo));
    }
}

void handlemap_VkVideoEncodeH264NaluSliceInfoEXT(VulkanHandleMapping* handlemap,
                                                 VkVideoEncodeH264NaluSliceInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH264VclFrameInfoEXT(VulkanHandleMapping* handlemap,
                                                VkVideoEncodeH264VclFrameInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pNaluSliceEntries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->naluSliceEntryCount; ++i) {
                handlemap_VkVideoEncodeH264NaluSliceInfoEXT(
                    handlemap, (VkVideoEncodeH264NaluSliceInfoEXT*)(toMap->pNaluSliceEntries + i));
            }
        }
    }
}

void handlemap_VkVideoEncodeH264DpbSlotInfoEXT(VulkanHandleMapping* handlemap,
                                               VkVideoEncodeH264DpbSlotInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH264ProfileInfoEXT(VulkanHandleMapping* handlemap,
                                               VkVideoEncodeH264ProfileInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH264RateControlInfoEXT(VulkanHandleMapping* handlemap,
                                                   VkVideoEncodeH264RateControlInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH264QpEXT(VulkanHandleMapping* handlemap,
                                      VkVideoEncodeH264QpEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVideoEncodeH264FrameSizeEXT(VulkanHandleMapping* handlemap,
                                             VkVideoEncodeH264FrameSizeEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVideoEncodeH264RateControlLayerInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH264RateControlLayerInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkVideoEncodeH264QpEXT(handlemap, (VkVideoEncodeH264QpEXT*)(&toMap->initialRcQp));
    handlemap_VkVideoEncodeH264QpEXT(handlemap, (VkVideoEncodeH264QpEXT*)(&toMap->minQp));
    handlemap_VkVideoEncodeH264QpEXT(handlemap, (VkVideoEncodeH264QpEXT*)(&toMap->maxQp));
    handlemap_VkVideoEncodeH264FrameSizeEXT(handlemap,
                                            (VkVideoEncodeH264FrameSizeEXT*)(&toMap->maxFrameSize));
}

#endif
#ifdef VK_EXT_video_encode_h265
void handlemap_VkVideoEncodeH265CapabilitiesEXT(VulkanHandleMapping* handlemap,
                                                VkVideoEncodeH265CapabilitiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH265SessionParametersAddInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH265SessionParametersAddInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH265SessionParametersCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH265SessionParametersCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pParametersAddInfo) {
        handlemap_VkVideoEncodeH265SessionParametersAddInfoEXT(
            handlemap, (VkVideoEncodeH265SessionParametersAddInfoEXT*)(toMap->pParametersAddInfo));
    }
}

void handlemap_VkVideoEncodeH265NaluSliceSegmentInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH265NaluSliceSegmentInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH265VclFrameInfoEXT(VulkanHandleMapping* handlemap,
                                                VkVideoEncodeH265VclFrameInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pNaluSliceSegmentEntries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->naluSliceSegmentEntryCount; ++i) {
                handlemap_VkVideoEncodeH265NaluSliceSegmentInfoEXT(
                    handlemap,
                    (VkVideoEncodeH265NaluSliceSegmentInfoEXT*)(toMap->pNaluSliceSegmentEntries +
                                                                i));
            }
        }
    }
}

void handlemap_VkVideoEncodeH265DpbSlotInfoEXT(VulkanHandleMapping* handlemap,
                                               VkVideoEncodeH265DpbSlotInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH265ProfileInfoEXT(VulkanHandleMapping* handlemap,
                                               VkVideoEncodeH265ProfileInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH265RateControlInfoEXT(VulkanHandleMapping* handlemap,
                                                   VkVideoEncodeH265RateControlInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVideoEncodeH265QpEXT(VulkanHandleMapping* handlemap,
                                      VkVideoEncodeH265QpEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVideoEncodeH265FrameSizeEXT(VulkanHandleMapping* handlemap,
                                             VkVideoEncodeH265FrameSizeEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVideoEncodeH265RateControlLayerInfoEXT(
    VulkanHandleMapping* handlemap, VkVideoEncodeH265RateControlLayerInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkVideoEncodeH265QpEXT(handlemap, (VkVideoEncodeH265QpEXT*)(&toMap->initialRcQp));
    handlemap_VkVideoEncodeH265QpEXT(handlemap, (VkVideoEncodeH265QpEXT*)(&toMap->minQp));
    handlemap_VkVideoEncodeH265QpEXT(handlemap, (VkVideoEncodeH265QpEXT*)(&toMap->maxQp));
    handlemap_VkVideoEncodeH265FrameSizeEXT(handlemap,
                                            (VkVideoEncodeH265FrameSizeEXT*)(&toMap->maxFrameSize));
}

#endif
#ifdef VK_AMD_texture_gather_bias_lod
void handlemap_VkTextureLODGatherFormatPropertiesAMD(VulkanHandleMapping* handlemap,
                                                     VkTextureLODGatherFormatPropertiesAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_info
void handlemap_VkShaderResourceUsageAMD(VulkanHandleMapping* handlemap,
                                        VkShaderResourceUsageAMD* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkShaderStatisticsInfoAMD(VulkanHandleMapping* handlemap,
                                         VkShaderStatisticsInfoAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkShaderResourceUsageAMD(handlemap,
                                       (VkShaderResourceUsageAMD*)(&toMap->resourceUsage));
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void handlemap_VkStreamDescriptorSurfaceCreateInfoGGP(
    VulkanHandleMapping* handlemap, VkStreamDescriptorSurfaceCreateInfoGGP* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_corner_sampled_image
void handlemap_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCornerSampledImageFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void handlemap_VkExternalImageFormatPropertiesNV(VulkanHandleMapping* handlemap,
                                                 VkExternalImageFormatPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageFormatProperties(handlemap,
                                      (VkImageFormatProperties*)(&toMap->imageFormatProperties));
}

#endif
#ifdef VK_NV_external_memory
void handlemap_VkExternalMemoryImageCreateInfoNV(VulkanHandleMapping* handlemap,
                                                 VkExternalMemoryImageCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryAllocateInfoNV(VulkanHandleMapping* handlemap,
                                            VkExportMemoryAllocateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_external_memory_win32
void handlemap_VkImportMemoryWin32HandleInfoNV(VulkanHandleMapping* handlemap,
                                               VkImportMemoryWin32HandleInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryWin32HandleInfoNV(VulkanHandleMapping* handlemap,
                                               VkExportMemoryWin32HandleInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void handlemap_VkWin32KeyedMutexAcquireReleaseInfoNV(VulkanHandleMapping* handlemap,
                                                     VkWin32KeyedMutexAcquireReleaseInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAcquireSyncs) {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pAcquireSyncs,
                                             toMap->acquireCount);
    }
    if (toMap->pReleaseSyncs) {
        handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)toMap->pReleaseSyncs,
                                             toMap->releaseCount);
    }
}

#endif
#ifdef VK_EXT_validation_flags
void handlemap_VkValidationFlagsEXT(VulkanHandleMapping* handlemap, VkValidationFlagsEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NN_vi_surface
void handlemap_VkViSurfaceCreateInfoNN(VulkanHandleMapping* handlemap,
                                       VkViSurfaceCreateInfoNN* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
#endif
#ifdef VK_EXT_astc_decode_mode
void handlemap_VkImageViewASTCDecodeModeEXT(VulkanHandleMapping* handlemap,
                                            VkImageViewASTCDecodeModeEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceASTCDecodeFeaturesEXT(VulkanHandleMapping* handlemap,
                                                     VkPhysicalDeviceASTCDecodeFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_robustness
void handlemap_VkPhysicalDevicePipelineRobustnessFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelineRobustnessFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePipelineRobustnessPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelineRobustnessPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRobustnessCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                 VkPipelineRobustnessCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_conditional_rendering
void handlemap_VkConditionalRenderingBeginInfoEXT(VulkanHandleMapping* handlemap,
                                                  VkConditionalRenderingBeginInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceConditionalRenderingFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanHandleMapping* handlemap, VkCommandBufferInheritanceConditionalRenderingInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void handlemap_VkViewportWScalingNV(VulkanHandleMapping* handlemap, VkViewportWScalingNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineViewportWScalingStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pViewportWScalings) {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i) {
                handlemap_VkViewportWScalingNV(
                    handlemap, (VkViewportWScalingNV*)(toMap->pViewportWScalings + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void handlemap_VkSurfaceCapabilities2EXT(VulkanHandleMapping* handlemap,
                                         VkSurfaceCapabilities2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->currentExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minImageExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxImageExtent));
}

#endif
#ifdef VK_EXT_display_control
void handlemap_VkDisplayPowerInfoEXT(VulkanHandleMapping* handlemap, VkDisplayPowerInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceEventInfoEXT(VulkanHandleMapping* handlemap, VkDeviceEventInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDisplayEventInfoEXT(VulkanHandleMapping* handlemap, VkDisplayEventInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainCounterCreateInfoEXT(VulkanHandleMapping* handlemap,
                                               VkSwapchainCounterCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_display_timing
void handlemap_VkRefreshCycleDurationGOOGLE(VulkanHandleMapping* handlemap,
                                            VkRefreshCycleDurationGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPastPresentationTimingGOOGLE(VulkanHandleMapping* handlemap,
                                              VkPastPresentationTimingGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPresentTimeGOOGLE(VulkanHandleMapping* handlemap, VkPresentTimeGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPresentTimesInfoGOOGLE(VulkanHandleMapping* handlemap,
                                        VkPresentTimesInfoGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pTimes) {
            for (uint32_t i = 0; i < (uint32_t)toMap->swapchainCount; ++i) {
                handlemap_VkPresentTimeGOOGLE(handlemap, (VkPresentTimeGOOGLE*)(toMap->pTimes + i));
            }
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void handlemap_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_viewport_swizzle
void handlemap_VkViewportSwizzleNV(VulkanHandleMapping* handlemap, VkViewportSwizzleNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineViewportSwizzleStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pViewportSwizzles) {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i) {
                handlemap_VkViewportSwizzleNV(handlemap,
                                              (VkViewportSwizzleNV*)(toMap->pViewportSwizzles + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void handlemap_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDiscardRectanglePropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineDiscardRectangleStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDiscardRectangles) {
            for (uint32_t i = 0; i < (uint32_t)toMap->discardRectangleCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pDiscardRectangles + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void handlemap_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceConservativeRasterizationPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationConservativeStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_depth_clip_enable
void handlemap_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDepthClipEnableFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationDepthClipStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void handlemap_VkXYColorEXT(VulkanHandleMapping* handlemap, VkXYColorEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkHdrMetadataEXT(VulkanHandleMapping* handlemap, VkHdrMetadataEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->displayPrimaryRed));
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->displayPrimaryGreen));
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->displayPrimaryBlue));
    handlemap_VkXYColorEXT(handlemap, (VkXYColorEXT*)(&toMap->whitePoint));
}

#endif
#ifdef VK_MVK_ios_surface
void handlemap_VkIOSSurfaceCreateInfoMVK(VulkanHandleMapping* handlemap,
                                         VkIOSSurfaceCreateInfoMVK* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_MVK_macos_surface
void handlemap_VkMacOSSurfaceCreateInfoMVK(VulkanHandleMapping* handlemap,
                                           VkMacOSSurfaceCreateInfoMVK* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void handlemap_VkDebugUtilsLabelEXT(VulkanHandleMapping* handlemap, VkDebugUtilsLabelEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugUtilsObjectNameInfoEXT(VulkanHandleMapping* handlemap,
                                             VkDebugUtilsObjectNameInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugUtilsMessengerCallbackDataEXT(VulkanHandleMapping* handlemap,
                                                    VkDebugUtilsMessengerCallbackDataEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pQueueLabels) {
            for (uint32_t i = 0; i < (uint32_t)toMap->queueLabelCount; ++i) {
                handlemap_VkDebugUtilsLabelEXT(handlemap,
                                               (VkDebugUtilsLabelEXT*)(toMap->pQueueLabels + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pCmdBufLabels) {
            for (uint32_t i = 0; i < (uint32_t)toMap->cmdBufLabelCount; ++i) {
                handlemap_VkDebugUtilsLabelEXT(handlemap,
                                               (VkDebugUtilsLabelEXT*)(toMap->pCmdBufLabels + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pObjects) {
            for (uint32_t i = 0; i < (uint32_t)toMap->objectCount; ++i) {
                handlemap_VkDebugUtilsObjectNameInfoEXT(
                    handlemap, (VkDebugUtilsObjectNameInfoEXT*)(toMap->pObjects + i));
            }
        }
    }
}

void handlemap_VkDebugUtilsMessengerCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                  VkDebugUtilsMessengerCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDebugUtilsObjectTagInfoEXT(VulkanHandleMapping* handlemap,
                                            VkDebugUtilsObjectTagInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void handlemap_VkAndroidHardwareBufferUsageANDROID(VulkanHandleMapping* handlemap,
                                                   VkAndroidHardwareBufferUsageANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanHandleMapping* handlemap, VkAndroidHardwareBufferPropertiesANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanHandleMapping* handlemap, VkAndroidHardwareBufferFormatPropertiesANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap,
                                 (VkComponentMapping*)(&toMap->samplerYcbcrConversionComponents));
}

void handlemap_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanHandleMapping* handlemap, VkImportAndroidHardwareBufferInfoANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanHandleMapping* handlemap, VkMemoryGetAndroidHardwareBufferInfoANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkExternalFormatANDROID(VulkanHandleMapping* handlemap,
                                       VkExternalFormatANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAndroidHardwareBufferFormatProperties2ANDROID(
    VulkanHandleMapping* handlemap, VkAndroidHardwareBufferFormatProperties2ANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap,
                                 (VkComponentMapping*)(&toMap->samplerYcbcrConversionComponents));
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void handlemap_VkSampleLocationEXT(VulkanHandleMapping* handlemap, VkSampleLocationEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSampleLocationsInfoEXT(VulkanHandleMapping* handlemap,
                                        VkSampleLocationsInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->sampleLocationGridSize));
    if (toMap) {
        if (toMap->pSampleLocations) {
            for (uint32_t i = 0; i < (uint32_t)toMap->sampleLocationsCount; ++i) {
                handlemap_VkSampleLocationEXT(handlemap,
                                              (VkSampleLocationEXT*)(toMap->pSampleLocations + i));
            }
        }
    }
}

void handlemap_VkAttachmentSampleLocationsEXT(VulkanHandleMapping* handlemap,
                                              VkAttachmentSampleLocationsEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkSampleLocationsInfoEXT(handlemap,
                                       (VkSampleLocationsInfoEXT*)(&toMap->sampleLocationsInfo));
}

void handlemap_VkSubpassSampleLocationsEXT(VulkanHandleMapping* handlemap,
                                           VkSubpassSampleLocationsEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkSampleLocationsInfoEXT(handlemap,
                                       (VkSampleLocationsInfoEXT*)(&toMap->sampleLocationsInfo));
}

void handlemap_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanHandleMapping* handlemap, VkRenderPassSampleLocationsBeginInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachmentInitialSampleLocations) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentInitialSampleLocationsCount; ++i) {
                handlemap_VkAttachmentSampleLocationsEXT(
                    handlemap,
                    (VkAttachmentSampleLocationsEXT*)(toMap->pAttachmentInitialSampleLocations +
                                                      i));
            }
        }
    }
    if (toMap) {
        if (toMap->pPostSubpassSampleLocations) {
            for (uint32_t i = 0; i < (uint32_t)toMap->postSubpassSampleLocationsCount; ++i) {
                handlemap_VkSubpassSampleLocationsEXT(
                    handlemap,
                    (VkSubpassSampleLocationsEXT*)(toMap->pPostSubpassSampleLocations + i));
            }
        }
    }
}

void handlemap_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineSampleLocationsStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSampleLocationsInfoEXT(handlemap,
                                       (VkSampleLocationsInfoEXT*)(&toMap->sampleLocationsInfo));
}

void handlemap_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSampleLocationsPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxSampleLocationGridSize));
}

void handlemap_VkMultisamplePropertiesEXT(VulkanHandleMapping* handlemap,
                                          VkMultisamplePropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void handlemap_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineColorBlendAdvancedStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void handlemap_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineCoverageToColorStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void handlemap_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineCoverageModulationStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void handlemap_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void handlemap_VkDrmFormatModifierPropertiesEXT(VulkanHandleMapping* handlemap,
                                                VkDrmFormatModifierPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrmFormatModifierPropertiesListEXT(VulkanHandleMapping* handlemap,
                                                    VkDrmFormatModifierPropertiesListEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDrmFormatModifierProperties) {
            for (uint32_t i = 0; i < (uint32_t)toMap->drmFormatModifierCount; ++i) {
                handlemap_VkDrmFormatModifierPropertiesEXT(
                    handlemap,
                    (VkDrmFormatModifierPropertiesEXT*)(toMap->pDrmFormatModifierProperties + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageDrmFormatModifierInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageDrmFormatModifierListCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkImageDrmFormatModifierListCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkImageDrmFormatModifierExplicitCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pPlaneLayouts) {
            for (uint32_t i = 0; i < (uint32_t)toMap->drmFormatModifierPlaneCount; ++i) {
                handlemap_VkSubresourceLayout(handlemap,
                                              (VkSubresourceLayout*)(toMap->pPlaneLayouts + i));
            }
        }
    }
}

void handlemap_VkImageDrmFormatModifierPropertiesEXT(VulkanHandleMapping* handlemap,
                                                     VkImageDrmFormatModifierPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDrmFormatModifierProperties2EXT(VulkanHandleMapping* handlemap,
                                                 VkDrmFormatModifierProperties2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrmFormatModifierPropertiesList2EXT(VulkanHandleMapping* handlemap,
                                                     VkDrmFormatModifierPropertiesList2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDrmFormatModifierProperties) {
            for (uint32_t i = 0; i < (uint32_t)toMap->drmFormatModifierCount; ++i) {
                handlemap_VkDrmFormatModifierProperties2EXT(
                    handlemap,
                    (VkDrmFormatModifierProperties2EXT*)(toMap->pDrmFormatModifierProperties + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_validation_cache
void handlemap_VkValidationCacheCreateInfoEXT(VulkanHandleMapping* handlemap,
                                              VkValidationCacheCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkShaderModuleValidationCacheCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)&toMap->validationCache);
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void handlemap_VkShadingRatePaletteNV(VulkanHandleMapping* handlemap,
                                      VkShadingRatePaletteNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineViewportShadingRateImageStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pShadingRatePalettes) {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i) {
                handlemap_VkShadingRatePaletteNV(
                    handlemap, (VkShadingRatePaletteNV*)(toMap->pShadingRatePalettes + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceShadingRateImageFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShadingRateImageFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShadingRateImagePropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShadingRateImagePropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->shadingRateTexelSize));
}

void handlemap_VkCoarseSampleLocationNV(VulkanHandleMapping* handlemap,
                                        VkCoarseSampleLocationNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkCoarseSampleOrderCustomNV(VulkanHandleMapping* handlemap,
                                           VkCoarseSampleOrderCustomNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pSampleLocations) {
            for (uint32_t i = 0; i < (uint32_t)toMap->sampleLocationCount; ++i) {
                handlemap_VkCoarseSampleLocationNV(
                    handlemap, (VkCoarseSampleLocationNV*)(toMap->pSampleLocations + i));
            }
        }
    }
}

void handlemap_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pCustomSampleOrders) {
            for (uint32_t i = 0; i < (uint32_t)toMap->customSampleOrderCount; ++i) {
                handlemap_VkCoarseSampleOrderCustomNV(
                    handlemap, (VkCoarseSampleOrderCustomNV*)(toMap->pCustomSampleOrders + i));
            }
        }
    }
}

#endif
#ifdef VK_NV_ray_tracing
void handlemap_VkRayTracingShaderGroupCreateInfoNV(VulkanHandleMapping* handlemap,
                                                   VkRayTracingShaderGroupCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRayTracingPipelineCreateInfoNV(VulkanHandleMapping* handlemap,
                                                VkRayTracingPipelineCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pStages) {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i) {
                handlemap_VkPipelineShaderStageCreateInfo(
                    handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pGroups) {
            for (uint32_t i = 0; i < (uint32_t)toMap->groupCount; ++i) {
                handlemap_VkRayTracingShaderGroupCreateInfoNV(
                    handlemap, (VkRayTracingShaderGroupCreateInfoNV*)(toMap->pGroups + i));
            }
        }
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkGeometryTrianglesNV(VulkanHandleMapping* handlemap, VkGeometryTrianglesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->vertexData);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->indexData);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->transformData);
}

void handlemap_VkGeometryAABBNV(VulkanHandleMapping* handlemap, VkGeometryAABBNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->aabbData);
}

void handlemap_VkGeometryDataNV(VulkanHandleMapping* handlemap, VkGeometryDataNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkGeometryTrianglesNV(handlemap, (VkGeometryTrianglesNV*)(&toMap->triangles));
    handlemap_VkGeometryAABBNV(handlemap, (VkGeometryAABBNV*)(&toMap->aabbs));
}

void handlemap_VkGeometryNV(VulkanHandleMapping* handlemap, VkGeometryNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkGeometryDataNV(handlemap, (VkGeometryDataNV*)(&toMap->geometry));
}

void handlemap_VkAccelerationStructureInfoNV(VulkanHandleMapping* handlemap,
                                             VkAccelerationStructureInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pGeometries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->geometryCount; ++i) {
                handlemap_VkGeometryNV(handlemap, (VkGeometryNV*)(toMap->pGeometries + i));
            }
        }
    }
}

void handlemap_VkAccelerationStructureCreateInfoNV(VulkanHandleMapping* handlemap,
                                                   VkAccelerationStructureCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkAccelerationStructureInfoNV(handlemap,
                                            (VkAccelerationStructureInfoNV*)(&toMap->info));
}

void handlemap_VkBindAccelerationStructureMemoryInfoNV(
    VulkanHandleMapping* handlemap, VkBindAccelerationStructureMemoryInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureNV(
        (VkAccelerationStructureNV*)&toMap->accelerationStructure);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkWriteDescriptorSetAccelerationStructureNV(
    VulkanHandleMapping* handlemap, VkWriteDescriptorSetAccelerationStructureNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAccelerationStructures) {
        handlemap->mapHandles_VkAccelerationStructureNV(
            (VkAccelerationStructureNV*)toMap->pAccelerationStructures,
            toMap->accelerationStructureCount);
    }
}

void handlemap_VkAccelerationStructureMemoryRequirementsInfoNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureMemoryRequirementsInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureNV(
        (VkAccelerationStructureNV*)&toMap->accelerationStructure);
}

void handlemap_VkPhysicalDeviceRayTracingPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTransformMatrixKHR(VulkanHandleMapping* handlemap, VkTransformMatrixKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAabbPositionsKHR(VulkanHandleMapping* handlemap, VkAabbPositionsKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureInstanceKHR(VulkanHandleMapping* handlemap,
                                                  VkAccelerationStructureInstanceKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkTransformMatrixKHR(handlemap, (VkTransformMatrixKHR*)(&toMap->transform));
}

#endif
#ifdef VK_NV_representative_fragment_test
void handlemap_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineRepresentativeFragmentTestStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_filter_cubic
void handlemap_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageViewImageFormatInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFilterCubicImageViewImageFormatPropertiesEXT(
    VulkanHandleMapping* handlemap, VkFilterCubicImageViewImageFormatPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
void handlemap_VkImportMemoryHostPointerInfoEXT(VulkanHandleMapping* handlemap,
                                                VkImportMemoryHostPointerInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryHostPointerPropertiesEXT(VulkanHandleMapping* handlemap,
                                                VkMemoryHostPointerPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExternalMemoryHostPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void handlemap_VkPipelineCompilerControlCreateInfoAMD(
    VulkanHandleMapping* handlemap, VkPipelineCompilerControlCreateInfoAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void handlemap_VkCalibratedTimestampInfoEXT(VulkanHandleMapping* handlemap,
                                            VkCalibratedTimestampInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_core_properties
void handlemap_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderCorePropertiesAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void handlemap_VkDeviceMemoryOverallocationCreateInfoAMD(
    VulkanHandleMapping* handlemap, VkDeviceMemoryOverallocationCreateInfoAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void handlemap_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanHandleMapping* handlemap, VkVertexInputBindingDivisorDescriptionEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineVertexInputDivisorStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pVertexBindingDivisors) {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexBindingDivisorCount; ++i) {
                handlemap_VkVertexInputBindingDivisorDescriptionEXT(
                    handlemap,
                    (VkVertexInputBindingDivisorDescriptionEXT*)(toMap->pVertexBindingDivisors +
                                                                 i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GGP_frame_token
void handlemap_VkPresentFrameTokenGGP(VulkanHandleMapping* handlemap,
                                      VkPresentFrameTokenGGP* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void handlemap_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_mesh_shader
void handlemap_VkPhysicalDeviceMeshShaderFeaturesNV(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDeviceMeshShaderFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMeshShaderPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMeshShaderPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDrawMeshTasksIndirectCommandNV(VulkanHandleMapping* handlemap,
                                                VkDrawMeshTasksIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
#endif
#ifdef VK_NV_shader_image_footprint
void handlemap_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderImageFootprintFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_scissor_exclusive
void handlemap_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineViewportExclusiveScissorStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pExclusiveScissors) {
            for (uint32_t i = 0; i < (uint32_t)toMap->exclusiveScissorCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pExclusiveScissors + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExclusiveScissorFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void handlemap_VkQueueFamilyCheckpointPropertiesNV(VulkanHandleMapping* handlemap,
                                                   VkQueueFamilyCheckpointPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCheckpointDataNV(VulkanHandleMapping* handlemap, VkCheckpointDataNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void handlemap_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_INTEL_performance_query
void handlemap_VkPerformanceValueDataINTEL(VulkanHandleMapping* handlemap,
                                           VkPerformanceValueDataINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPerformanceValueINTEL(VulkanHandleMapping* handlemap,
                                       VkPerformanceValueINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkPerformanceValueDataINTEL(handlemap, (VkPerformanceValueDataINTEL*)(&toMap->data));
}

void handlemap_VkInitializePerformanceApiInfoINTEL(VulkanHandleMapping* handlemap,
                                                   VkInitializePerformanceApiInfoINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    VulkanHandleMapping* handlemap, VkQueryPoolPerformanceQueryCreateInfoINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceMarkerInfoINTEL(VulkanHandleMapping* handlemap,
                                            VkPerformanceMarkerInfoINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceStreamMarkerInfoINTEL(VulkanHandleMapping* handlemap,
                                                  VkPerformanceStreamMarkerInfoINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceOverrideInfoINTEL(VulkanHandleMapping* handlemap,
                                              VkPerformanceOverrideInfoINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPerformanceConfigurationAcquireInfoINTEL(
    VulkanHandleMapping* handlemap, VkPerformanceConfigurationAcquireInfoINTEL* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pci_bus_info
void handlemap_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePCIBusInfoPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_display_native_hdr
void handlemap_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    VulkanHandleMapping* handlemap, VkDisplayNativeHdrSurfaceCapabilitiesAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    VulkanHandleMapping* handlemap, VkSwapchainDisplayNativeHdrCreateInfoAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void handlemap_VkImagePipeSurfaceCreateInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                                   VkImagePipeSurfaceCreateInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_metal_surface
void handlemap_VkMetalSurfaceCreateInfoEXT(VulkanHandleMapping* handlemap,
                                           VkMetalSurfaceCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_fragment_density_map
void handlemap_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentDensityMapFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentDensityMapPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minFragmentDensityTexelSize));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxFragmentDensityTexelSize));
}

void handlemap_VkRenderPassFragmentDensityMapCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkRenderPassFragmentDensityMapCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkAttachmentReference(handlemap,
                                    (VkAttachmentReference*)(&toMap->fragmentDensityMapAttachment));
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_AMD_shader_core_properties2
void handlemap_VkPhysicalDeviceShaderCoreProperties2AMD(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderCoreProperties2AMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_device_coherent_memory
void handlemap_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCoherentMemoryFeaturesAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void handlemap_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_memory_budget
void handlemap_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMemoryBudgetPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_memory_priority
void handlemap_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMemoryPriorityFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryPriorityAllocateInfoEXT(VulkanHandleMapping* handlemap,
                                               VkMemoryPriorityAllocateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void handlemap_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_buffer_device_address
void handlemap_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferDeviceAddressCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                  VkBufferDeviceAddressCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_tooling_info
#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void handlemap_VkValidationFeaturesEXT(VulkanHandleMapping* handlemap,
                                       VkValidationFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_cooperative_matrix
void handlemap_VkCooperativeMatrixPropertiesNV(VulkanHandleMapping* handlemap,
                                               VkCooperativeMatrixPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCooperativeMatrixFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCooperativeMatrixPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void handlemap_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCoverageReductionModeFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCoverageReductionStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineCoverageReductionStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferMixedSamplesCombinationNV(
    VulkanHandleMapping* handlemap, VkFramebufferMixedSamplesCombinationNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void handlemap_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void handlemap_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_provoking_vertex
void handlemap_VkPhysicalDeviceProvokingVertexFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProvokingVertexFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProvokingVertexPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProvokingVertexPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void handlemap_VkSurfaceFullScreenExclusiveInfoEXT(VulkanHandleMapping* handlemap,
                                                   VkSurfaceFullScreenExclusiveInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    VulkanHandleMapping* handlemap, VkSurfaceCapabilitiesFullScreenExclusiveEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    VulkanHandleMapping* handlemap, VkSurfaceFullScreenExclusiveWin32InfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_headless_surface
void handlemap_VkHeadlessSurfaceCreateInfoEXT(VulkanHandleMapping* handlemap,
                                              VkHeadlessSurfaceCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_line_rasterization
void handlemap_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceLineRasterizationFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceLineRasterizationPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationLineStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_atomic_float
void handlemap_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void handlemap_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceIndexTypeUint8FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void handlemap_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_atomic_float2
void handlemap_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_surface_maintenance1
void handlemap_VkSurfacePresentModeEXT(VulkanHandleMapping* handlemap,
                                       VkSurfacePresentModeEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSurfacePresentScalingCapabilitiesEXT(
    VulkanHandleMapping* handlemap, VkSurfacePresentScalingCapabilitiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->minScaledImageExtent));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxScaledImageExtent));
}

void handlemap_VkSurfacePresentModeCompatibilityEXT(VulkanHandleMapping* handlemap,
                                                    VkSurfacePresentModeCompatibilityEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_swapchain_maintenance1
void handlemap_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentFenceInfoEXT(VulkanHandleMapping* handlemap,
                                              VkSwapchainPresentFenceInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pFences) {
        handlemap->mapHandles_VkFence((VkFence*)toMap->pFences, toMap->swapchainCount);
    }
}

void handlemap_VkSwapchainPresentModesCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                    VkSwapchainPresentModesCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentModeInfoEXT(VulkanHandleMapping* handlemap,
                                             VkSwapchainPresentModeInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentScalingCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkSwapchainPresentScalingCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkReleaseSwapchainImagesInfoEXT(VulkanHandleMapping* handlemap,
                                               VkReleaseSwapchainImagesInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
#endif
#ifdef VK_NV_device_generated_commands
void handlemap_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsShaderGroupCreateInfoNV(VulkanHandleMapping* handlemap,
                                                 VkGraphicsShaderGroupCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pStages) {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i) {
                handlemap_VkPipelineShaderStageCreateInfo(
                    handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap->pVertexInputState) {
        handlemap_VkPipelineVertexInputStateCreateInfo(
            handlemap, (VkPipelineVertexInputStateCreateInfo*)(toMap->pVertexInputState));
    }
    if (toMap->pTessellationState) {
        handlemap_VkPipelineTessellationStateCreateInfo(
            handlemap, (VkPipelineTessellationStateCreateInfo*)(toMap->pTessellationState));
    }
}

void handlemap_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    VulkanHandleMapping* handlemap, VkGraphicsPipelineShaderGroupsCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pGroups) {
            for (uint32_t i = 0; i < (uint32_t)toMap->groupCount; ++i) {
                handlemap_VkGraphicsShaderGroupCreateInfoNV(
                    handlemap, (VkGraphicsShaderGroupCreateInfoNV*)(toMap->pGroups + i));
            }
        }
    }
    if (toMap->pPipelines) {
        handlemap->mapHandles_VkPipeline((VkPipeline*)toMap->pPipelines, toMap->pipelineCount);
    }
}

void handlemap_VkBindShaderGroupIndirectCommandNV(VulkanHandleMapping* handlemap,
                                                  VkBindShaderGroupIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBindIndexBufferIndirectCommandNV(VulkanHandleMapping* handlemap,
                                                  VkBindIndexBufferIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBindVertexBufferIndirectCommandNV(VulkanHandleMapping* handlemap,
                                                   VkBindVertexBufferIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSetStateFlagsIndirectCommandNV(VulkanHandleMapping* handlemap,
                                                VkSetStateFlagsIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkIndirectCommandsStreamNV(VulkanHandleMapping* handlemap,
                                          VkIndirectCommandsStreamNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkIndirectCommandsLayoutTokenNV(VulkanHandleMapping* handlemap,
                                               VkIndirectCommandsLayoutTokenNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->pushconstantPipelineLayout);
}

void handlemap_VkIndirectCommandsLayoutCreateInfoNV(VulkanHandleMapping* handlemap,
                                                    VkIndirectCommandsLayoutCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pTokens) {
            for (uint32_t i = 0; i < (uint32_t)toMap->tokenCount; ++i) {
                handlemap_VkIndirectCommandsLayoutTokenNV(
                    handlemap, (VkIndirectCommandsLayoutTokenNV*)(toMap->pTokens + i));
            }
        }
    }
}

void handlemap_VkGeneratedCommandsInfoNV(VulkanHandleMapping* handlemap,
                                         VkGeneratedCommandsInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
    handlemap->mapHandles_VkIndirectCommandsLayoutNV(
        (VkIndirectCommandsLayoutNV*)&toMap->indirectCommandsLayout);
    if (toMap) {
        if (toMap->pStreams) {
            for (uint32_t i = 0; i < (uint32_t)toMap->streamCount; ++i) {
                handlemap_VkIndirectCommandsStreamNV(
                    handlemap, (VkIndirectCommandsStreamNV*)(toMap->pStreams + i));
            }
        }
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->preprocessBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->sequencesCountBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->sequencesIndexBuffer);
}

void handlemap_VkGeneratedCommandsMemoryRequirementsInfoNV(
    VulkanHandleMapping* handlemap, VkGeneratedCommandsMemoryRequirementsInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
    handlemap->mapHandles_VkIndirectCommandsLayoutNV(
        (VkIndirectCommandsLayoutNV*)&toMap->indirectCommandsLayout);
}

#endif
#ifdef VK_NV_inherited_viewport_scissor
void handlemap_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceInheritedViewportScissorFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceViewportScissorInfoNV(
    VulkanHandleMapping* handlemap, VkCommandBufferInheritanceViewportScissorInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pViewportDepths) {
        handlemap_VkViewport(handlemap, (VkViewport*)(toMap->pViewportDepths));
    }
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void handlemap_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_render_pass_transform
void handlemap_VkRenderPassTransformBeginInfoQCOM(VulkanHandleMapping* handlemap,
                                                  VkRenderPassTransformBeginInfoQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    VulkanHandleMapping* handlemap, VkCommandBufferInheritanceRenderPassTransformInfoQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
}

#endif
#ifdef VK_EXT_device_memory_report
void handlemap_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceMemoryReportCallbackDataEXT(VulkanHandleMapping* handlemap,
                                                   VkDeviceMemoryReportCallbackDataEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkDeviceDeviceMemoryReportCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_acquire_drm_display
#endif
#ifdef VK_EXT_robustness2
void handlemap_VkPhysicalDeviceRobustness2FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRobustness2FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceRobustness2PropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRobustness2PropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_custom_border_color
void handlemap_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkSamplerCustomBorderColorCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkClearColorValue(handlemap, (VkClearColorValue*)(&toMap->customBorderColor));
}

void handlemap_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCustomBorderColorPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCustomBorderColorFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_NV_present_barrier
void handlemap_VkPhysicalDevicePresentBarrierFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePresentBarrierFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSurfaceCapabilitiesPresentBarrierNV(VulkanHandleMapping* handlemap,
                                                     VkSurfaceCapabilitiesPresentBarrierNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentBarrierCreateInfoNV(VulkanHandleMapping* handlemap,
                                                     VkSwapchainPresentBarrierCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_private_data
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
#endif
#ifdef VK_NV_device_diagnostics_config
void handlemap_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDiagnosticsConfigFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceDiagnosticsConfigCreateInfoNV(VulkanHandleMapping* handlemap,
                                                     VkDeviceDiagnosticsConfigCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_low_latency
void handlemap_VkQueryLowLatencySupportNV(VulkanHandleMapping* handlemap,
                                          VkQueryLowLatencySupportNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_metal_objects
void handlemap_VkExportMetalObjectCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                VkExportMetalObjectCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMetalObjectsInfoEXT(VulkanHandleMapping* handlemap,
                                           VkExportMetalObjectsInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMetalDeviceInfoEXT(VulkanHandleMapping* handlemap,
                                          VkExportMetalDeviceInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMetalCommandQueueInfoEXT(VulkanHandleMapping* handlemap,
                                                VkExportMetalCommandQueueInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkQueue((VkQueue*)&toMap->queue);
}

void handlemap_VkExportMetalBufferInfoEXT(VulkanHandleMapping* handlemap,
                                          VkExportMetalBufferInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkImportMetalBufferInfoEXT(VulkanHandleMapping* handlemap,
                                          VkImportMetalBufferInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMetalTextureInfoEXT(VulkanHandleMapping* handlemap,
                                           VkExportMetalTextureInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap->mapHandles_VkBufferView((VkBufferView*)&toMap->bufferView);
}

void handlemap_VkImportMetalTextureInfoEXT(VulkanHandleMapping* handlemap,
                                           VkImportMetalTextureInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMetalIOSurfaceInfoEXT(VulkanHandleMapping* handlemap,
                                             VkExportMetalIOSurfaceInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkImportMetalIOSurfaceInfoEXT(VulkanHandleMapping* handlemap,
                                             VkImportMetalIOSurfaceInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMetalSharedEventInfoEXT(VulkanHandleMapping* handlemap,
                                               VkExportMetalSharedEventInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
    handlemap->mapHandles_VkEvent((VkEvent*)&toMap->event);
}

void handlemap_VkImportMetalSharedEventInfoEXT(VulkanHandleMapping* handlemap,
                                               VkImportMetalSharedEventInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_descriptor_buffer
void handlemap_VkPhysicalDeviceDescriptorBufferPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorBufferPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorBufferFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorBufferFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorAddressInfoEXT(VulkanHandleMapping* handlemap,
                                          VkDescriptorAddressInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorBufferBindingInfoEXT(VulkanHandleMapping* handlemap,
                                                VkDescriptorBufferBindingInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(
    VulkanHandleMapping* handlemap, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDescriptorDataEXT(VulkanHandleMapping* handlemap, VkDescriptorDataEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pSampler) {
        handlemap->mapHandles_VkSampler((VkSampler*)toMap->pSampler, 1);
    }
    if (toMap->pCombinedImageSampler) {
        handlemap_VkDescriptorImageInfo(handlemap,
                                        (VkDescriptorImageInfo*)(toMap->pCombinedImageSampler));
    }
    if (toMap->pInputAttachmentImage) {
        handlemap_VkDescriptorImageInfo(handlemap,
                                        (VkDescriptorImageInfo*)(toMap->pInputAttachmentImage));
    }
    if (toMap->pSampledImage) {
        handlemap_VkDescriptorImageInfo(handlemap, (VkDescriptorImageInfo*)(toMap->pSampledImage));
    }
    if (toMap->pStorageImage) {
        handlemap_VkDescriptorImageInfo(handlemap, (VkDescriptorImageInfo*)(toMap->pStorageImage));
    }
    if (toMap->pUniformTexelBuffer) {
        handlemap_VkDescriptorAddressInfoEXT(
            handlemap, (VkDescriptorAddressInfoEXT*)(toMap->pUniformTexelBuffer));
    }
    if (toMap->pStorageTexelBuffer) {
        handlemap_VkDescriptorAddressInfoEXT(
            handlemap, (VkDescriptorAddressInfoEXT*)(toMap->pStorageTexelBuffer));
    }
    if (toMap->pUniformBuffer) {
        handlemap_VkDescriptorAddressInfoEXT(handlemap,
                                             (VkDescriptorAddressInfoEXT*)(toMap->pUniformBuffer));
    }
    if (toMap->pStorageBuffer) {
        handlemap_VkDescriptorAddressInfoEXT(handlemap,
                                             (VkDescriptorAddressInfoEXT*)(toMap->pStorageBuffer));
    }
}

void handlemap_VkDescriptorGetInfoEXT(VulkanHandleMapping* handlemap,
                                      VkDescriptorGetInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDescriptorDataEXT(handlemap, (VkDescriptorDataEXT*)(&toMap->data));
}

void handlemap_VkBufferCaptureDescriptorDataInfoEXT(VulkanHandleMapping* handlemap,
                                                    VkBufferCaptureDescriptorDataInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageCaptureDescriptorDataInfoEXT(VulkanHandleMapping* handlemap,
                                                   VkImageCaptureDescriptorDataInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkImageViewCaptureDescriptorDataInfoEXT(
    VulkanHandleMapping* handlemap, VkImageViewCaptureDescriptorDataInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
}

void handlemap_VkSamplerCaptureDescriptorDataInfoEXT(VulkanHandleMapping* handlemap,
                                                     VkSamplerCaptureDescriptorDataInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSampler((VkSampler*)&toMap->sampler);
}

void handlemap_VkOpaqueCaptureDescriptorDataCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkOpaqueCaptureDescriptorDataCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAccelerationStructureCaptureDescriptorDataInfoEXT(
    VulkanHandleMapping* handlemap, VkAccelerationStructureCaptureDescriptorDataInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR(
        (VkAccelerationStructureKHR*)&toMap->accelerationStructure);
    handlemap->mapHandles_VkAccelerationStructureNV(
        (VkAccelerationStructureNV*)&toMap->accelerationStructureNV);
}

#endif
#ifdef VK_EXT_graphics_pipeline_library
void handlemap_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsPipelineLibraryCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkGraphicsPipelineLibraryCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_shader_early_and_late_fragment_tests
void handlemap_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_fragment_shading_rate_enums
void handlemap_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    VulkanHandleMapping* handlemap, VkPipelineFragmentShadingRateEnumStateCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_ray_tracing_motion_blur
void handlemap_VkDeviceOrHostAddressConstKHR(VulkanHandleMapping* handlemap,
                                             VkDeviceOrHostAddressConstKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureGeometryMotionTrianglesDataNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureGeometryMotionTrianglesDataNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->vertexData));
}

void handlemap_VkAccelerationStructureMotionInfoNV(VulkanHandleMapping* handlemap,
                                                   VkAccelerationStructureMotionInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAccelerationStructureMatrixMotionInstanceNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureMatrixMotionInstanceNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkTransformMatrixKHR(handlemap, (VkTransformMatrixKHR*)(&toMap->transformT0));
    handlemap_VkTransformMatrixKHR(handlemap, (VkTransformMatrixKHR*)(&toMap->transformT1));
}

void handlemap_VkSRTDataNV(VulkanHandleMapping* handlemap, VkSRTDataNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureSRTMotionInstanceNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureSRTMotionInstanceNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkSRTDataNV(handlemap, (VkSRTDataNV*)(&toMap->transformT0));
    handlemap_VkSRTDataNV(handlemap, (VkSRTDataNV*)(&toMap->transformT1));
}

void handlemap_VkAccelerationStructureMotionInstanceDataNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureMotionInstanceDataNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkAccelerationStructureInstanceKHR(
        handlemap, (VkAccelerationStructureInstanceKHR*)(&toMap->staticInstance));
    handlemap_VkAccelerationStructureMatrixMotionInstanceNV(
        handlemap, (VkAccelerationStructureMatrixMotionInstanceNV*)(&toMap->matrixMotionInstance));
    handlemap_VkAccelerationStructureSRTMotionInstanceNV(
        handlemap, (VkAccelerationStructureSRTMotionInstanceNV*)(&toMap->srtMotionInstance));
}

void handlemap_VkAccelerationStructureMotionInstanceNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureMotionInstanceNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkAccelerationStructureMotionInstanceDataNV(
        handlemap, (VkAccelerationStructureMotionInstanceDataNV*)(&toMap->data));
}

void handlemap_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
void handlemap_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_fragment_density_map2
void handlemap_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void handlemap_VkCopyCommandTransformInfoQCOM(VulkanHandleMapping* handlemap,
                                              VkCopyCommandTransformInfoQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_image_compression_control
void handlemap_VkPhysicalDeviceImageCompressionControlFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageCompressionControlFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageCompressionControlEXT(VulkanHandleMapping* handlemap,
                                            VkImageCompressionControlEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubresourceLayout2EXT(VulkanHandleMapping* handlemap,
                                       VkSubresourceLayout2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSubresourceLayout(handlemap, (VkSubresourceLayout*)(&toMap->subresourceLayout));
}

void handlemap_VkImageSubresource2EXT(VulkanHandleMapping* handlemap,
                                      VkImageSubresource2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresource(handlemap, (VkImageSubresource*)(&toMap->imageSubresource));
}

void handlemap_VkImageCompressionPropertiesEXT(VulkanHandleMapping* handlemap,
                                               VkImageCompressionPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_attachment_feedback_loop_layout
void handlemap_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_4444_formats
void handlemap_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevice4444FormatsFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_device_fault
void handlemap_VkPhysicalDeviceFaultFeaturesEXT(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceFaultFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceFaultCountsEXT(VulkanHandleMapping* handlemap,
                                      VkDeviceFaultCountsEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceFaultAddressInfoEXT(VulkanHandleMapping* handlemap,
                                           VkDeviceFaultAddressInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDeviceFaultVendorInfoEXT(VulkanHandleMapping* handlemap,
                                          VkDeviceFaultVendorInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDeviceFaultInfoEXT(VulkanHandleMapping* handlemap, VkDeviceFaultInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAddressInfos) {
        handlemap_VkDeviceFaultAddressInfoEXT(handlemap,
                                              (VkDeviceFaultAddressInfoEXT*)(toMap->pAddressInfos));
    }
    if (toMap->pVendorInfos) {
        handlemap_VkDeviceFaultVendorInfoEXT(handlemap,
                                             (VkDeviceFaultVendorInfoEXT*)(toMap->pVendorInfos));
    }
}

void handlemap_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(
    VulkanHandleMapping* handlemap, VkDeviceFaultVendorBinaryHeaderVersionOneEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_ARM_rasterization_order_attachment_access
void handlemap_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_rgba10x6_formats
void handlemap_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_acquire_winrt_display
#endif
#ifdef VK_EXT_directfb_surface
void handlemap_VkDirectFBSurfaceCreateInfoEXT(VulkanHandleMapping* handlemap,
                                              VkDirectFBSurfaceCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_VALVE_mutable_descriptor_type
void handlemap_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMutableDescriptorTypeListEXT(VulkanHandleMapping* handlemap,
                                              VkMutableDescriptorTypeListEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkMutableDescriptorTypeCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                    VkMutableDescriptorTypeCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pMutableDescriptorTypeLists) {
            for (uint32_t i = 0; i < (uint32_t)toMap->mutableDescriptorTypeListCount; ++i) {
                handlemap_VkMutableDescriptorTypeListEXT(
                    handlemap,
                    (VkMutableDescriptorTypeListEXT*)(toMap->pMutableDescriptorTypeLists + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_vertex_input_dynamic_state
void handlemap_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVertexInputBindingDescription2EXT(VulkanHandleMapping* handlemap,
                                                   VkVertexInputBindingDescription2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVertexInputAttributeDescription2EXT(VulkanHandleMapping* handlemap,
                                                     VkVertexInputAttributeDescription2EXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_physical_device_drm
void handlemap_VkPhysicalDeviceDrmPropertiesEXT(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceDrmPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_device_address_binding_report
void handlemap_VkPhysicalDeviceAddressBindingReportFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceAddressBindingReportFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceAddressBindingCallbackDataEXT(VulkanHandleMapping* handlemap,
                                                     VkDeviceAddressBindingCallbackDataEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_depth_clip_control
void handlemap_VkPhysicalDeviceDepthClipControlFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDepthClipControlFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineViewportDepthClipControlCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineViewportDepthClipControlCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_primitive_topology_list_restart
void handlemap_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_FUCHSIA_external_memory
void handlemap_VkImportMemoryZirconHandleInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                                     VkImportMemoryZirconHandleInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryZirconHandlePropertiesFUCHSIA(VulkanHandleMapping* handlemap,
                                                     VkMemoryZirconHandlePropertiesFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryGetZirconHandleInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                                  VkMemoryGetZirconHandleInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_FUCHSIA_external_semaphore
void handlemap_VkImportSemaphoreZirconHandleInfoFUCHSIA(
    VulkanHandleMapping* handlemap, VkImportSemaphoreZirconHandleInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkSemaphoreGetZirconHandleInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                                     VkSemaphoreGetZirconHandleInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

#endif
#ifdef VK_FUCHSIA_buffer_collection
void handlemap_VkBufferCollectionCreateInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                                   VkBufferCollectionCreateInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImportMemoryBufferCollectionFUCHSIA(VulkanHandleMapping* handlemap,
                                                     VkImportMemoryBufferCollectionFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBufferCollectionFUCHSIA((VkBufferCollectionFUCHSIA*)&toMap->collection);
}

void handlemap_VkBufferCollectionImageCreateInfoFUCHSIA(
    VulkanHandleMapping* handlemap, VkBufferCollectionImageCreateInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBufferCollectionFUCHSIA((VkBufferCollectionFUCHSIA*)&toMap->collection);
}

void handlemap_VkBufferCollectionConstraintsInfoFUCHSIA(
    VulkanHandleMapping* handlemap, VkBufferCollectionConstraintsInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferConstraintsInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                              VkBufferConstraintsInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkBufferCreateInfo(handlemap, (VkBufferCreateInfo*)(&toMap->createInfo));
    handlemap_VkBufferCollectionConstraintsInfoFUCHSIA(
        handlemap,
        (VkBufferCollectionConstraintsInfoFUCHSIA*)(&toMap->bufferCollectionConstraints));
}

void handlemap_VkBufferCollectionBufferCreateInfoFUCHSIA(
    VulkanHandleMapping* handlemap, VkBufferCollectionBufferCreateInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBufferCollectionFUCHSIA((VkBufferCollectionFUCHSIA*)&toMap->collection);
}

void handlemap_VkSysmemColorSpaceFUCHSIA(VulkanHandleMapping* handlemap,
                                         VkSysmemColorSpaceFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferCollectionPropertiesFUCHSIA(VulkanHandleMapping* handlemap,
                                                   VkBufferCollectionPropertiesFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSysmemColorSpaceFUCHSIA(
        handlemap, (VkSysmemColorSpaceFUCHSIA*)(&toMap->sysmemColorSpaceIndex));
    handlemap_VkComponentMapping(handlemap,
                                 (VkComponentMapping*)(&toMap->samplerYcbcrConversionComponents));
}

void handlemap_VkImageFormatConstraintsInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                                   VkImageFormatConstraintsInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageCreateInfo(handlemap, (VkImageCreateInfo*)(&toMap->imageCreateInfo));
    if (toMap) {
        if (toMap->pColorSpaces) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorSpaceCount; ++i) {
                handlemap_VkSysmemColorSpaceFUCHSIA(
                    handlemap, (VkSysmemColorSpaceFUCHSIA*)(toMap->pColorSpaces + i));
            }
        }
    }
}

void handlemap_VkImageConstraintsInfoFUCHSIA(VulkanHandleMapping* handlemap,
                                             VkImageConstraintsInfoFUCHSIA* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pFormatConstraints) {
            for (uint32_t i = 0; i < (uint32_t)toMap->formatConstraintsCount; ++i) {
                handlemap_VkImageFormatConstraintsInfoFUCHSIA(
                    handlemap,
                    (VkImageFormatConstraintsInfoFUCHSIA*)(toMap->pFormatConstraints + i));
            }
        }
    }
    handlemap_VkBufferCollectionConstraintsInfoFUCHSIA(
        handlemap,
        (VkBufferCollectionConstraintsInfoFUCHSIA*)(&toMap->bufferCollectionConstraints));
}

#endif
#ifdef VK_HUAWEI_subpass_shading
void handlemap_VkSubpassShadingPipelineCreateInfoHUAWEI(
    VulkanHandleMapping* handlemap, VkSubpassShadingPipelineCreateInfoHUAWEI* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
}

void handlemap_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_HUAWEI_invocation_mask
void handlemap_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_external_memory_rdma
void handlemap_VkMemoryGetRemoteAddressInfoNV(VulkanHandleMapping* handlemap,
                                              VkMemoryGetRemoteAddressInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_properties
void handlemap_VkPipelinePropertiesIdentifierEXT(VulkanHandleMapping* handlemap,
                                                 VkPipelinePropertiesIdentifierEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePipelinePropertiesFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelinePropertiesFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
void handlemap_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassResolvePerformanceQueryEXT(VulkanHandleMapping* handlemap,
                                                   VkSubpassResolvePerformanceQueryEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMultisampledRenderToSingleSampledInfoEXT(
    VulkanHandleMapping* handlemap, VkMultisampledRenderToSingleSampledInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_extended_dynamic_state2
void handlemap_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QNX_screen_surface
void handlemap_VkScreenSurfaceCreateInfoQNX(VulkanHandleMapping* handlemap,
                                            VkScreenSurfaceCreateInfoQNX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_color_write_enable
void handlemap_VkPhysicalDeviceColorWriteEnableFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceColorWriteEnableFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineColorWriteCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                 VkPipelineColorWriteCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_primitives_generated_query
void handlemap_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_gfxstream
void handlemap_VkImportColorBufferGOOGLE(VulkanHandleMapping* handlemap,
                                         VkImportColorBufferGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImportBufferGOOGLE(VulkanHandleMapping* handlemap, VkImportBufferGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCreateBlobGOOGLE(VulkanHandleMapping* handlemap, VkCreateBlobGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_global_priority_query
#endif
#ifdef VK_EXT_image_view_min_lod
void handlemap_VkPhysicalDeviceImageViewMinLodFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageViewMinLodFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageViewMinLodCreateInfoEXT(VulkanHandleMapping* handlemap,
                                              VkImageViewMinLodCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_multi_draw
void handlemap_VkPhysicalDeviceMultiDrawFeaturesEXT(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDeviceMultiDrawFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiDrawPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMultiDrawPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMultiDrawInfoEXT(VulkanHandleMapping* handlemap, VkMultiDrawInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkMultiDrawIndexedInfoEXT(VulkanHandleMapping* handlemap,
                                         VkMultiDrawIndexedInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_EXT_image_2d_view_of_3d
void handlemap_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_tile_image
void handlemap_VkPhysicalDeviceShaderTileImageFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderTileImageFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderTileImagePropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderTileImagePropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_opacity_micromap
void handlemap_VkMicromapUsageEXT(VulkanHandleMapping* handlemap, VkMicromapUsageEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDeviceOrHostAddressKHR(VulkanHandleMapping* handlemap,
                                        VkDeviceOrHostAddressKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkMicromapBuildInfoEXT(VulkanHandleMapping* handlemap,
                                      VkMicromapBuildInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->dstMicromap);
    if (toMap) {
        if (toMap->pUsageCounts) {
            for (uint32_t i = 0; i < (uint32_t)toMap->usageCountsCount; ++i) {
                handlemap_VkMicromapUsageEXT(handlemap,
                                             (VkMicromapUsageEXT*)(toMap->pUsageCounts + i));
            }
        }
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->data));
    handlemap_VkDeviceOrHostAddressKHR(handlemap, (VkDeviceOrHostAddressKHR*)(&toMap->scratchData));
    handlemap_VkDeviceOrHostAddressConstKHR(
        handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->triangleArray));
}

void handlemap_VkMicromapCreateInfoEXT(VulkanHandleMapping* handlemap,
                                       VkMicromapCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkPhysicalDeviceOpacityMicromapFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceOpacityMicromapFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceOpacityMicromapPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceOpacityMicromapPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMicromapVersionInfoEXT(VulkanHandleMapping* handlemap,
                                        VkMicromapVersionInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyMicromapToMemoryInfoEXT(VulkanHandleMapping* handlemap,
                                             VkCopyMicromapToMemoryInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->src);
    handlemap_VkDeviceOrHostAddressKHR(handlemap, (VkDeviceOrHostAddressKHR*)(&toMap->dst));
}

void handlemap_VkCopyMemoryToMicromapInfoEXT(VulkanHandleMapping* handlemap,
                                             VkCopyMemoryToMicromapInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->src));
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->dst);
}

void handlemap_VkCopyMicromapInfoEXT(VulkanHandleMapping* handlemap, VkCopyMicromapInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->src);
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->dst);
}

void handlemap_VkMicromapBuildSizesInfoEXT(VulkanHandleMapping* handlemap,
                                           VkMicromapBuildSizesInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAccelerationStructureTrianglesOpacityMicromapEXT(
    VulkanHandleMapping* handlemap, VkAccelerationStructureTrianglesOpacityMicromapEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->indexBuffer));
    if (toMap) {
        if (toMap->pUsageCounts) {
            for (uint32_t i = 0; i < (uint32_t)toMap->usageCountsCount; ++i) {
                handlemap_VkMicromapUsageEXT(handlemap,
                                             (VkMicromapUsageEXT*)(toMap->pUsageCounts + i));
            }
        }
    }
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->micromap);
}

void handlemap_VkMicromapTriangleEXT(VulkanHandleMapping* handlemap, VkMicromapTriangleEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_NV_displacement_micromap
void handlemap_VkPhysicalDeviceDisplacementMicromapFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDisplacementMicromapFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDisplacementMicromapPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDisplacementMicromapPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAccelerationStructureTrianglesDisplacementMicromapNV(
    VulkanHandleMapping* handlemap, VkAccelerationStructureTrianglesDisplacementMicromapNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(
        handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->displacementBiasAndScaleBuffer));
    handlemap_VkDeviceOrHostAddressConstKHR(
        handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->displacementVectorBuffer));
    handlemap_VkDeviceOrHostAddressConstKHR(
        handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->displacedMicromapPrimitiveFlags));
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->indexBuffer));
    if (toMap) {
        if (toMap->pUsageCounts) {
            for (uint32_t i = 0; i < (uint32_t)toMap->usageCountsCount; ++i) {
                handlemap_VkMicromapUsageEXT(handlemap,
                                             (VkMicromapUsageEXT*)(toMap->pUsageCounts + i));
            }
        }
    }
    handlemap->mapHandles_VkMicromapEXT((VkMicromapEXT*)&toMap->micromap);
}

#endif
#ifdef VK_EXT_load_store_op_none
#endif
#ifdef VK_HUAWEI_cluster_culling_shader
void handlemap_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_border_color_swizzle
void handlemap_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerBorderColorComponentMappingCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkSamplerBorderColorComponentMappingCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
}

#endif
#ifdef VK_EXT_pageable_device_local_memory
void handlemap_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_ARM_shader_core_properties
void handlemap_VkPhysicalDeviceShaderCorePropertiesARM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderCorePropertiesARM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_image_sliced_view_of_3d
void handlemap_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageViewSlicedCreateInfoEXT(VulkanHandleMapping* handlemap,
                                              VkImageViewSlicedCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
void handlemap_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetBindingReferenceVALVE(VulkanHandleMapping* handlemap,
                                                    VkDescriptorSetBindingReferenceVALVE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSetLayout(
        (VkDescriptorSetLayout*)&toMap->descriptorSetLayout);
}

void handlemap_VkDescriptorSetLayoutHostMappingInfoVALVE(
    VulkanHandleMapping* handlemap, VkDescriptorSetLayoutHostMappingInfoVALVE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_depth_clamp_zero_one
void handlemap_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_non_seamless_cube_map
void handlemap_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_fragment_density_map_offset
void handlemap_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->fragmentDensityOffsetGranularity));
}

void handlemap_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(
    VulkanHandleMapping* handlemap, VkSubpassFragmentDensityMapOffsetEndInfoQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pFragmentDensityOffsets) {
            for (uint32_t i = 0; i < (uint32_t)toMap->fragmentDensityOffsetCount; ++i) {
                handlemap_VkOffset2D(handlemap, (VkOffset2D*)(toMap->pFragmentDensityOffsets + i));
            }
        }
    }
}

#endif
#ifdef VK_NV_copy_memory_indirect
void handlemap_VkCopyMemoryIndirectCommandNV(VulkanHandleMapping* handlemap,
                                             VkCopyMemoryIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkCopyMemoryToImageIndirectCommandNV(VulkanHandleMapping* handlemap,
                                                    VkCopyMemoryToImageIndirectCommandNV* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_memory_decompression
void handlemap_VkDecompressMemoryRegionNV(VulkanHandleMapping* handlemap,
                                          VkDecompressMemoryRegionNV* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceMemoryDecompressionFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMemoryDecompressionFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMemoryDecompressionPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMemoryDecompressionPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_linear_color_attachment
void handlemap_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceLinearColorAttachmentFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_surfaceless_query
#endif
#ifdef VK_EXT_image_compression_control_swapchain
void handlemap_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_image_processing
void handlemap_VkImageViewSampleWeightCreateInfoQCOM(VulkanHandleMapping* handlemap,
                                                     VkImageViewSampleWeightCreateInfoQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->filterCenter));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->filterSize));
}

void handlemap_VkPhysicalDeviceImageProcessingFeaturesQCOM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageProcessingFeaturesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceImageProcessingPropertiesQCOM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageProcessingPropertiesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxWeightFilterDimension));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxBlockMatchRegion));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->maxBoxFilterBlockSize));
}

#endif
#ifdef VK_EXT_extended_dynamic_state3
void handlemap_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkColorBlendEquationEXT(VulkanHandleMapping* handlemap,
                                       VkColorBlendEquationEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkColorBlendAdvancedEXT(VulkanHandleMapping* handlemap,
                                       VkColorBlendAdvancedEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_EXT_subpass_merge_feedback
void handlemap_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassCreationControlEXT(VulkanHandleMapping* handlemap,
                                              VkRenderPassCreationControlEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassCreationFeedbackInfoEXT(VulkanHandleMapping* handlemap,
                                                   VkRenderPassCreationFeedbackInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassCreationFeedbackCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkRenderPassCreationFeedbackCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pRenderPassFeedback) {
        handlemap_VkRenderPassCreationFeedbackInfoEXT(
            handlemap, (VkRenderPassCreationFeedbackInfoEXT*)(toMap->pRenderPassFeedback));
    }
}

void handlemap_VkRenderPassSubpassFeedbackInfoEXT(VulkanHandleMapping* handlemap,
                                                  VkRenderPassSubpassFeedbackInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassSubpassFeedbackCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkRenderPassSubpassFeedbackCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSubpassFeedback) {
        handlemap_VkRenderPassSubpassFeedbackInfoEXT(
            handlemap, (VkRenderPassSubpassFeedbackInfoEXT*)(toMap->pSubpassFeedback));
    }
}

#endif
#ifdef VK_LUNARG_direct_driver_loading
void handlemap_VkDirectDriverLoadingInfoLUNARG(VulkanHandleMapping* handlemap,
                                               VkDirectDriverLoadingInfoLUNARG* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDirectDriverLoadingListLUNARG(VulkanHandleMapping* handlemap,
                                               VkDirectDriverLoadingListLUNARG* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDrivers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->driverCount; ++i) {
                handlemap_VkDirectDriverLoadingInfoLUNARG(
                    handlemap, (VkDirectDriverLoadingInfoLUNARG*)(toMap->pDrivers + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_shader_module_identifier
void handlemap_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineShaderStageModuleIdentifierCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkShaderModuleIdentifierEXT(VulkanHandleMapping* handlemap,
                                           VkShaderModuleIdentifierEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_rasterization_order_attachment_access
#endif
#ifdef VK_NV_optical_flow
void handlemap_VkPhysicalDeviceOpticalFlowFeaturesNV(VulkanHandleMapping* handlemap,
                                                     VkPhysicalDeviceOpticalFlowFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceOpticalFlowPropertiesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceOpticalFlowPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkOpticalFlowImageFormatInfoNV(VulkanHandleMapping* handlemap,
                                              VkOpticalFlowImageFormatInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkOpticalFlowImageFormatPropertiesNV(VulkanHandleMapping* handlemap,
                                                    VkOpticalFlowImageFormatPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkOpticalFlowSessionCreateInfoNV(VulkanHandleMapping* handlemap,
                                                VkOpticalFlowSessionCreateInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkOpticalFlowSessionCreatePrivateDataInfoNV(
    VulkanHandleMapping* handlemap, VkOpticalFlowSessionCreatePrivateDataInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkOpticalFlowExecuteInfoNV(VulkanHandleMapping* handlemap,
                                          VkOpticalFlowExecuteInfoNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pRegions + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_legacy_dithering
void handlemap_VkPhysicalDeviceLegacyDitheringFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceLegacyDitheringFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_protected_access
void handlemap_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_shader_object
void handlemap_VkPhysicalDeviceShaderObjectFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderObjectFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderObjectPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderObjectPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkShaderCreateInfoEXT(VulkanHandleMapping* handlemap, VkShaderCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSetLayouts) {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts,
                                                    toMap->setLayoutCount);
    }
    if (toMap) {
        if (toMap->pPushConstantRanges) {
            for (uint32_t i = 0; i < (uint32_t)toMap->pushConstantRangeCount; ++i) {
                handlemap_VkPushConstantRange(
                    handlemap, (VkPushConstantRange*)(toMap->pPushConstantRanges + i));
            }
        }
    }
    if (toMap->pSpecializationInfo) {
        handlemap_VkSpecializationInfo(handlemap,
                                       (VkSpecializationInfo*)(toMap->pSpecializationInfo));
    }
}

#endif
#ifdef VK_QCOM_tile_properties
void handlemap_VkPhysicalDeviceTilePropertiesFeaturesQCOM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTilePropertiesFeaturesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTilePropertiesQCOM(VulkanHandleMapping* handlemap, VkTilePropertiesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->tileSize));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->apronSize));
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->origin));
}

#endif
#ifdef VK_SEC_amigo_profiling
void handlemap_VkPhysicalDeviceAmigoProfilingFeaturesSEC(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceAmigoProfilingFeaturesSEC* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAmigoProfilingSubmitInfoSEC(VulkanHandleMapping* handlemap,
                                             VkAmigoProfilingSubmitInfoSEC* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_multiview_per_view_viewports
void handlemap_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
void handlemap_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_mutable_descriptor_type
#endif
#ifdef VK_ARM_shader_core_builtins
void handlemap_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_library_group_handles
void handlemap_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QCOM_multiview_per_view_render_areas
void handlemap_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(
    VulkanHandleMapping* handlemap, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pPerViewRenderAreas) {
            for (uint32_t i = 0; i < (uint32_t)toMap->perViewRenderAreaCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pPerViewRenderAreas + i));
            }
        }
    }
}

#endif
#ifdef VK_EXT_attachment_feedback_loop_dynamic_state
void handlemap_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_acceleration_structure
void handlemap_VkAccelerationStructureBuildRangeInfoKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureBuildRangeInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAccelerationStructureGeometryTrianglesDataKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureGeometryTrianglesDataKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->vertexData));
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->indexData));
    handlemap_VkDeviceOrHostAddressConstKHR(
        handlemap, (VkDeviceOrHostAddressConstKHR*)(&toMap->transformData));
}

void handlemap_VkAccelerationStructureGeometryAabbsDataKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureGeometryAabbsDataKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->data));
}

void handlemap_VkAccelerationStructureGeometryInstancesDataKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureGeometryInstancesDataKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->data));
}

void handlemap_VkAccelerationStructureGeometryDataKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureGeometryDataKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkAccelerationStructureGeometryTrianglesDataKHR(
        handlemap, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&toMap->triangles));
    handlemap_VkAccelerationStructureGeometryAabbsDataKHR(
        handlemap, (VkAccelerationStructureGeometryAabbsDataKHR*)(&toMap->aabbs));
    handlemap_VkAccelerationStructureGeometryInstancesDataKHR(
        handlemap, (VkAccelerationStructureGeometryInstancesDataKHR*)(&toMap->instances));
}

void handlemap_VkAccelerationStructureGeometryKHR(VulkanHandleMapping* handlemap,
                                                  VkAccelerationStructureGeometryKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkAccelerationStructureGeometryDataKHR(
        handlemap, (VkAccelerationStructureGeometryDataKHR*)(&toMap->geometry));
}

void handlemap_VkAccelerationStructureBuildGeometryInfoKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureBuildGeometryInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR(
        (VkAccelerationStructureKHR*)&toMap->srcAccelerationStructure);
    handlemap->mapHandles_VkAccelerationStructureKHR(
        (VkAccelerationStructureKHR*)&toMap->dstAccelerationStructure);
    if (toMap) {
        if (toMap->pGeometries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->geometryCount; ++i) {
                handlemap_VkAccelerationStructureGeometryKHR(
                    handlemap, (VkAccelerationStructureGeometryKHR*)(toMap->pGeometries + i));
            }
        }
    }
    handlemap_VkDeviceOrHostAddressKHR(handlemap, (VkDeviceOrHostAddressKHR*)(&toMap->scratchData));
}

void handlemap_VkAccelerationStructureCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                    VkAccelerationStructureCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkWriteDescriptorSetAccelerationStructureKHR(
    VulkanHandleMapping* handlemap, VkWriteDescriptorSetAccelerationStructureKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAccelerationStructures) {
        handlemap->mapHandles_VkAccelerationStructureKHR(
            (VkAccelerationStructureKHR*)toMap->pAccelerationStructures,
            toMap->accelerationStructureCount);
    }
}

void handlemap_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceAccelerationStructureFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceAccelerationStructurePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAccelerationStructureDeviceAddressInfoKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureDeviceAddressInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR(
        (VkAccelerationStructureKHR*)&toMap->accelerationStructure);
}

void handlemap_VkAccelerationStructureVersionInfoKHR(VulkanHandleMapping* handlemap,
                                                     VkAccelerationStructureVersionInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyAccelerationStructureToMemoryInfoKHR(
    VulkanHandleMapping* handlemap, VkCopyAccelerationStructureToMemoryInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->src);
    handlemap_VkDeviceOrHostAddressKHR(handlemap, (VkDeviceOrHostAddressKHR*)(&toMap->dst));
}

void handlemap_VkCopyMemoryToAccelerationStructureInfoKHR(
    VulkanHandleMapping* handlemap, VkCopyMemoryToAccelerationStructureInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkDeviceOrHostAddressConstKHR(handlemap,
                                            (VkDeviceOrHostAddressConstKHR*)(&toMap->src));
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->dst);
}

void handlemap_VkCopyAccelerationStructureInfoKHR(VulkanHandleMapping* handlemap,
                                                  VkCopyAccelerationStructureInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->src);
    handlemap->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&toMap->dst);
}

void handlemap_VkAccelerationStructureBuildSizesInfoKHR(
    VulkanHandleMapping* handlemap, VkAccelerationStructureBuildSizesInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void handlemap_VkRayTracingShaderGroupCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                    VkRayTracingShaderGroupCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRayTracingPipelineInterfaceCreateInfoKHR(
    VulkanHandleMapping* handlemap, VkRayTracingPipelineInterfaceCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRayTracingPipelineCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                 VkRayTracingPipelineCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pStages) {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i) {
                handlemap_VkPipelineShaderStageCreateInfo(
                    handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pGroups) {
            for (uint32_t i = 0; i < (uint32_t)toMap->groupCount; ++i) {
                handlemap_VkRayTracingShaderGroupCreateInfoKHR(
                    handlemap, (VkRayTracingShaderGroupCreateInfoKHR*)(toMap->pGroups + i));
            }
        }
    }
    if (toMap->pLibraryInfo) {
        handlemap_VkPipelineLibraryCreateInfoKHR(
            handlemap, (VkPipelineLibraryCreateInfoKHR*)(toMap->pLibraryInfo));
    }
    if (toMap->pLibraryInterface) {
        handlemap_VkRayTracingPipelineInterfaceCreateInfoKHR(
            handlemap, (VkRayTracingPipelineInterfaceCreateInfoKHR*)(toMap->pLibraryInterface));
    }
    if (toMap->pDynamicState) {
        handlemap_VkPipelineDynamicStateCreateInfo(
            handlemap, (VkPipelineDynamicStateCreateInfo*)(toMap->pDynamicState));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingPipelineFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceRayTracingPipelinePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkStridedDeviceAddressRegionKHR(VulkanHandleMapping* handlemap,
                                               VkStridedDeviceAddressRegionKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkTraceRaysIndirectCommandKHR(VulkanHandleMapping* handlemap,
                                             VkTraceRaysIndirectCommandKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
#ifdef VK_KHR_ray_query
void handlemap_VkPhysicalDeviceRayQueryFeaturesKHR(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDeviceRayQueryFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_mesh_shader
void handlemap_VkPhysicalDeviceMeshShaderFeaturesEXT(VulkanHandleMapping* handlemap,
                                                     VkPhysicalDeviceMeshShaderFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMeshShaderPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMeshShaderPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDrawMeshTasksIndirectCommandEXT(VulkanHandleMapping* handlemap,
                                                 VkDrawMeshTasksIndirectCommandEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

#endif
void handlemap_extension_struct(VulkanHandleMapping* handlemap, void* structExtension_out) {
    if (!structExtension_out) {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch (structType) {
#ifdef VK_VERSION_1_0
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {
            handlemap_VkShaderModuleCreateInfo(
                handlemap, reinterpret_cast<VkShaderModuleCreateInfo*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            handlemap_VkPhysicalDeviceSubgroupProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            handlemap_VkPhysicalDevice16BitStorageFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
            handlemap_VkMemoryDedicatedRequirements(
                handlemap, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {
            handlemap_VkMemoryDedicatedAllocateInfo(
                handlemap, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {
            handlemap_VkMemoryAllocateFlagsInfo(
                handlemap, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
            handlemap_VkDeviceGroupRenderPassBeginInfo(
                handlemap,
                reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
            handlemap_VkDeviceGroupCommandBufferBeginInfo(
                handlemap,
                reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {
            handlemap_VkDeviceGroupSubmitInfo(
                handlemap, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {
            handlemap_VkDeviceGroupBindSparseInfo(
                handlemap, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {
            handlemap_VkBindBufferMemoryDeviceGroupInfo(
                handlemap,
                reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
            handlemap_VkBindImageMemoryDeviceGroupInfo(
                handlemap,
                reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
            handlemap_VkDeviceGroupDeviceCreateInfo(
                handlemap, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {
            handlemap_VkPhysicalDeviceFeatures2(
                handlemap, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            handlemap_VkPhysicalDevicePointClippingProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
            handlemap_VkRenderPassInputAttachmentAspectCreateInfo(
                handlemap, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
            handlemap_VkImageViewUsageCreateInfo(
                handlemap, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
            handlemap_VkPipelineTessellationDomainOriginStateCreateInfo(
                handlemap, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
            handlemap_VkRenderPassMultiviewCreateInfo(
                handlemap, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            handlemap_VkPhysicalDeviceMultiviewFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            handlemap_VkPhysicalDeviceMultiviewProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
            handlemap_VkPhysicalDeviceVariablePointersFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            handlemap_VkPhysicalDeviceProtectedMemoryFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            handlemap_VkPhysicalDeviceProtectedMemoryProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {
            handlemap_VkProtectedSubmitInfo(
                handlemap, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
            handlemap_VkSamplerYcbcrConversionInfo(
                handlemap, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
            handlemap_VkBindImagePlaneMemoryInfo(
                handlemap, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
            handlemap_VkImagePlaneMemoryRequirementsInfo(
                handlemap,
                reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            handlemap_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
            handlemap_VkSamplerYcbcrConversionImageFormatProperties(
                handlemap, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            handlemap_VkPhysicalDeviceExternalImageFormatInfo(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
            handlemap_VkExternalImageFormatProperties(
                handlemap, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            handlemap_VkPhysicalDeviceIDProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {
            handlemap_VkExternalMemoryImageCreateInfo(
                handlemap, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {
            handlemap_VkExternalMemoryBufferCreateInfo(
                handlemap,
                reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {
            handlemap_VkExportMemoryAllocateInfo(
                handlemap, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {
            handlemap_VkExportFenceCreateInfo(
                handlemap, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {
            handlemap_VkExportSemaphoreCreateInfo(
                handlemap, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            handlemap_VkPhysicalDeviceMaintenance3Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
            handlemap_VkPhysicalDeviceShaderDrawParametersFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
            handlemap_VkPhysicalDeviceVulkan11Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan11Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {
            handlemap_VkPhysicalDeviceVulkan11Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan11Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
            handlemap_VkPhysicalDeviceVulkan12Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan12Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {
            handlemap_VkPhysicalDeviceVulkan12Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan12Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {
            handlemap_VkImageFormatListCreateInfo(
                handlemap, reinterpret_cast<VkImageFormatListCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
            handlemap_VkPhysicalDevice8BitStorageFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDevice8BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {
            handlemap_VkPhysicalDeviceDriverProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDriverProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
            handlemap_VkPhysicalDeviceShaderAtomicInt64Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
            handlemap_VkPhysicalDeviceShaderFloat16Int8Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {
            handlemap_VkPhysicalDeviceFloatControlsProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceFloatControlsProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
            handlemap_VkDescriptorSetLayoutBindingFlagsCreateInfo(
                handlemap, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
            handlemap_VkPhysicalDeviceDescriptorIndexingFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {
            handlemap_VkPhysicalDeviceDescriptorIndexingProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {
            handlemap_VkDescriptorSetVariableDescriptorCountAllocateInfo(
                handlemap, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {
            handlemap_VkDescriptorSetVariableDescriptorCountLayoutSupport(
                handlemap, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
            handlemap_VkSubpassDescriptionDepthStencilResolve(
                handlemap,
                reinterpret_cast<VkSubpassDescriptionDepthStencilResolve*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {
            handlemap_VkPhysicalDeviceDepthStencilResolveProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
            handlemap_VkPhysicalDeviceScalarBlockLayoutFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {
            handlemap_VkImageStencilUsageCreateInfo(
                handlemap, reinterpret_cast<VkImageStencilUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
            handlemap_VkSamplerReductionModeCreateInfo(
                handlemap,
                reinterpret_cast<VkSamplerReductionModeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            handlemap_VkPhysicalDeviceSamplerFilterMinmaxProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
            handlemap_VkPhysicalDeviceVulkanMemoryModelFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
            handlemap_VkPhysicalDeviceImagelessFramebufferFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
            handlemap_VkFramebufferAttachmentsCreateInfo(
                handlemap,
                reinterpret_cast<VkFramebufferAttachmentsCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
            handlemap_VkRenderPassAttachmentBeginInfo(
                handlemap, reinterpret_cast<VkRenderPassAttachmentBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
            handlemap_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
            handlemap_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
            handlemap_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
            handlemap_VkAttachmentReferenceStencilLayout(
                handlemap,
                reinterpret_cast<VkAttachmentReferenceStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            handlemap_VkAttachmentDescriptionStencilLayout(
                handlemap,
                reinterpret_cast<VkAttachmentDescriptionStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            handlemap_VkPhysicalDeviceHostQueryResetFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
            handlemap_VkPhysicalDeviceTimelineSemaphoreFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {
            handlemap_VkPhysicalDeviceTimelineSemaphoreProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {
            handlemap_VkSemaphoreTypeCreateInfo(
                handlemap, reinterpret_cast<VkSemaphoreTypeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {
            handlemap_VkTimelineSemaphoreSubmitInfo(
                handlemap, reinterpret_cast<VkTimelineSemaphoreSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            handlemap_VkPhysicalDeviceBufferDeviceAddressFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {
            handlemap_VkBufferOpaqueCaptureAddressCreateInfo(
                handlemap,
                reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {
            handlemap_VkMemoryOpaqueCaptureAddressAllocateInfo(
                handlemap,
                reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_3
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {
            handlemap_VkPhysicalDeviceVulkan13Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan13Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: {
            handlemap_VkPhysicalDeviceVulkan13Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan13Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
            handlemap_VkPipelineCreationFeedbackCreateInfo(
                handlemap,
                reinterpret_cast<VkPipelineCreationFeedbackCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {
            handlemap_VkPhysicalDeviceShaderTerminateInvocationFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {
            handlemap_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {
            handlemap_VkPhysicalDevicePrivateDataFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePrivateDataFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: {
            handlemap_VkDevicePrivateDataCreateInfo(
                handlemap, reinterpret_cast<VkDevicePrivateDataCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {
            handlemap_VkPhysicalDevicePipelineCreationCacheControlFeatures(
                handlemap, reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {
            handlemap_VkMemoryBarrier2(handlemap,
                                       reinterpret_cast<VkMemoryBarrier2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {
            handlemap_VkPhysicalDeviceSynchronization2Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceSynchronization2Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {
            handlemap_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {
            handlemap_VkPhysicalDeviceImageRobustnessFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceImageRobustnessFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {
            handlemap_VkPhysicalDeviceSubgroupSizeControlFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: {
            handlemap_VkPhysicalDeviceSubgroupSizeControlProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {
            handlemap_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
                handlemap, reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {
            handlemap_VkPhysicalDeviceInlineUniformBlockFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: {
            handlemap_VkPhysicalDeviceInlineUniformBlockProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: {
            handlemap_VkWriteDescriptorSetInlineUniformBlock(
                handlemap,
                reinterpret_cast<VkWriteDescriptorSetInlineUniformBlock*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: {
            handlemap_VkDescriptorPoolInlineUniformBlockCreateInfo(
                handlemap, reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {
            handlemap_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
            handlemap_VkPipelineRenderingCreateInfo(
                handlemap, reinterpret_cast<VkPipelineRenderingCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {
            handlemap_VkPhysicalDeviceDynamicRenderingFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDynamicRenderingFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {
            handlemap_VkCommandBufferInheritanceRenderingInfo(
                handlemap,
                reinterpret_cast<VkCommandBufferInheritanceRenderingInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {
            handlemap_VkPhysicalDeviceShaderIntegerDotProductFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderIntegerDotProductFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: {
            handlemap_VkPhysicalDeviceShaderIntegerDotProductProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderIntegerDotProductProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: {
            handlemap_VkPhysicalDeviceTexelBufferAlignmentProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: {
            handlemap_VkFormatProperties3(
                handlemap, reinterpret_cast<VkFormatProperties3*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {
            handlemap_VkPhysicalDeviceMaintenance4Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance4Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: {
            handlemap_VkPhysicalDeviceMaintenance4Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance4Properties*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {
            handlemap_VkImageSwapchainCreateInfoKHR(
                handlemap, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {
            handlemap_VkBindImageMemorySwapchainInfoKHR(
                handlemap,
                reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {
            handlemap_VkDeviceGroupPresentInfoKHR(
                handlemap, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {
            handlemap_VkDeviceGroupSwapchainCreateInfoKHR(
                handlemap,
                reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {
            handlemap_VkDisplayPresentInfoKHR(
                handlemap, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_video_queue
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR: {
            handlemap_VkQueueFamilyQueryResultStatusPropertiesKHR(
                handlemap, reinterpret_cast<VkQueueFamilyQueryResultStatusPropertiesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR: {
            handlemap_VkQueueFamilyVideoPropertiesKHR(
                handlemap, reinterpret_cast<VkQueueFamilyVideoPropertiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: {
            handlemap_VkVideoProfileInfoKHR(
                handlemap, reinterpret_cast<VkVideoProfileInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: {
            handlemap_VkVideoProfileListInfoKHR(
                handlemap, reinterpret_cast<VkVideoProfileListInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_video_decode_queue
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR: {
            handlemap_VkVideoDecodeCapabilitiesKHR(
                handlemap, reinterpret_cast<VkVideoDecodeCapabilitiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: {
            handlemap_VkVideoDecodeUsageInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeUsageInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_video_decode_h264
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: {
            handlemap_VkVideoDecodeH264ProfileInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH264ProfileInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR: {
            handlemap_VkVideoDecodeH264CapabilitiesKHR(
                handlemap,
                reinterpret_cast<VkVideoDecodeH264CapabilitiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {
            handlemap_VkVideoDecodeH264SessionParametersAddInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH264SessionParametersAddInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            handlemap_VkVideoDecodeH264SessionParametersCreateInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH264SessionParametersCreateInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: {
            handlemap_VkVideoDecodeH264PictureInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH264PictureInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: {
            handlemap_VkVideoDecodeH264DpbSlotInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH264DpbSlotInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_dynamic_rendering
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            handlemap_VkRenderingFragmentShadingRateAttachmentInfoKHR(
                handlemap, reinterpret_cast<VkRenderingFragmentShadingRateAttachmentInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: {
            handlemap_VkRenderingFragmentDensityMapAttachmentInfoEXT(
                handlemap, reinterpret_cast<VkRenderingFragmentDensityMapAttachmentInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: {
            handlemap_VkAttachmentSampleCountInfoAMD(
                handlemap, reinterpret_cast<VkAttachmentSampleCountInfoAMD*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: {
            handlemap_VkMultiviewPerViewAttributesInfoNVX(
                handlemap,
                reinterpret_cast<VkMultiviewPerViewAttributesInfoNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: {
            handlemap_VkImportMemoryWin32HandleInfoKHR(
                handlemap,
                reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: {
            handlemap_VkExportMemoryWin32HandleInfoKHR(
                handlemap,
                reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: {
            handlemap_VkImportMemoryFdInfoKHR(
                handlemap, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {
            handlemap_VkWin32KeyedMutexAcquireReleaseInfoKHR(
                handlemap,
                reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: {
            handlemap_VkExportSemaphoreWin32HandleInfoKHR(
                handlemap,
                reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: {
            handlemap_VkD3D12FenceSubmitInfoKHR(
                handlemap, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: {
            handlemap_VkPhysicalDevicePushDescriptorPropertiesKHR(
                handlemap, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {
            handlemap_VkPresentRegionsKHR(
                handlemap, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: {
            handlemap_VkSharedPresentSurfaceCapabilitiesKHR(
                handlemap,
                reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: {
            handlemap_VkExportFenceWin32HandleInfoKHR(
                handlemap, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {
            handlemap_VkPhysicalDevicePerformanceQueryFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: {
            handlemap_VkPhysicalDevicePerformanceQueryPropertiesKHR(
                handlemap, reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {
            handlemap_VkQueryPoolPerformanceCreateInfoKHR(
                handlemap,
                reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: {
            handlemap_VkPerformanceQuerySubmitInfoKHR(
                handlemap, reinterpret_cast<VkPerformanceQuerySubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: {
            handlemap_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR: {
            handlemap_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
                handlemap, reinterpret_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceShaderClockFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_video_decode_h265
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR: {
            handlemap_VkVideoDecodeH265ProfileInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH265ProfileInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR: {
            handlemap_VkVideoDecodeH265CapabilitiesKHR(
                handlemap,
                reinterpret_cast<VkVideoDecodeH265CapabilitiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {
            handlemap_VkVideoDecodeH265SessionParametersAddInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH265SessionParametersAddInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {
            handlemap_VkVideoDecodeH265SessionParametersCreateInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH265SessionParametersCreateInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: {
            handlemap_VkVideoDecodeH265PictureInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH265PictureInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: {
            handlemap_VkVideoDecodeH265DpbSlotInfoKHR(
                handlemap, reinterpret_cast<VkVideoDecodeH265DpbSlotInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {
            handlemap_VkDeviceQueueGlobalPriorityCreateInfoKHR(
                handlemap,
                reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: {
            handlemap_VkQueueFamilyGlobalPriorityPropertiesKHR(
                handlemap,
                reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            handlemap_VkFragmentShadingRateAttachmentInfoKHR(
                handlemap,
                reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {
            handlemap_VkPipelineFragmentShadingRateStateCreateInfoKHR(
                handlemap, reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: {
            handlemap_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: {
            handlemap_VkSurfaceProtectedCapabilitiesKHR(
                handlemap,
                reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_present_wait
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {
            handlemap_VkPhysicalDevicePresentWaitFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePresentWaitFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
            handlemap_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_pipeline_library
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {
            handlemap_VkPipelineLibraryCreateInfoKHR(
                handlemap, reinterpret_cast<VkPipelineLibraryCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_present_id
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR: {
            handlemap_VkPresentIdKHR(handlemap,
                                     reinterpret_cast<VkPresentIdKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {
            handlemap_VkPhysicalDevicePresentIdFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePresentIdFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_video_encode_queue
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR: {
            handlemap_VkVideoEncodeCapabilitiesKHR(
                handlemap, reinterpret_cast<VkVideoEncodeCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR: {
            handlemap_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(
                handlemap, reinterpret_cast<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: {
            handlemap_VkVideoEncodeUsageInfoKHR(
                handlemap, reinterpret_cast<VkVideoEncodeUsageInfoKHR*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR: {
            handlemap_VkVideoEncodeRateControlLayerInfoKHR(
                handlemap,
                reinterpret_cast<VkVideoEncodeRateControlLayerInfoKHR*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: {
            handlemap_VkVideoEncodeRateControlInfoKHR(
                handlemap, reinterpret_cast<VkVideoEncodeRateControlInfoKHR*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#endif
#ifdef VK_KHR_synchronization2
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {
            handlemap_VkQueueFamilyCheckpointProperties2NV(
                handlemap,
                reinterpret_cast<VkQueueFamilyCheckpointProperties2NV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR: {
            handlemap_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shader_subgroup_uniform_control_flow
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_workgroup_memory_explicit_layout
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_maintenance1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_position_fetch
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
            handlemap_VkNativeBufferANDROID(
                handlemap, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: {
            handlemap_VkDebugReportCallbackCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {
            handlemap_VkPipelineRasterizationStateRasterizationOrderAMD(
                handlemap, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
            handlemap_VkDedicatedAllocationImageCreateInfoNV(
                handlemap,
                reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
            handlemap_VkDedicatedAllocationBufferCreateInfoNV(
                handlemap,
                reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
            handlemap_VkDedicatedAllocationMemoryAllocateInfoNV(
                handlemap,
                reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationStateStreamCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_video_encode_h264
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT: {
            handlemap_VkVideoEncodeH264CapabilitiesEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH264CapabilitiesEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT: {
            handlemap_VkVideoEncodeH264SessionParametersAddInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH264SessionParametersAddInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT: {
            handlemap_VkVideoEncodeH264SessionParametersCreateInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH264SessionParametersCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT: {
            handlemap_VkVideoEncodeH264VclFrameInfoEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH264VclFrameInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT: {
            handlemap_VkVideoEncodeH264DpbSlotInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH264DpbSlotInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT: {
            handlemap_VkVideoEncodeH264ProfileInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH264ProfileInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT: {
            handlemap_VkVideoEncodeH264RateControlInfoEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH264RateControlInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT: {
            handlemap_VkVideoEncodeH264RateControlLayerInfoEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH264RateControlLayerInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#endif
#ifdef VK_EXT_video_encode_h265
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT: {
            handlemap_VkVideoEncodeH265CapabilitiesEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH265CapabilitiesEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT: {
            handlemap_VkVideoEncodeH265SessionParametersAddInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH265SessionParametersAddInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT: {
            handlemap_VkVideoEncodeH265SessionParametersCreateInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH265SessionParametersCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT: {
            handlemap_VkVideoEncodeH265VclFrameInfoEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH265VclFrameInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT: {
            handlemap_VkVideoEncodeH265DpbSlotInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH265DpbSlotInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT: {
            handlemap_VkVideoEncodeH265ProfileInfoEXT(
                handlemap, reinterpret_cast<VkVideoEncodeH265ProfileInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT: {
            handlemap_VkVideoEncodeH265RateControlInfoEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH265RateControlInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT: {
            handlemap_VkVideoEncodeH265RateControlLayerInfoEXT(
                handlemap,
                reinterpret_cast<VkVideoEncodeH265RateControlLayerInfoEXT*>(structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: {
            handlemap_VkTextureLODGatherFormatPropertiesAMD(
                handlemap,
                reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {
            handlemap_VkPhysicalDeviceCornerSampledImageFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {
            handlemap_VkExternalMemoryImageCreateInfoNV(
                handlemap,
                reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {
            handlemap_VkExportMemoryAllocateInfoNV(
                handlemap, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: {
            handlemap_VkImportMemoryWin32HandleInfoNV(
                handlemap, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: {
            handlemap_VkExportMemoryWin32HandleInfoNV(
                handlemap, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: {
            handlemap_VkWin32KeyedMutexAcquireReleaseInfoNV(
                handlemap,
                reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {
            handlemap_VkValidationFlagsEXT(
                handlemap, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {
            handlemap_VkImageViewASTCDecodeModeEXT(
                handlemap, reinterpret_cast<VkImageViewASTCDecodeModeEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceASTCDecodeFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePipelineRobustnessFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDevicePipelineRobustnessFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT: {
            handlemap_VkPhysicalDevicePipelineRobustnessPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDevicePipelineRobustnessPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: {
            handlemap_VkPipelineRobustnessCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkPipelineRobustnessCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {
            handlemap_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
                handlemap, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineViewportWScalingStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {
            handlemap_VkSwapchainCounterCreateInfoEXT(
                handlemap, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: {
            handlemap_VkPresentTimesInfoGOOGLE(
                handlemap, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX: {
            handlemap_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineViewportSwizzleStateCreateInfoNV(
                handlemap,
                reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineDiscardRectangleStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationConservativeStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {
            handlemap_VkDebugUtilsObjectNameInfoEXT(
                handlemap, reinterpret_cast<VkDebugUtilsObjectNameInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: {
            handlemap_VkDebugUtilsMessengerCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: {
            handlemap_VkAndroidHardwareBufferUsageANDROID(
                handlemap,
                reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: {
            handlemap_VkAndroidHardwareBufferFormatPropertiesANDROID(
                handlemap, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: {
            handlemap_VkImportAndroidHardwareBufferInfoANDROID(
                handlemap,
                reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: {
            handlemap_VkExternalFormatANDROID(
                handlemap, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID: {
            handlemap_VkAndroidHardwareBufferFormatProperties2ANDROID(
                handlemap, reinterpret_cast<VkAndroidHardwareBufferFormatProperties2ANDROID*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {
            handlemap_VkSampleLocationsInfoEXT(
                handlemap, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {
            handlemap_VkRenderPassSampleLocationsBeginInfoEXT(
                handlemap,
                reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineSampleLocationsStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceSampleLocationsPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineCoverageToColorStateCreateInfoNV(
                handlemap,
                reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineCoverageModulationStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {
            handlemap_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: {
            handlemap_VkDrmFormatModifierPropertiesListEXT(
                handlemap,
                reinterpret_cast<VkDrmFormatModifierPropertiesListEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: {
            handlemap_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: {
            handlemap_VkImageDrmFormatModifierListCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: {
            handlemap_VkImageDrmFormatModifierExplicitCreateInfoEXT(
                handlemap, reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT: {
            handlemap_VkDrmFormatModifierPropertiesList2EXT(
                handlemap,
                reinterpret_cast<VkDrmFormatModifierPropertiesList2EXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {
            handlemap_VkShaderModuleValidationCacheCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineViewportShadingRateImageStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {
            handlemap_VkPhysicalDeviceShadingRateImageFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceShadingRateImagePropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {
            handlemap_VkWriteDescriptorSetAccelerationStructureNV(
                handlemap, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceRayTracingPropertiesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {
            handlemap_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {
            handlemap_VkPhysicalDeviceImageViewImageFormatInfoEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: {
            handlemap_VkFilterCubicImageViewImageFormatPropertiesEXT(
                handlemap, reinterpret_cast<VkFilterCubicImageViewImageFormatPropertiesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: {
            handlemap_VkImportMemoryHostPointerInfoEXT(
                handlemap,
                reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {
            handlemap_VkPipelineCompilerControlCreateInfoAMD(
                handlemap,
                reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
            handlemap_VkPhysicalDeviceShaderCorePropertiesAMD(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {
            handlemap_VkDeviceMemoryOverallocationCreateInfoAMD(
                handlemap,
                reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineVertexInputDivisorStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: {
            handlemap_VkPresentFrameTokenGGP(
                handlemap, reinterpret_cast<VkPresentFrameTokenGGP*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: {
            handlemap_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {
            handlemap_VkPhysicalDeviceMeshShaderFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceMeshShaderPropertiesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {
            handlemap_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {
            handlemap_VkPhysicalDeviceExclusiveScissorFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: {
            handlemap_VkQueueFamilyCheckpointPropertiesNV(
                handlemap,
                reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {
            handlemap_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {
            handlemap_VkQueryPoolPerformanceQueryCreateInfoINTEL(
                handlemap,
                reinterpret_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
            handlemap_VkPhysicalDevicePCIBusInfoPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: {
            handlemap_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
                handlemap,
                reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: {
            handlemap_VkSwapchainDisplayNativeHdrCreateInfoAMD(
                handlemap,
                reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {
            handlemap_VkRenderPassFragmentDensityMapCreateInfoEXT(
                handlemap, reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: {
            handlemap_VkPhysicalDeviceShaderCoreProperties2AMD(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {
            handlemap_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {
            handlemap_VkMemoryPriorityAllocateInfoEXT(
                handlemap, reinterpret_cast<VkMemoryPriorityAllocateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {
            handlemap_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: {
            handlemap_VkBufferDeviceAddressCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkBufferDeviceAddressCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {
            handlemap_VkValidationFeaturesEXT(
                handlemap, reinterpret_cast<VkValidationFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {
            handlemap_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {
            handlemap_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineCoverageReductionStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineCoverageReductionStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_provoking_vertex
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceProvokingVertexFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceProvokingVertexFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceProvokingVertexPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceProvokingVertexPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: {
            handlemap_VkSurfaceFullScreenExclusiveInfoEXT(
                handlemap,
                reinterpret_cast<VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: {
            handlemap_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
                handlemap, reinterpret_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: {
            handlemap_VkSurfaceFullScreenExclusiveWin32InfoEXT(
                handlemap,
                reinterpret_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceLineRasterizationFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceLineRasterizationPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationLineStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_surface_maintenance1
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: {
            handlemap_VkSurfacePresentModeEXT(
                handlemap, reinterpret_cast<VkSurfacePresentModeEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
            handlemap_VkSurfacePresentScalingCapabilitiesEXT(
                handlemap,
                reinterpret_cast<VkSurfacePresentScalingCapabilitiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
            handlemap_VkSurfacePresentModeCompatibilityEXT(
                handlemap,
                reinterpret_cast<VkSurfacePresentModeCompatibilityEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_swapchain_maintenance1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {
            handlemap_VkSwapchainPresentFenceInfoEXT(
                handlemap, reinterpret_cast<VkSwapchainPresentFenceInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: {
            handlemap_VkSwapchainPresentModesCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkSwapchainPresentModesCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: {
            handlemap_VkSwapchainPresentModeInfoEXT(
                handlemap, reinterpret_cast<VkSwapchainPresentModeInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: {
            handlemap_VkSwapchainPresentScalingCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkSwapchainPresentScalingCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {
            handlemap_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {
            handlemap_VkGraphicsPipelineShaderGroupsCreateInfoNV(
                handlemap,
                reinterpret_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_inherited_viewport_scissor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {
            handlemap_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {
            handlemap_VkCommandBufferInheritanceViewportScissorInfoNV(
                handlemap, reinterpret_cast<VkCommandBufferInheritanceViewportScissorInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: {
            handlemap_VkRenderPassTransformBeginInfoQCOM(
                handlemap,
                reinterpret_cast<VkRenderPassTransformBeginInfoQCOM*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: {
            handlemap_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
                handlemap, reinterpret_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: {
            handlemap_VkDeviceDeviceMemoryReportCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceRobustness2FeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceRobustness2PropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
            handlemap_VkSamplerCustomBorderColorCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_present_barrier
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: {
            handlemap_VkPhysicalDevicePresentBarrierFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePresentBarrierFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV: {
            handlemap_VkSurfaceCapabilitiesPresentBarrierNV(
                handlemap,
                reinterpret_cast<VkSurfaceCapabilitiesPresentBarrierNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: {
            handlemap_VkSwapchainPresentBarrierCreateInfoNV(
                handlemap,
                reinterpret_cast<VkSwapchainPresentBarrierCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {
            handlemap_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {
            handlemap_VkDeviceDiagnosticsConfigCreateInfoNV(
                handlemap,
                reinterpret_cast<VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_low_latency
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: {
            handlemap_VkQueryLowLatencySupportNV(
                handlemap, reinterpret_cast<VkQueryLowLatencySupportNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_metal_objects
        case VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: {
            handlemap_VkExportMetalObjectCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkExportMetalObjectCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT: {
            handlemap_VkExportMetalDeviceInfoEXT(
                handlemap, reinterpret_cast<VkExportMetalDeviceInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: {
            handlemap_VkExportMetalCommandQueueInfoEXT(
                handlemap,
                reinterpret_cast<VkExportMetalCommandQueueInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: {
            handlemap_VkExportMetalBufferInfoEXT(
                handlemap, reinterpret_cast<VkExportMetalBufferInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT: {
            handlemap_VkImportMetalBufferInfoEXT(
                handlemap, reinterpret_cast<VkImportMetalBufferInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: {
            handlemap_VkExportMetalTextureInfoEXT(
                handlemap, reinterpret_cast<VkExportMetalTextureInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: {
            handlemap_VkImportMetalTextureInfoEXT(
                handlemap, reinterpret_cast<VkImportMetalTextureInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: {
            handlemap_VkExportMetalIOSurfaceInfoEXT(
                handlemap, reinterpret_cast<VkExportMetalIOSurfaceInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT: {
            handlemap_VkImportMetalIOSurfaceInfoEXT(
                handlemap, reinterpret_cast<VkImportMetalIOSurfaceInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT: {
            handlemap_VkExportMetalSharedEventInfoEXT(
                handlemap, reinterpret_cast<VkExportMetalSharedEventInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT: {
            handlemap_VkImportMetalSharedEventInfoEXT(
                handlemap, reinterpret_cast<VkImportMetalSharedEventInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_descriptor_buffer
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceDescriptorBufferPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorBufferPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDescriptorBufferFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorBufferFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT: {
            handlemap_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(
                handlemap,
                reinterpret_cast<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: {
            handlemap_VkOpaqueCaptureDescriptorDataCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkOpaqueCaptureDescriptorDataCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_graphics_pipeline_library
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: {
            handlemap_VkGraphicsPipelineLibraryCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkGraphicsPipelineLibraryCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_early_and_late_fragment_tests
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: {
            handlemap_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {
            handlemap_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: {
            handlemap_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
                handlemap, reinterpret_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_ray_tracing_motion_blur
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: {
            handlemap_VkAccelerationStructureGeometryMotionTrianglesDataNV(
                handlemap, reinterpret_cast<VkAccelerationStructureGeometryMotionTrianglesDataNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {
            handlemap_VkAccelerationStructureMotionInfoNV(
                handlemap,
                reinterpret_cast<VkAccelerationStructureMotionInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {
            handlemap_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: {
            handlemap_VkCopyCommandTransformInfoQCOM(
                handlemap, reinterpret_cast<VkCopyCommandTransformInfoQCOM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_compression_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImageCompressionControlFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: {
            handlemap_VkImageCompressionControlEXT(
                handlemap, reinterpret_cast<VkImageCompressionControlEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: {
            handlemap_VkImageCompressionPropertiesEXT(
                handlemap, reinterpret_cast<VkImageCompressionPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_attachment_feedback_loop_layout
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
            handlemap_VkPhysicalDevice4444FormatsFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_device_fault
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceFaultFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceFaultFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ARM_rasterization_order_attachment_access
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_rgba10x6_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VALVE_mutable_descriptor_type
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: {
            handlemap_VkMutableDescriptorTypeCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkMutableDescriptorTypeCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_input_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_physical_device_drm
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceDrmPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDrmPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_device_address_binding_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceAddressBindingReportFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceAddressBindingReportFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: {
            handlemap_VkDeviceAddressBindingCallbackDataEXT(
                handlemap,
                reinterpret_cast<VkDeviceAddressBindingCallbackDataEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDepthClipControlFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDepthClipControlFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: {
            handlemap_VkPipelineViewportDepthClipControlCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineViewportDepthClipControlCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_primitive_topology_list_restart
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_FUCHSIA_external_memory
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: {
            handlemap_VkImportMemoryZirconHandleInfoFUCHSIA(
                handlemap,
                reinterpret_cast<VkImportMemoryZirconHandleInfoFUCHSIA*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_FUCHSIA_buffer_collection
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: {
            handlemap_VkImportMemoryBufferCollectionFUCHSIA(
                handlemap,
                reinterpret_cast<VkImportMemoryBufferCollectionFUCHSIA*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: {
            handlemap_VkBufferCollectionImageCreateInfoFUCHSIA(
                handlemap,
                reinterpret_cast<VkBufferCollectionImageCreateInfoFUCHSIA*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: {
            handlemap_VkBufferCollectionBufferCreateInfoFUCHSIA(
                handlemap,
                reinterpret_cast<VkBufferCollectionBufferCreateInfoFUCHSIA*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_HUAWEI_subpass_shading
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {
            handlemap_VkSubpassShadingPipelineCreateInfoHUAWEI(
                handlemap,
                reinterpret_cast<VkSubpassShadingPipelineCreateInfoHUAWEI*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {
            handlemap_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: {
            handlemap_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_HUAWEI_invocation_mask
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: {
            handlemap_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(
                handlemap, reinterpret_cast<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_rdma
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: {
            handlemap_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePipelinePropertiesFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDevicePipelinePropertiesFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_multisampled_render_to_single_sampled
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: {
            handlemap_VkSubpassResolvePerformanceQueryEXT(
                handlemap,
                reinterpret_cast<VkSubpassResolvePerformanceQueryEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: {
            handlemap_VkMultisampledRenderToSingleSampledInfoEXT(
                handlemap,
                reinterpret_cast<VkMultisampledRenderToSingleSampledInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_color_write_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceColorWriteEnableFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {
            handlemap_VkPipelineColorWriteCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkPipelineColorWriteCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_primitives_generated_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE: {
            handlemap_VkImportColorBufferGOOGLE(
                handlemap, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE: {
            handlemap_VkImportBufferGOOGLE(
                handlemap, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_CREATE_BLOB_GOOGLE: {
            handlemap_VkCreateBlobGOOGLE(
                handlemap, reinterpret_cast<VkCreateBlobGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_view_min_lod
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImageViewMinLodFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceImageViewMinLodFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: {
            handlemap_VkImageViewMinLodCreateInfoEXT(
                handlemap, reinterpret_cast<VkImageViewMinLodCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_multi_draw
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceMultiDrawFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiDrawFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceMultiDrawPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiDrawPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_2d_view_of_3d
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_tile_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceShaderTileImageFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderTileImageFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceShaderTileImagePropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderTileImagePropertiesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_opacity_micromap
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceOpacityMicromapFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceOpacityMicromapFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceOpacityMicromapPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceOpacityMicromapPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: {
            handlemap_VkAccelerationStructureTrianglesOpacityMicromapEXT(
                handlemap, reinterpret_cast<VkAccelerationStructureTrianglesOpacityMicromapEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_displacement_micromap
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV: {
            handlemap_VkPhysicalDeviceDisplacementMicromapFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceDisplacementMicromapFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceDisplacementMicromapPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceDisplacementMicromapPropertiesNV*>(
                               structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV: {
            handlemap_VkAccelerationStructureTrianglesDisplacementMicromapNV(
                handlemap,
                reinterpret_cast<VkAccelerationStructureTrianglesDisplacementMicromapNV*>(
                    structExtension_out));
            break;
        }
#endif  // VK_ENABLE_BETA_EXTENSIONS
#endif
#ifdef VK_HUAWEI_cluster_culling_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI: {
            handlemap_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(
                handlemap, reinterpret_cast<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI: {
            handlemap_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(
                handlemap, reinterpret_cast<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_border_color_swizzle
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: {
            handlemap_VkSamplerBorderColorComponentMappingCreateInfoEXT(
                handlemap, reinterpret_cast<VkSamplerBorderColorComponentMappingCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pageable_device_local_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_ARM_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM: {
            handlemap_VkPhysicalDeviceShaderCorePropertiesARM(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesARM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_sliced_view_of_3d
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT: {
            handlemap_VkImageViewSlicedCreateInfoEXT(
                handlemap, reinterpret_cast<VkImageViewSlicedCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VALVE_descriptor_set_host_mapping
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: {
            handlemap_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(
                handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_depth_clamp_zero_one
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_non_seamless_cube_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_fragment_density_map_offset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: {
            handlemap_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(
                handlemap, reinterpret_cast<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM: {
            handlemap_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: {
            handlemap_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(
                handlemap, reinterpret_cast<VkSubpassFragmentDensityMapOffsetEndInfoQCOM*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_copy_memory_indirect
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: {
            handlemap_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_memory_decompression
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: {
            handlemap_VkPhysicalDeviceMemoryDecompressionFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceMemoryDecompressionFeaturesNV*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceMemoryDecompressionPropertiesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceMemoryDecompressionPropertiesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_linear_color_attachment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: {
            handlemap_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceLinearColorAttachmentFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_compression_control_swapchain
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_image_processing
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM: {
            handlemap_VkImageViewSampleWeightCreateInfoQCOM(
                handlemap,
                reinterpret_cast<VkImageViewSampleWeightCreateInfoQCOM*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: {
            handlemap_VkPhysicalDeviceImageProcessingFeaturesQCOM(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageProcessingFeaturesQCOM*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM: {
            handlemap_VkPhysicalDeviceImageProcessingPropertiesQCOM(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageProcessingPropertiesQCOM*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state3
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_subpass_merge_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: {
            handlemap_VkRenderPassCreationControlEXT(
                handlemap, reinterpret_cast<VkRenderPassCreationControlEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            handlemap_VkRenderPassCreationFeedbackCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkRenderPassCreationFeedbackCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: {
            handlemap_VkRenderPassSubpassFeedbackCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkRenderPassSubpassFeedbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_LUNARG_direct_driver_loading
        case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG: {
            handlemap_VkDirectDriverLoadingListLUNARG(
                handlemap, reinterpret_cast<VkDirectDriverLoadingListLUNARG*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_module_identifier
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT: {
            handlemap_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineShaderStageModuleIdentifierCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_optical_flow
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: {
            handlemap_VkPhysicalDeviceOpticalFlowFeaturesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceOpticalFlowFeaturesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceOpticalFlowPropertiesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceOpticalFlowPropertiesNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: {
            handlemap_VkOpticalFlowImageFormatInfoNV(
                handlemap, reinterpret_cast<VkOpticalFlowImageFormatInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: {
            handlemap_VkOpticalFlowSessionCreatePrivateDataInfoNV(
                handlemap, reinterpret_cast<VkOpticalFlowSessionCreatePrivateDataInfoNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_legacy_dithering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceLegacyDitheringFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceLegacyDitheringFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_protected_access
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_shader_object
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceShaderObjectFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderObjectFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceShaderObjectPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderObjectPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_tile_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: {
            handlemap_VkPhysicalDeviceTilePropertiesFeaturesQCOM(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceTilePropertiesFeaturesQCOM*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_SEC_amigo_profiling
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC: {
            handlemap_VkPhysicalDeviceAmigoProfilingFeaturesSEC(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceAmigoProfilingFeaturesSEC*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC: {
            handlemap_VkAmigoProfilingSubmitInfoSEC(
                handlemap, reinterpret_cast<VkAmigoProfilingSubmitInfoSEC*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_multiview_per_view_viewports
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM: {
            handlemap_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(
                handlemap, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_ray_tracing_invocation_reorder
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV: {
            handlemap_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV: {
            handlemap_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(
                handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_ARM_shader_core_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: {
            handlemap_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM: {
            handlemap_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_pipeline_library_group_handles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_QCOM_multiview_per_view_render_areas
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM: {
            handlemap_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM: {
            handlemap_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(
                handlemap, reinterpret_cast<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_attachment_feedback_loop_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {
            handlemap_VkWriteDescriptorSetAccelerationStructureKHR(
                handlemap, reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: {
            handlemap_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: {
            handlemap_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
                handlemap, reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceRayQueryFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceMeshShaderFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceMeshShaderPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
        default: {
            return;
        }
    }
}

}  // namespace vk
}  // namespace gfxstream
