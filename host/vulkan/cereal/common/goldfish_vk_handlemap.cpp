// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_handlemap
//
// (impl) generated by codegen/vulkan/vulkan-docs-next/scripts/genvk.py -registry
// codegen/vulkan/vulkan-docs-next/xml/vk.xml -registryGfxstream
// codegen/vulkan/vulkan-docs-next/xml/vk_gfxstream.xml cereal -o host/vulkan/cereal
//
// Please do not modify directly;
// re-run gfxstream-protocols/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
// VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
//
// python3 $VULKAN_REGISTRY_SCRIPTS_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o
// $CEREAL_OUTPUT_DIR
//

#include "goldfish_vk_handlemap.h"

#include <string.h>

#include "goldfish_vk_extension_structs.h"
#include "goldfish_vk_private_defs.h"

namespace gfxstream {
namespace vk {

void handlemap_extension_struct(VulkanHandleMapping* handlemap, void* structExtension_out);

#ifdef VK_VERSION_1_0
void handlemap_VkExtent2D(VulkanHandleMapping* handlemap, VkExtent2D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkExtent3D(VulkanHandleMapping* handlemap, VkExtent3D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkOffset2D(VulkanHandleMapping* handlemap, VkOffset2D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkOffset3D(VulkanHandleMapping* handlemap, VkOffset3D* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRect2D(VulkanHandleMapping* handlemap, VkRect2D* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->offset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->extent));
}

void handlemap_VkBaseInStructure(VulkanHandleMapping* handlemap, VkBaseInStructure* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBaseOutStructure(VulkanHandleMapping* handlemap, VkBaseOutStructure* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferMemoryBarrier(VulkanHandleMapping* handlemap, VkBufferMemoryBarrier* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDispatchIndirectCommand(VulkanHandleMapping* handlemap,
                                         VkDispatchIndirectCommand* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrawIndexedIndirectCommand(VulkanHandleMapping* handlemap,
                                            VkDrawIndexedIndirectCommand* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDrawIndirectCommand(VulkanHandleMapping* handlemap, VkDrawIndirectCommand* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageSubresourceRange(VulkanHandleMapping* handlemap,
                                       VkImageSubresourceRange* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageMemoryBarrier(VulkanHandleMapping* handlemap, VkImageMemoryBarrier* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkMemoryBarrier(VulkanHandleMapping* handlemap, VkMemoryBarrier* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCacheHeaderVersionOne(VulkanHandleMapping* handlemap,
                                               VkPipelineCacheHeaderVersionOne* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAllocationCallbacks(VulkanHandleMapping* handlemap, VkAllocationCallbacks* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkApplicationInfo(VulkanHandleMapping* handlemap, VkApplicationInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFormatProperties(VulkanHandleMapping* handlemap, VkFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageFormatProperties(VulkanHandleMapping* handlemap,
                                       VkImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->maxExtent));
}

void handlemap_VkInstanceCreateInfo(VulkanHandleMapping* handlemap, VkInstanceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pApplicationInfo) {
        handlemap_VkApplicationInfo(handlemap, (VkApplicationInfo*)(toMap->pApplicationInfo));
    }
}

void handlemap_VkMemoryHeap(VulkanHandleMapping* handlemap, VkMemoryHeap* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkMemoryType(VulkanHandleMapping* handlemap, VkMemoryType* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceFeatures(VulkanHandleMapping* handlemap,
                                        VkPhysicalDeviceFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceLimits(VulkanHandleMapping* handlemap,
                                      VkPhysicalDeviceLimits* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceMemoryProperties(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceMemoryProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i) {
        handlemap_VkMemoryType(handlemap, (VkMemoryType*)(toMap->memoryTypes + i));
    }
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i) {
        handlemap_VkMemoryHeap(handlemap, (VkMemoryHeap*)(toMap->memoryHeaps + i));
    }
}

void handlemap_VkPhysicalDeviceSparseProperties(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceSparseProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceProperties(VulkanHandleMapping* handlemap,
                                          VkPhysicalDeviceProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkPhysicalDeviceLimits(handlemap, (VkPhysicalDeviceLimits*)(&toMap->limits));
    handlemap_VkPhysicalDeviceSparseProperties(
        handlemap, (VkPhysicalDeviceSparseProperties*)(&toMap->sparseProperties));
}

void handlemap_VkQueueFamilyProperties(VulkanHandleMapping* handlemap,
                                       VkQueueFamilyProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->minImageTransferGranularity));
}

void handlemap_VkDeviceQueueCreateInfo(VulkanHandleMapping* handlemap,
                                       VkDeviceQueueCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceCreateInfo(VulkanHandleMapping* handlemap, VkDeviceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pQueueCreateInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->queueCreateInfoCount; ++i) {
                handlemap_VkDeviceQueueCreateInfo(
                    handlemap, (VkDeviceQueueCreateInfo*)(toMap->pQueueCreateInfos + i));
            }
        }
    }
    if (toMap->pEnabledFeatures) {
        handlemap_VkPhysicalDeviceFeatures(handlemap,
                                           (VkPhysicalDeviceFeatures*)(toMap->pEnabledFeatures));
    }
}

void handlemap_VkExtensionProperties(VulkanHandleMapping* handlemap, VkExtensionProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkLayerProperties(VulkanHandleMapping* handlemap, VkLayerProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSubmitInfo(VulkanHandleMapping* handlemap, VkSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores,
                                          toMap->waitSemaphoreCount);
    }
    if (toMap->pCommandBuffers) {
        handlemap->mapHandles_VkCommandBuffer((VkCommandBuffer*)toMap->pCommandBuffers,
                                              toMap->commandBufferCount);
    }
    if (toMap->pSignalSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSignalSemaphores,
                                          toMap->signalSemaphoreCount);
    }
}

void handlemap_VkMappedMemoryRange(VulkanHandleMapping* handlemap, VkMappedMemoryRange* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkMemoryAllocateInfo(VulkanHandleMapping* handlemap, VkMemoryAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryRequirements(VulkanHandleMapping* handlemap, VkMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSparseMemoryBind(VulkanHandleMapping* handlemap, VkSparseMemoryBind* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkSparseBufferMemoryBindInfo(VulkanHandleMapping* handlemap,
                                            VkSparseBufferMemoryBindInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
    if (toMap) {
        if (toMap->pBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i) {
                handlemap_VkSparseMemoryBind(handlemap, (VkSparseMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkSparseImageOpaqueMemoryBindInfo(VulkanHandleMapping* handlemap,
                                                 VkSparseImageOpaqueMemoryBindInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    if (toMap) {
        if (toMap->pBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i) {
                handlemap_VkSparseMemoryBind(handlemap, (VkSparseMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkImageSubresource(VulkanHandleMapping* handlemap, VkImageSubresource* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSparseImageMemoryBind(VulkanHandleMapping* handlemap,
                                       VkSparseImageMemoryBind* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresource(handlemap, (VkImageSubresource*)(&toMap->subresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->offset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkSparseImageMemoryBindInfo(VulkanHandleMapping* handlemap,
                                           VkSparseImageMemoryBindInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    if (toMap) {
        if (toMap->pBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindCount; ++i) {
                handlemap_VkSparseImageMemoryBind(handlemap,
                                                  (VkSparseImageMemoryBind*)(toMap->pBinds + i));
            }
        }
    }
}

void handlemap_VkBindSparseInfo(VulkanHandleMapping* handlemap, VkBindSparseInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores,
                                          toMap->waitSemaphoreCount);
    }
    if (toMap) {
        if (toMap->pBufferBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bufferBindCount; ++i) {
                handlemap_VkSparseBufferMemoryBindInfo(
                    handlemap, (VkSparseBufferMemoryBindInfo*)(toMap->pBufferBinds + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pImageOpaqueBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageOpaqueBindCount; ++i) {
                handlemap_VkSparseImageOpaqueMemoryBindInfo(
                    handlemap, (VkSparseImageOpaqueMemoryBindInfo*)(toMap->pImageOpaqueBinds + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pImageBinds) {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageBindCount; ++i) {
                handlemap_VkSparseImageMemoryBindInfo(
                    handlemap, (VkSparseImageMemoryBindInfo*)(toMap->pImageBinds + i));
            }
        }
    }
    if (toMap->pSignalSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSignalSemaphores,
                                          toMap->signalSemaphoreCount);
    }
}

void handlemap_VkSparseImageFormatProperties(VulkanHandleMapping* handlemap,
                                             VkSparseImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageGranularity));
}

void handlemap_VkSparseImageMemoryRequirements(VulkanHandleMapping* handlemap,
                                               VkSparseImageMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkSparseImageFormatProperties(
        handlemap, (VkSparseImageFormatProperties*)(&toMap->formatProperties));
}

void handlemap_VkFenceCreateInfo(VulkanHandleMapping* handlemap, VkFenceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreCreateInfo(VulkanHandleMapping* handlemap, VkSemaphoreCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkEventCreateInfo(VulkanHandleMapping* handlemap, VkEventCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueryPoolCreateInfo(VulkanHandleMapping* handlemap, VkQueryPoolCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferCreateInfo(VulkanHandleMapping* handlemap, VkBufferCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferViewCreateInfo(VulkanHandleMapping* handlemap,
                                      VkBufferViewCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageCreateInfo(VulkanHandleMapping* handlemap, VkImageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkSubresourceLayout(VulkanHandleMapping* handlemap, VkSubresourceLayout* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkComponentMapping(VulkanHandleMapping* handlemap, VkComponentMapping* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageViewCreateInfo(VulkanHandleMapping* handlemap, VkImageViewCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkShaderModuleCreateInfo(VulkanHandleMapping* handlemap,
                                        VkShaderModuleCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCacheCreateInfo(VulkanHandleMapping* handlemap,
                                         VkPipelineCacheCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSpecializationMapEntry(VulkanHandleMapping* handlemap,
                                        VkSpecializationMapEntry* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkSpecializationInfo(VulkanHandleMapping* handlemap, VkSpecializationInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pMapEntries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->mapEntryCount; ++i) {
                handlemap_VkSpecializationMapEntry(
                    handlemap, (VkSpecializationMapEntry*)(toMap->pMapEntries + i));
            }
        }
    }
}

void handlemap_VkPipelineShaderStageCreateInfo(VulkanHandleMapping* handlemap,
                                               VkPipelineShaderStageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkShaderModule((VkShaderModule*)&toMap->module);
    if (toMap->pSpecializationInfo) {
        handlemap_VkSpecializationInfo(handlemap,
                                       (VkSpecializationInfo*)(toMap->pSpecializationInfo));
    }
}

void handlemap_VkComputePipelineCreateInfo(VulkanHandleMapping* handlemap,
                                           VkComputePipelineCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPipelineShaderStageCreateInfo(handlemap,
                                              (VkPipelineShaderStageCreateInfo*)(&toMap->stage));
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkVertexInputBindingDescription(VulkanHandleMapping* handlemap,
                                               VkVertexInputBindingDescription* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkVertexInputAttributeDescription(VulkanHandleMapping* handlemap,
                                                 VkVertexInputAttributeDescription* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineVertexInputStateCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkPipelineVertexInputStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pVertexBindingDescriptions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexBindingDescriptionCount; ++i) {
                handlemap_VkVertexInputBindingDescription(
                    handlemap,
                    (VkVertexInputBindingDescription*)(toMap->pVertexBindingDescriptions + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pVertexAttributeDescriptions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexAttributeDescriptionCount; ++i) {
                handlemap_VkVertexInputAttributeDescription(
                    handlemap,
                    (VkVertexInputAttributeDescription*)(toMap->pVertexAttributeDescriptions + i));
            }
        }
    }
}

void handlemap_VkPipelineInputAssemblyStateCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineInputAssemblyStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineTessellationStateCreateInfo(VulkanHandleMapping* handlemap,
                                                     VkPipelineTessellationStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkViewport(VulkanHandleMapping* handlemap, VkViewport* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineViewportStateCreateInfo(VulkanHandleMapping* handlemap,
                                                 VkPipelineViewportStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pViewports) {
            for (uint32_t i = 0; i < (uint32_t)toMap->viewportCount; ++i) {
                handlemap_VkViewport(handlemap, (VkViewport*)(toMap->pViewports + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pScissors) {
            for (uint32_t i = 0; i < (uint32_t)toMap->scissorCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pScissors + i));
            }
        }
    }
}

void handlemap_VkPipelineRasterizationStateCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineMultisampleStateCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkPipelineMultisampleStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkStencilOpState(VulkanHandleMapping* handlemap, VkStencilOpState* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineDepthStencilStateCreateInfo(VulkanHandleMapping* handlemap,
                                                     VkPipelineDepthStencilStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkStencilOpState(handlemap, (VkStencilOpState*)(&toMap->front));
    handlemap_VkStencilOpState(handlemap, (VkStencilOpState*)(&toMap->back));
}

void handlemap_VkPipelineColorBlendAttachmentState(VulkanHandleMapping* handlemap,
                                                   VkPipelineColorBlendAttachmentState* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineColorBlendStateCreateInfo(VulkanHandleMapping* handlemap,
                                                   VkPipelineColorBlendStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i) {
                handlemap_VkPipelineColorBlendAttachmentState(
                    handlemap, (VkPipelineColorBlendAttachmentState*)(toMap->pAttachments + i));
            }
        }
    }
}

void handlemap_VkPipelineDynamicStateCreateInfo(VulkanHandleMapping* handlemap,
                                                VkPipelineDynamicStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsPipelineCreateInfo(VulkanHandleMapping* handlemap,
                                            VkGraphicsPipelineCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pStages) {
            for (uint32_t i = 0; i < (uint32_t)toMap->stageCount; ++i) {
                handlemap_VkPipelineShaderStageCreateInfo(
                    handlemap, (VkPipelineShaderStageCreateInfo*)(toMap->pStages + i));
            }
        }
    }
    if (toMap->pVertexInputState) {
        handlemap_VkPipelineVertexInputStateCreateInfo(
            handlemap, (VkPipelineVertexInputStateCreateInfo*)(toMap->pVertexInputState));
    }
    if (toMap->pInputAssemblyState) {
        handlemap_VkPipelineInputAssemblyStateCreateInfo(
            handlemap, (VkPipelineInputAssemblyStateCreateInfo*)(toMap->pInputAssemblyState));
    }
    if (toMap->pTessellationState) {
        handlemap_VkPipelineTessellationStateCreateInfo(
            handlemap, (VkPipelineTessellationStateCreateInfo*)(toMap->pTessellationState));
    }
    if (toMap->pViewportState) {
        handlemap_VkPipelineViewportStateCreateInfo(
            handlemap, (VkPipelineViewportStateCreateInfo*)(toMap->pViewportState));
    }
    if (toMap->pRasterizationState) {
        handlemap_VkPipelineRasterizationStateCreateInfo(
            handlemap, (VkPipelineRasterizationStateCreateInfo*)(toMap->pRasterizationState));
    }
    if (toMap->pMultisampleState) {
        handlemap_VkPipelineMultisampleStateCreateInfo(
            handlemap, (VkPipelineMultisampleStateCreateInfo*)(toMap->pMultisampleState));
    }
    if (toMap->pDepthStencilState) {
        handlemap_VkPipelineDepthStencilStateCreateInfo(
            handlemap, (VkPipelineDepthStencilStateCreateInfo*)(toMap->pDepthStencilState));
    }
    if (toMap->pColorBlendState) {
        handlemap_VkPipelineColorBlendStateCreateInfo(
            handlemap, (VkPipelineColorBlendStateCreateInfo*)(toMap->pColorBlendState));
    }
    if (toMap->pDynamicState) {
        handlemap_VkPipelineDynamicStateCreateInfo(
            handlemap, (VkPipelineDynamicStateCreateInfo*)(toMap->pDynamicState));
    }
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->layout);
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->basePipelineHandle);
}

void handlemap_VkPushConstantRange(VulkanHandleMapping* handlemap, VkPushConstantRange* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineLayoutCreateInfo(VulkanHandleMapping* handlemap,
                                          VkPipelineLayoutCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSetLayouts) {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts,
                                                    toMap->setLayoutCount);
    }
    if (toMap) {
        if (toMap->pPushConstantRanges) {
            for (uint32_t i = 0; i < (uint32_t)toMap->pushConstantRangeCount; ++i) {
                handlemap_VkPushConstantRange(
                    handlemap, (VkPushConstantRange*)(toMap->pPushConstantRanges + i));
            }
        }
    }
}

void handlemap_VkSamplerCreateInfo(VulkanHandleMapping* handlemap, VkSamplerCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyDescriptorSet(VulkanHandleMapping* handlemap, VkCopyDescriptorSet* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->srcSet);
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->dstSet);
}

void handlemap_VkDescriptorBufferInfo(VulkanHandleMapping* handlemap,
                                      VkDescriptorBufferInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkDescriptorImageInfo(VulkanHandleMapping* handlemap, VkDescriptorImageInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap->mapHandles_VkSampler((VkSampler*)&toMap->sampler);
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
}

void handlemap_VkDescriptorPoolSize(VulkanHandleMapping* handlemap, VkDescriptorPoolSize* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDescriptorPoolCreateInfo(VulkanHandleMapping* handlemap,
                                          VkDescriptorPoolCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pPoolSizes) {
            for (uint32_t i = 0; i < (uint32_t)toMap->poolSizeCount; ++i) {
                handlemap_VkDescriptorPoolSize(handlemap,
                                               (VkDescriptorPoolSize*)(toMap->pPoolSizes + i));
            }
        }
    }
}

void handlemap_VkDescriptorSetAllocateInfo(VulkanHandleMapping* handlemap,
                                           VkDescriptorSetAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorPool((VkDescriptorPool*)&toMap->descriptorPool);
    if (toMap->pSetLayouts) {
        handlemap->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)toMap->pSetLayouts,
                                                    toMap->descriptorSetCount);
    }
}

void handlemap_VkDescriptorSetLayoutBinding(VulkanHandleMapping* handlemap,
                                            VkDescriptorSetLayoutBinding* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pImmutableSamplers) {
        handlemap->mapHandles_VkSampler((VkSampler*)toMap->pImmutableSamplers,
                                        toMap->descriptorCount);
    }
}

void handlemap_VkDescriptorSetLayoutCreateInfo(VulkanHandleMapping* handlemap,
                                               VkDescriptorSetLayoutCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pBindings) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bindingCount; ++i) {
                handlemap_VkDescriptorSetLayoutBinding(
                    handlemap, (VkDescriptorSetLayoutBinding*)(toMap->pBindings + i));
            }
        }
    }
}

void handlemap_VkWriteDescriptorSet(VulkanHandleMapping* handlemap, VkWriteDescriptorSet* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDescriptorSet((VkDescriptorSet*)&toMap->dstSet);
    if (toMap) {
        if (toMap->pImageInfo) {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorCount; ++i) {
                handlemap_VkDescriptorImageInfo(handlemap,
                                                (VkDescriptorImageInfo*)(toMap->pImageInfo + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pBufferInfo) {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorCount; ++i) {
                handlemap_VkDescriptorBufferInfo(handlemap,
                                                 (VkDescriptorBufferInfo*)(toMap->pBufferInfo + i));
            }
        }
    }
    if (toMap->pTexelBufferView) {
        handlemap->mapHandles_VkBufferView((VkBufferView*)toMap->pTexelBufferView,
                                           toMap->descriptorCount);
    }
}

void handlemap_VkAttachmentDescription(VulkanHandleMapping* handlemap,
                                       VkAttachmentDescription* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkAttachmentReference(VulkanHandleMapping* handlemap, VkAttachmentReference* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkFramebufferCreateInfo(VulkanHandleMapping* handlemap,
                                       VkFramebufferCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    if (toMap->pAttachments) {
        handlemap->mapHandles_VkImageView((VkImageView*)toMap->pAttachments,
                                          toMap->attachmentCount);
    }
}

void handlemap_VkSubpassDescription(VulkanHandleMapping* handlemap, VkSubpassDescription* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pInputAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->inputAttachmentCount; ++i) {
                handlemap_VkAttachmentReference(
                    handlemap, (VkAttachmentReference*)(toMap->pInputAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pColorAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference(
                    handlemap, (VkAttachmentReference*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pResolveAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference(
                    handlemap, (VkAttachmentReference*)(toMap->pResolveAttachments + i));
            }
        }
    }
    if (toMap->pDepthStencilAttachment) {
        handlemap_VkAttachmentReference(handlemap,
                                        (VkAttachmentReference*)(toMap->pDepthStencilAttachment));
    }
}

void handlemap_VkSubpassDependency(VulkanHandleMapping* handlemap, VkSubpassDependency* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassCreateInfo(VulkanHandleMapping* handlemap,
                                      VkRenderPassCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i) {
                handlemap_VkAttachmentDescription(
                    handlemap, (VkAttachmentDescription*)(toMap->pAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pSubpasses) {
            for (uint32_t i = 0; i < (uint32_t)toMap->subpassCount; ++i) {
                handlemap_VkSubpassDescription(handlemap,
                                               (VkSubpassDescription*)(toMap->pSubpasses + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pDependencies) {
            for (uint32_t i = 0; i < (uint32_t)toMap->dependencyCount; ++i) {
                handlemap_VkSubpassDependency(handlemap,
                                              (VkSubpassDependency*)(toMap->pDependencies + i));
            }
        }
    }
}

void handlemap_VkCommandPoolCreateInfo(VulkanHandleMapping* handlemap,
                                       VkCommandPoolCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferAllocateInfo(VulkanHandleMapping* handlemap,
                                           VkCommandBufferAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCommandPool((VkCommandPool*)&toMap->commandPool);
}

void handlemap_VkCommandBufferInheritanceInfo(VulkanHandleMapping* handlemap,
                                              VkCommandBufferInheritanceInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkFramebuffer((VkFramebuffer*)&toMap->framebuffer);
}

void handlemap_VkCommandBufferBeginInfo(VulkanHandleMapping* handlemap,
                                        VkCommandBufferBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pInheritanceInfo) {
        handlemap_VkCommandBufferInheritanceInfo(
            handlemap, (VkCommandBufferInheritanceInfo*)(toMap->pInheritanceInfo));
    }
}

void handlemap_VkBufferCopy(VulkanHandleMapping* handlemap, VkBufferCopy* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkImageSubresourceLayers(VulkanHandleMapping* handlemap,
                                        VkImageSubresourceLayers* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkBufferImageCopy(VulkanHandleMapping* handlemap, VkBufferImageCopy* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkClearColorValue(VulkanHandleMapping* handlemap, VkClearColorValue* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkClearDepthStencilValue(VulkanHandleMapping* handlemap,
                                        VkClearDepthStencilValue* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkClearValue(VulkanHandleMapping* handlemap, VkClearValue* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkClearColorValue(handlemap, (VkClearColorValue*)(&toMap->color));
    handlemap_VkClearDepthStencilValue(handlemap,
                                       (VkClearDepthStencilValue*)(&toMap->depthStencil));
}

void handlemap_VkClearAttachment(VulkanHandleMapping* handlemap, VkClearAttachment* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkClearValue(handlemap, (VkClearValue*)(&toMap->clearValue));
}

void handlemap_VkClearRect(VulkanHandleMapping* handlemap, VkClearRect* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->rect));
}

void handlemap_VkImageBlit(VulkanHandleMapping* handlemap, VkImageBlit* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->srcOffsets + i));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->dstOffsets + i));
    }
}

void handlemap_VkImageCopy(VulkanHandleMapping* handlemap, VkImageCopy* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkImageResolve(VulkanHandleMapping* handlemap, VkImageResolve* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkRenderPassBeginInfo(VulkanHandleMapping* handlemap, VkRenderPassBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkRenderPass((VkRenderPass*)&toMap->renderPass);
    handlemap->mapHandles_VkFramebuffer((VkFramebuffer*)&toMap->framebuffer);
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
    if (toMap) {
        if (toMap->pClearValues) {
            for (uint32_t i = 0; i < (uint32_t)toMap->clearValueCount; ++i) {
                handlemap_VkClearValue(handlemap, (VkClearValue*)(toMap->pClearValues + i));
            }
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void handlemap_VkPhysicalDeviceSubgroupProperties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceSubgroupProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindBufferMemoryInfo(VulkanHandleMapping* handlemap,
                                      VkBindBufferMemoryInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkBindImageMemoryInfo(VulkanHandleMapping* handlemap, VkBindImageMemoryInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

void handlemap_VkPhysicalDevice16BitStorageFeatures(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDevice16BitStorageFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryDedicatedRequirements(VulkanHandleMapping* handlemap,
                                             VkMemoryDedicatedRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryDedicatedAllocateInfo(VulkanHandleMapping* handlemap,
                                             VkMemoryDedicatedAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkMemoryAllocateFlagsInfo(VulkanHandleMapping* handlemap,
                                         VkMemoryAllocateFlagsInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupRenderPassBeginInfo(VulkanHandleMapping* handlemap,
                                                VkDeviceGroupRenderPassBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDeviceRenderAreas) {
            for (uint32_t i = 0; i < (uint32_t)toMap->deviceRenderAreaCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pDeviceRenderAreas + i));
            }
        }
    }
}

void handlemap_VkDeviceGroupCommandBufferBeginInfo(VulkanHandleMapping* handlemap,
                                                   VkDeviceGroupCommandBufferBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupSubmitInfo(VulkanHandleMapping* handlemap,
                                       VkDeviceGroupSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupBindSparseInfo(VulkanHandleMapping* handlemap,
                                           VkDeviceGroupBindSparseInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindBufferMemoryDeviceGroupInfo(VulkanHandleMapping* handlemap,
                                                 VkBindBufferMemoryDeviceGroupInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBindImageMemoryDeviceGroupInfo(VulkanHandleMapping* handlemap,
                                                VkBindImageMemoryDeviceGroupInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pSplitInstanceBindRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->splitInstanceBindRegionCount; ++i) {
                handlemap_VkRect2D(handlemap, (VkRect2D*)(toMap->pSplitInstanceBindRegions + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceGroupProperties(VulkanHandleMapping* handlemap,
                                               VkPhysicalDeviceGroupProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)toMap->physicalDevices,
                                           VK_MAX_DEVICE_GROUP_SIZE);
}

void handlemap_VkDeviceGroupDeviceCreateInfo(VulkanHandleMapping* handlemap,
                                             VkDeviceGroupDeviceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPhysicalDevices) {
        handlemap->mapHandles_VkPhysicalDevice((VkPhysicalDevice*)toMap->pPhysicalDevices,
                                               toMap->physicalDeviceCount);
    }
}

void handlemap_VkBufferMemoryRequirementsInfo2(VulkanHandleMapping* handlemap,
                                               VkBufferMemoryRequirementsInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageMemoryRequirementsInfo2(VulkanHandleMapping* handlemap,
                                              VkImageMemoryRequirementsInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkImageSparseMemoryRequirementsInfo2(VulkanHandleMapping* handlemap,
                                                    VkImageSparseMemoryRequirementsInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
}

void handlemap_VkMemoryRequirements2(VulkanHandleMapping* handlemap, VkMemoryRequirements2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkMemoryRequirements(handlemap, (VkMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkSparseImageMemoryRequirements2(VulkanHandleMapping* handlemap,
                                                VkSparseImageMemoryRequirements2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSparseImageMemoryRequirements(
        handlemap, (VkSparseImageMemoryRequirements*)(&toMap->memoryRequirements));
}

void handlemap_VkPhysicalDeviceFeatures2(VulkanHandleMapping* handlemap,
                                         VkPhysicalDeviceFeatures2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceFeatures(handlemap, (VkPhysicalDeviceFeatures*)(&toMap->features));
}

void handlemap_VkPhysicalDeviceProperties2(VulkanHandleMapping* handlemap,
                                           VkPhysicalDeviceProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceProperties(handlemap,
                                         (VkPhysicalDeviceProperties*)(&toMap->properties));
}

void handlemap_VkFormatProperties2(VulkanHandleMapping* handlemap, VkFormatProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkFormatProperties(handlemap, (VkFormatProperties*)(&toMap->formatProperties));
}

void handlemap_VkImageFormatProperties2(VulkanHandleMapping* handlemap,
                                        VkImageFormatProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageFormatProperties(handlemap,
                                      (VkImageFormatProperties*)(&toMap->imageFormatProperties));
}

void handlemap_VkPhysicalDeviceImageFormatInfo2(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceImageFormatInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkQueueFamilyProperties2(VulkanHandleMapping* handlemap,
                                        VkQueueFamilyProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkQueueFamilyProperties(handlemap,
                                      (VkQueueFamilyProperties*)(&toMap->queueFamilyProperties));
}

void handlemap_VkPhysicalDeviceMemoryProperties2(VulkanHandleMapping* handlemap,
                                                 VkPhysicalDeviceMemoryProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPhysicalDeviceMemoryProperties(
        handlemap, (VkPhysicalDeviceMemoryProperties*)(&toMap->memoryProperties));
}

void handlemap_VkSparseImageFormatProperties2(VulkanHandleMapping* handlemap,
                                              VkSparseImageFormatProperties2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSparseImageFormatProperties(handlemap,
                                            (VkSparseImageFormatProperties*)(&toMap->properties));
}

void handlemap_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSparseImageFormatInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePointClippingProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePointClippingProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkInputAttachmentAspectReference(VulkanHandleMapping* handlemap,
                                                VkInputAttachmentAspectReference* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanHandleMapping* handlemap, VkRenderPassInputAttachmentAspectCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAspectReferences) {
            for (uint32_t i = 0; i < (uint32_t)toMap->aspectReferenceCount; ++i) {
                handlemap_VkInputAttachmentAspectReference(
                    handlemap, (VkInputAttachmentAspectReference*)(toMap->pAspectReferences + i));
            }
        }
    }
}

void handlemap_VkImageViewUsageCreateInfo(VulkanHandleMapping* handlemap,
                                          VkImageViewUsageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineTessellationDomainOriginStateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassMultiviewCreateInfo(VulkanHandleMapping* handlemap,
                                               VkRenderPassMultiviewCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiviewFeatures(VulkanHandleMapping* handlemap,
                                                 VkPhysicalDeviceMultiviewFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMultiviewProperties(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDeviceMultiviewProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVariablePointersFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVariablePointersFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProtectedMemoryFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProtectedMemoryProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceQueueInfo2(VulkanHandleMapping* handlemap, VkDeviceQueueInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkProtectedSubmitInfo(VulkanHandleMapping* handlemap, VkProtectedSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerYcbcrConversionCreateInfo(VulkanHandleMapping* handlemap,
                                                  VkSamplerYcbcrConversionCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkComponentMapping(handlemap, (VkComponentMapping*)(&toMap->components));
}

void handlemap_VkSamplerYcbcrConversionInfo(VulkanHandleMapping* handlemap,
                                            VkSamplerYcbcrConversionInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&toMap->conversion);
}

void handlemap_VkBindImagePlaneMemoryInfo(VulkanHandleMapping* handlemap,
                                          VkBindImagePlaneMemoryInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImagePlaneMemoryRequirementsInfo(VulkanHandleMapping* handlemap,
                                                  VkImagePlaneMemoryRequirementsInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSamplerYcbcrConversionFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanHandleMapping* handlemap, VkSamplerYcbcrConversionImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorUpdateTemplateEntry(VulkanHandleMapping* handlemap,
                                               VkDescriptorUpdateTemplateEntry* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkDescriptorUpdateTemplateCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkDescriptorUpdateTemplateCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pDescriptorUpdateEntries) {
            for (uint32_t i = 0; i < (uint32_t)toMap->descriptorUpdateEntryCount; ++i) {
                handlemap_VkDescriptorUpdateTemplateEntry(
                    handlemap,
                    (VkDescriptorUpdateTemplateEntry*)(toMap->pDescriptorUpdateEntries + i));
            }
        }
    }
    handlemap->mapHandles_VkDescriptorSetLayout(
        (VkDescriptorSetLayout*)&toMap->descriptorSetLayout);
    handlemap->mapHandles_VkPipelineLayout((VkPipelineLayout*)&toMap->pipelineLayout);
}

void handlemap_VkExternalMemoryProperties(VulkanHandleMapping* handlemap,
                                          VkExternalMemoryProperties* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExternalImageFormatInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalImageFormatProperties(VulkanHandleMapping* handlemap,
                                               VkExternalImageFormatProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExternalMemoryProperties(
        handlemap, (VkExternalMemoryProperties*)(&toMap->externalMemoryProperties));
}

void handlemap_VkPhysicalDeviceExternalBufferInfo(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceExternalBufferInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalBufferProperties(VulkanHandleMapping* handlemap,
                                          VkExternalBufferProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkExternalMemoryProperties(
        handlemap, (VkExternalMemoryProperties*)(&toMap->externalMemoryProperties));
}

void handlemap_VkPhysicalDeviceIDProperties(VulkanHandleMapping* handlemap,
                                            VkPhysicalDeviceIDProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalMemoryImageCreateInfo(VulkanHandleMapping* handlemap,
                                               VkExternalMemoryImageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalMemoryBufferCreateInfo(VulkanHandleMapping* handlemap,
                                                VkExternalMemoryBufferCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportMemoryAllocateInfo(VulkanHandleMapping* handlemap,
                                          VkExportMemoryAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalFenceInfo(VulkanHandleMapping* handlemap,
                                                 VkPhysicalDeviceExternalFenceInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalFenceProperties(VulkanHandleMapping* handlemap,
                                         VkExternalFenceProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportFenceCreateInfo(VulkanHandleMapping* handlemap,
                                       VkExportFenceCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExportSemaphoreCreateInfo(VulkanHandleMapping* handlemap,
                                           VkExportSemaphoreCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceExternalSemaphoreInfo(VulkanHandleMapping* handlemap,
                                                     VkPhysicalDeviceExternalSemaphoreInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkExternalSemaphoreProperties(VulkanHandleMapping* handlemap,
                                             VkExternalSemaphoreProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance3Properties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMaintenance3Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetLayoutSupport(VulkanHandleMapping* handlemap,
                                            VkDescriptorSetLayoutSupport* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderDrawParametersFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_VERSION_1_2
void handlemap_VkPhysicalDeviceVulkan11Features(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceVulkan11Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan11Properties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVulkan11Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan12Features(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceVulkan12Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkConformanceVersion(VulkanHandleMapping* handlemap, VkConformanceVersion* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPhysicalDeviceVulkan12Properties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVulkan12Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkConformanceVersion(handlemap, (VkConformanceVersion*)(&toMap->conformanceVersion));
}

void handlemap_VkImageFormatListCreateInfo(VulkanHandleMapping* handlemap,
                                           VkImageFormatListCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentDescription2(VulkanHandleMapping* handlemap,
                                        VkAttachmentDescription2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentReference2(VulkanHandleMapping* handlemap,
                                      VkAttachmentReference2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassDescription2(VulkanHandleMapping* handlemap, VkSubpassDescription2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pInputAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->inputAttachmentCount; ++i) {
                handlemap_VkAttachmentReference2(
                    handlemap, (VkAttachmentReference2*)(toMap->pInputAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pColorAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference2(
                    handlemap, (VkAttachmentReference2*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pResolveAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkAttachmentReference2(
                    handlemap, (VkAttachmentReference2*)(toMap->pResolveAttachments + i));
            }
        }
    }
    if (toMap->pDepthStencilAttachment) {
        handlemap_VkAttachmentReference2(handlemap,
                                         (VkAttachmentReference2*)(toMap->pDepthStencilAttachment));
    }
}

void handlemap_VkSubpassDependency2(VulkanHandleMapping* handlemap, VkSubpassDependency2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderPassCreateInfo2(VulkanHandleMapping* handlemap,
                                       VkRenderPassCreateInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentCount; ++i) {
                handlemap_VkAttachmentDescription2(
                    handlemap, (VkAttachmentDescription2*)(toMap->pAttachments + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pSubpasses) {
            for (uint32_t i = 0; i < (uint32_t)toMap->subpassCount; ++i) {
                handlemap_VkSubpassDescription2(handlemap,
                                                (VkSubpassDescription2*)(toMap->pSubpasses + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pDependencies) {
            for (uint32_t i = 0; i < (uint32_t)toMap->dependencyCount; ++i) {
                handlemap_VkSubpassDependency2(handlemap,
                                               (VkSubpassDependency2*)(toMap->pDependencies + i));
            }
        }
    }
}

void handlemap_VkSubpassBeginInfo(VulkanHandleMapping* handlemap, VkSubpassBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassEndInfo(VulkanHandleMapping* handlemap, VkSubpassEndInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevice8BitStorageFeatures(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDevice8BitStorageFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDriverProperties(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceDriverProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkConformanceVersion(handlemap, (VkConformanceVersion*)(&toMap->conformanceVersion));
}

void handlemap_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderAtomicInt64Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderFloat16Int8Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceFloatControlsProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceFloatControlsProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanHandleMapping* handlemap, VkDescriptorSetLayoutBindingFlagsCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorIndexingFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDescriptorIndexingProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanHandleMapping* handlemap, VkDescriptorSetVariableDescriptorCountAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanHandleMapping* handlemap, VkDescriptorSetVariableDescriptorCountLayoutSupport* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSubpassDescriptionDepthStencilResolve(
    VulkanHandleMapping* handlemap, VkSubpassDescriptionDepthStencilResolve* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pDepthStencilResolveAttachment) {
        handlemap_VkAttachmentReference2(
            handlemap, (VkAttachmentReference2*)(toMap->pDepthStencilResolveAttachment));
    }
}

void handlemap_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDepthStencilResolveProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceScalarBlockLayoutFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageStencilUsageCreateInfo(VulkanHandleMapping* handlemap,
                                             VkImageStencilUsageCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSamplerReductionModeCreateInfo(VulkanHandleMapping* handlemap,
                                                VkSamplerReductionModeCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSamplerFilterMinmaxProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVulkanMemoryModelFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImagelessFramebufferFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferAttachmentImageInfo(VulkanHandleMapping* handlemap,
                                                VkFramebufferAttachmentImageInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFramebufferAttachmentsCreateInfo(VulkanHandleMapping* handlemap,
                                                  VkFramebufferAttachmentsCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pAttachmentImageInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->attachmentImageInfoCount; ++i) {
                handlemap_VkFramebufferAttachmentImageInfo(
                    handlemap,
                    (VkFramebufferAttachmentImageInfo*)(toMap->pAttachmentImageInfos + i));
            }
        }
    }
}

void handlemap_VkRenderPassAttachmentBeginInfo(VulkanHandleMapping* handlemap,
                                               VkRenderPassAttachmentBeginInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pAttachments) {
        handlemap->mapHandles_VkImageView((VkImageView*)toMap->pAttachments,
                                          toMap->attachmentCount);
    }
}

void handlemap_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceUniformBufferStandardLayoutFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentReferenceStencilLayout(VulkanHandleMapping* handlemap,
                                                  VkAttachmentReferenceStencilLayout* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkAttachmentDescriptionStencilLayout(VulkanHandleMapping* handlemap,
                                                    VkAttachmentDescriptionStencilLayout* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceHostQueryResetFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTimelineSemaphoreFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTimelineSemaphoreProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreTypeCreateInfo(VulkanHandleMapping* handlemap,
                                         VkSemaphoreTypeCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkTimelineSemaphoreSubmitInfo(VulkanHandleMapping* handlemap,
                                             VkTimelineSemaphoreSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSemaphoreWaitInfo(VulkanHandleMapping* handlemap, VkSemaphoreWaitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pSemaphores, toMap->semaphoreCount);
    }
}

void handlemap_VkSemaphoreSignalInfo(VulkanHandleMapping* handlemap, VkSemaphoreSignalInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceBufferDeviceAddressFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferDeviceAddressInfo(VulkanHandleMapping* handlemap,
                                         VkBufferDeviceAddressInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanHandleMapping* handlemap, VkBufferOpaqueCaptureAddressCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanHandleMapping* handlemap, VkMemoryOpaqueCaptureAddressAllocateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanHandleMapping* handlemap, VkDeviceMemoryOpaqueCaptureAddressInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkDeviceMemory((VkDeviceMemory*)&toMap->memory);
}

#endif
#ifdef VK_VERSION_1_3
void handlemap_VkPhysicalDeviceVulkan13Features(VulkanHandleMapping* handlemap,
                                                VkPhysicalDeviceVulkan13Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceVulkan13Properties(VulkanHandleMapping* handlemap,
                                                  VkPhysicalDeviceVulkan13Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineCreationFeedback(VulkanHandleMapping* handlemap,
                                          VkPipelineCreationFeedback* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineCreationFeedbackCreateInfo(VulkanHandleMapping* handlemap,
                                                    VkPipelineCreationFeedbackCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pPipelineCreationFeedback) {
        handlemap_VkPipelineCreationFeedback(
            handlemap, (VkPipelineCreationFeedback*)(toMap->pPipelineCreationFeedback));
    }
    if (toMap) {
        if (toMap->pPipelineStageCreationFeedbacks) {
            for (uint32_t i = 0; i < (uint32_t)toMap->pipelineStageCreationFeedbackCount; ++i) {
                handlemap_VkPipelineCreationFeedback(
                    handlemap,
                    (VkPipelineCreationFeedback*)(toMap->pPipelineStageCreationFeedbacks + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceShaderTerminateInvocationFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderTerminateInvocationFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceToolProperties(VulkanHandleMapping* handlemap,
                                              VkPhysicalDeviceToolProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePrivateDataFeatures(VulkanHandleMapping* handlemap,
                                                   VkPhysicalDevicePrivateDataFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDevicePrivateDataCreateInfo(VulkanHandleMapping* handlemap,
                                             VkDevicePrivateDataCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPrivateDataSlotCreateInfo(VulkanHandleMapping* handlemap,
                                           VkPrivateDataSlotCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePipelineCreationCacheControlFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePipelineCreationCacheControlFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryBarrier2(VulkanHandleMapping* handlemap, VkMemoryBarrier2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferMemoryBarrier2(VulkanHandleMapping* handlemap,
                                      VkBufferMemoryBarrier2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->buffer);
}

void handlemap_VkImageMemoryBarrier2(VulkanHandleMapping* handlemap, VkImageMemoryBarrier2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkDependencyInfo(VulkanHandleMapping* handlemap, VkDependencyInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pMemoryBarriers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->memoryBarrierCount; ++i) {
                handlemap_VkMemoryBarrier2(handlemap,
                                           (VkMemoryBarrier2*)(toMap->pMemoryBarriers + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pBufferMemoryBarriers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->bufferMemoryBarrierCount; ++i) {
                handlemap_VkBufferMemoryBarrier2(
                    handlemap, (VkBufferMemoryBarrier2*)(toMap->pBufferMemoryBarriers + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pImageMemoryBarriers) {
            for (uint32_t i = 0; i < (uint32_t)toMap->imageMemoryBarrierCount; ++i) {
                handlemap_VkImageMemoryBarrier2(
                    handlemap, (VkImageMemoryBarrier2*)(toMap->pImageMemoryBarriers + i));
            }
        }
    }
}

void handlemap_VkSemaphoreSubmitInfo(VulkanHandleMapping* handlemap, VkSemaphoreSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkCommandBufferSubmitInfo(VulkanHandleMapping* handlemap,
                                         VkCommandBufferSubmitInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkCommandBuffer((VkCommandBuffer*)&toMap->commandBuffer);
}

void handlemap_VkSubmitInfo2(VulkanHandleMapping* handlemap, VkSubmitInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pWaitSemaphoreInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->waitSemaphoreInfoCount; ++i) {
                handlemap_VkSemaphoreSubmitInfo(
                    handlemap, (VkSemaphoreSubmitInfo*)(toMap->pWaitSemaphoreInfos + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pCommandBufferInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->commandBufferInfoCount; ++i) {
                handlemap_VkCommandBufferSubmitInfo(
                    handlemap, (VkCommandBufferSubmitInfo*)(toMap->pCommandBufferInfos + i));
            }
        }
    }
    if (toMap) {
        if (toMap->pSignalSemaphoreInfos) {
            for (uint32_t i = 0; i < (uint32_t)toMap->signalSemaphoreInfoCount; ++i) {
                handlemap_VkSemaphoreSubmitInfo(
                    handlemap, (VkSemaphoreSubmitInfo*)(toMap->pSignalSemaphoreInfos + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceSynchronization2Features(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSynchronization2Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceImageRobustnessFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageRobustnessFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferCopy2(VulkanHandleMapping* handlemap, VkBufferCopy2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCopyBufferInfo2(VulkanHandleMapping* handlemap, VkCopyBufferInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkBufferCopy2(handlemap, (VkBufferCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageCopy2(VulkanHandleMapping* handlemap, VkImageCopy2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkCopyImageInfo2(VulkanHandleMapping* handlemap, VkCopyImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageCopy2(handlemap, (VkImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkBufferImageCopy2(VulkanHandleMapping* handlemap, VkBufferImageCopy2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkCopyBufferToImageInfo2(VulkanHandleMapping* handlemap,
                                        VkCopyBufferToImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->srcBuffer);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkBufferImageCopy2(handlemap, (VkBufferImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkCopyImageToBufferInfo2(VulkanHandleMapping* handlemap,
                                        VkCopyImageToBufferInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkBuffer((VkBuffer*)&toMap->dstBuffer);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkBufferImageCopy2(handlemap, (VkBufferImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageBlit2(VulkanHandleMapping* handlemap, VkImageBlit2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->srcOffsets + i));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i) {
        handlemap_VkOffset3D(handlemap, (VkOffset3D*)(toMap->dstOffsets + i));
    }
}

void handlemap_VkBlitImageInfo2(VulkanHandleMapping* handlemap, VkBlitImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageBlit2(handlemap, (VkImageBlit2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkImageResolve2(VulkanHandleMapping* handlemap, VkImageResolve2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->srcSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->srcOffset));
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->dstSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->dstOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->extent));
}

void handlemap_VkResolveImageInfo2(VulkanHandleMapping* handlemap, VkResolveImageInfo2* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageResolve2(handlemap, (VkImageResolve2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceSubgroupSizeControlFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubgroupSizeControlFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceSubgroupSizeControlProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSubgroupSizeControlProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
    VulkanHandleMapping* handlemap, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceInlineUniformBlockFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceInlineUniformBlockFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceInlineUniformBlockProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceInlineUniformBlockProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkWriteDescriptorSetInlineUniformBlock(
    VulkanHandleMapping* handlemap, VkWriteDescriptorSetInlineUniformBlock* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDescriptorPoolInlineUniformBlockCreateInfo(
    VulkanHandleMapping* handlemap, VkDescriptorPoolInlineUniformBlockCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTextureCompressionASTCHDRFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderingAttachmentInfo(VulkanHandleMapping* handlemap,
                                         VkRenderingAttachmentInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->resolveImageView);
    handlemap_VkClearValue(handlemap, (VkClearValue*)(&toMap->clearValue));
}

void handlemap_VkRenderingInfo(VulkanHandleMapping* handlemap, VkRenderingInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkRect2D(handlemap, (VkRect2D*)(&toMap->renderArea));
    if (toMap) {
        if (toMap->pColorAttachments) {
            for (uint32_t i = 0; i < (uint32_t)toMap->colorAttachmentCount; ++i) {
                handlemap_VkRenderingAttachmentInfo(
                    handlemap, (VkRenderingAttachmentInfo*)(toMap->pColorAttachments + i));
            }
        }
    }
    if (toMap->pDepthAttachment) {
        handlemap_VkRenderingAttachmentInfo(handlemap,
                                            (VkRenderingAttachmentInfo*)(toMap->pDepthAttachment));
    }
    if (toMap->pStencilAttachment) {
        handlemap_VkRenderingAttachmentInfo(
            handlemap, (VkRenderingAttachmentInfo*)(toMap->pStencilAttachment));
    }
}

void handlemap_VkPipelineRenderingCreateInfo(VulkanHandleMapping* handlemap,
                                             VkPipelineRenderingCreateInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceDynamicRenderingFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDynamicRenderingFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCommandBufferInheritanceRenderingInfo(
    VulkanHandleMapping* handlemap, VkCommandBufferInheritanceRenderingInfo* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderIntegerDotProductFeatures(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderIntegerDotProductFeatures* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceShaderIntegerDotProductProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceShaderIntegerDotProductProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTexelBufferAlignmentProperties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTexelBufferAlignmentProperties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkFormatProperties3(VulkanHandleMapping* handlemap, VkFormatProperties3* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance4Features(VulkanHandleMapping* handlemap,
                                                    VkPhysicalDeviceMaintenance4Features* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance4Properties(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMaintenance4Properties* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceBufferMemoryRequirements(VulkanHandleMapping* handlemap,
                                                VkDeviceBufferMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pCreateInfo) {
        handlemap_VkBufferCreateInfo(handlemap, (VkBufferCreateInfo*)(toMap->pCreateInfo));
    }
}

void handlemap_VkDeviceImageMemoryRequirements(VulkanHandleMapping* handlemap,
                                               VkDeviceImageMemoryRequirements* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pCreateInfo) {
        handlemap_VkImageCreateInfo(handlemap, (VkImageCreateInfo*)(toMap->pCreateInfo));
    }
}

#endif
#ifdef VK_KHR_surface
#endif
#ifdef VK_KHR_swapchain
void handlemap_VkSwapchainCreateInfoKHR(VulkanHandleMapping* handlemap,
                                        VkSwapchainCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&toMap->surface);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->imageExtent));
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->oldSwapchain);
}

void handlemap_VkPresentInfoKHR(VulkanHandleMapping* handlemap, VkPresentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pWaitSemaphores) {
        handlemap->mapHandles_VkSemaphore((VkSemaphore*)toMap->pWaitSemaphores,
                                          toMap->waitSemaphoreCount);
    }
    if (toMap->pSwapchains) {
        handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)toMap->pSwapchains,
                                             toMap->swapchainCount);
    }
}

void handlemap_VkImageSwapchainCreateInfoKHR(VulkanHandleMapping* handlemap,
                                             VkImageSwapchainCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

void handlemap_VkBindImageMemorySwapchainInfoKHR(VulkanHandleMapping* handlemap,
                                                 VkBindImageMemorySwapchainInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

void handlemap_VkAcquireNextImageInfoKHR(VulkanHandleMapping* handlemap,
                                         VkAcquireNextImageInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkDeviceGroupPresentCapabilitiesKHR(VulkanHandleMapping* handlemap,
                                                   VkDeviceGroupPresentCapabilitiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupPresentInfoKHR(VulkanHandleMapping* handlemap,
                                           VkDeviceGroupPresentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceGroupSwapchainCreateInfoKHR(VulkanHandleMapping* handlemap,
                                                   VkDeviceGroupSwapchainCreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_xcb_surface
#endif
#ifdef VK_KHR_android_surface
#endif
#ifdef VK_KHR_win32_surface
#endif
#ifdef VK_KHR_dynamic_rendering
void handlemap_VkRenderingFragmentShadingRateAttachmentInfoKHR(
    VulkanHandleMapping* handlemap, VkRenderingFragmentShadingRateAttachmentInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->shadingRateAttachmentTexelSize));
}

void handlemap_VkRenderingFragmentDensityMapAttachmentInfoEXT(
    VulkanHandleMapping* handlemap, VkRenderingFragmentDensityMapAttachmentInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImageView((VkImageView*)&toMap->imageView);
}

void handlemap_VkAttachmentSampleCountInfoAMD(VulkanHandleMapping* handlemap,
                                              VkAttachmentSampleCountInfoAMD* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMultiviewPerViewAttributesInfoNVX(VulkanHandleMapping* handlemap,
                                                   VkMultiviewPerViewAttributesInfoNVX* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
#endif
#ifdef VK_KHR_external_memory_fd
#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
#endif
#ifdef VK_KHR_external_semaphore_fd
void handlemap_VkImportSemaphoreFdInfoKHR(VulkanHandleMapping* handlemap,
                                          VkImportSemaphoreFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

void handlemap_VkSemaphoreGetFdInfoKHR(VulkanHandleMapping* handlemap,
                                       VkSemaphoreGetFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSemaphore((VkSemaphore*)&toMap->semaphore);
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_incremental_present
void handlemap_VkRectLayerKHR(VulkanHandleMapping* handlemap, VkRectLayerKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    handlemap_VkOffset2D(handlemap, (VkOffset2D*)(&toMap->offset));
    handlemap_VkExtent2D(handlemap, (VkExtent2D*)(&toMap->extent));
}

void handlemap_VkPresentRegionKHR(VulkanHandleMapping* handlemap, VkPresentRegionKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap) {
        if (toMap->pRectangles) {
            for (uint32_t i = 0; i < (uint32_t)toMap->rectangleCount; ++i) {
                handlemap_VkRectLayerKHR(handlemap, (VkRectLayerKHR*)(toMap->pRectangles + i));
            }
        }
    }
}

void handlemap_VkPresentRegionsKHR(VulkanHandleMapping* handlemap, VkPresentRegionsKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->swapchainCount; ++i) {
                handlemap_VkPresentRegionKHR(handlemap, (VkPresentRegionKHR*)(toMap->pRegions + i));
            }
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_fd
void handlemap_VkImportFenceFdInfoKHR(VulkanHandleMapping* handlemap,
                                      VkImportFenceFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

void handlemap_VkFenceGetFdInfoKHR(VulkanHandleMapping* handlemap, VkFenceGetFdInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkFence((VkFence*)&toMap->fence);
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_pipeline_executable_properties
void handlemap_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineInfoKHR(VulkanHandleMapping* handlemap, VkPipelineInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
}

void handlemap_VkPipelineExecutablePropertiesKHR(VulkanHandleMapping* handlemap,
                                                 VkPipelineExecutablePropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineExecutableInfoKHR(VulkanHandleMapping* handlemap,
                                           VkPipelineExecutableInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkPipeline((VkPipeline*)&toMap->pipeline);
}

void handlemap_VkPipelineExecutableStatisticValueKHR(VulkanHandleMapping* handlemap,
                                                     VkPipelineExecutableStatisticValueKHR* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineExecutableStatisticKHR(VulkanHandleMapping* handlemap,
                                                VkPipelineExecutableStatisticKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkPipelineExecutableStatisticValueKHR(
        handlemap, (VkPipelineExecutableStatisticValueKHR*)(&toMap->value));
}

void handlemap_VkPipelineExecutableInternalRepresentationKHR(
    VulkanHandleMapping* handlemap, VkPipelineExecutableInternalRepresentationKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_shader_integer_dot_product
#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_synchronization2
void handlemap_VkQueueFamilyCheckpointProperties2NV(VulkanHandleMapping* handlemap,
                                                    VkQueueFamilyCheckpointProperties2NV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCheckpointData2NV(VulkanHandleMapping* handlemap, VkCheckpointData2NV* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_KHR_zero_initialize_workgroup_memory
#endif
#ifdef VK_KHR_copy_commands2
#endif
#ifdef VK_KHR_format_feature_flags2
#endif
#ifdef VK_KHR_maintenance4
#endif
#ifdef VK_KHR_maintenance5
void handlemap_VkPhysicalDeviceMaintenance5FeaturesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMaintenance5FeaturesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceMaintenance5PropertiesKHR(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceMaintenance5PropertiesKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkRenderingAreaInfoKHR(VulkanHandleMapping* handlemap,
                                      VkRenderingAreaInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageSubresource2KHR(VulkanHandleMapping* handlemap,
                                      VkImageSubresource2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresource(handlemap, (VkImageSubresource*)(&toMap->imageSubresource));
}

void handlemap_VkDeviceImageSubresourceInfoKHR(VulkanHandleMapping* handlemap,
                                               VkDeviceImageSubresourceInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pCreateInfo) {
        handlemap_VkImageCreateInfo(handlemap, (VkImageCreateInfo*)(toMap->pCreateInfo));
    }
    if (toMap->pSubresource) {
        handlemap_VkImageSubresource2KHR(handlemap, (VkImageSubresource2KHR*)(toMap->pSubresource));
    }
}

void handlemap_VkSubresourceLayout2KHR(VulkanHandleMapping* handlemap,
                                       VkSubresourceLayout2KHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkSubresourceLayout(handlemap, (VkSubresourceLayout*)(&toMap->subresourceLayout));
}

void handlemap_VkPipelineCreateFlags2CreateInfoKHR(VulkanHandleMapping* handlemap,
                                                   VkPipelineCreateFlags2CreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkBufferUsageFlags2CreateInfoKHR(VulkanHandleMapping* handlemap,
                                                VkBufferUsageFlags2CreateInfoKHR* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void handlemap_VkNativeBufferUsage2ANDROID(VulkanHandleMapping* handlemap,
                                           VkNativeBufferUsage2ANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkNativeBufferANDROID(VulkanHandleMapping* handlemap, VkNativeBufferANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkNativeBufferUsage2ANDROID(handlemap,
                                          (VkNativeBufferUsage2ANDROID*)(&toMap->usage2));
}

void handlemap_VkSwapchainImageCreateInfoANDROID(VulkanHandleMapping* handlemap,
                                                 VkSwapchainImageCreateInfoANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDevicePresentationPropertiesANDROID(
    VulkanHandleMapping* handlemap, VkPhysicalDevicePresentationPropertiesANDROID* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_transform_feedback
void handlemap_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTransformFeedbackFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTransformFeedbackPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationStateStreamCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
#endif
#ifdef VK_EXT_depth_clip_enable
void handlemap_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDepthClipEnableFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationDepthClipStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
#endif
#ifdef VK_EXT_inline_uniform_block
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_vertex_attribute_divisor
void handlemap_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanHandleMapping* handlemap, VkVertexInputBindingDivisorDescriptionEXT* toMap) {
    (void)handlemap;
    (void)toMap;
}

void handlemap_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineVertexInputDivisorStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap) {
        if (toMap->pVertexBindingDivisors) {
            for (uint32_t i = 0; i < (uint32_t)toMap->vertexBindingDivisorCount; ++i) {
                handlemap_VkVertexInputBindingDivisorDescriptionEXT(
                    handlemap,
                    (VkVertexInputBindingDivisorDescriptionEXT*)(toMap->pVertexBindingDivisors +
                                                                 i));
            }
        }
    }
}

void handlemap_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_EXT_metal_surface
#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_EXT_tooling_info
#endif
#ifdef VK_EXT_provoking_vertex
void handlemap_VkPhysicalDeviceProvokingVertexFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProvokingVertexFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceProvokingVertexPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceProvokingVertexPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
    VulkanHandleMapping* handlemap,
    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_line_rasterization
void handlemap_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceLineRasterizationFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceLineRasterizationPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkPipelineRasterizationLineStateCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_index_type_uint8
void handlemap_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceIndexTypeUint8FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void handlemap_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_host_image_copy
void handlemap_VkPhysicalDeviceHostImageCopyFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceHostImageCopyFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceHostImageCopyPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceHostImageCopyPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkMemoryToImageCopyEXT(VulkanHandleMapping* handlemap,
                                      VkMemoryToImageCopyEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkImageToMemoryCopyEXT(VulkanHandleMapping* handlemap,
                                      VkImageToMemoryCopyEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkImageSubresourceLayers(handlemap,
                                       (VkImageSubresourceLayers*)(&toMap->imageSubresource));
    handlemap_VkOffset3D(handlemap, (VkOffset3D*)(&toMap->imageOffset));
    handlemap_VkExtent3D(handlemap, (VkExtent3D*)(&toMap->imageExtent));
}

void handlemap_VkCopyMemoryToImageInfoEXT(VulkanHandleMapping* handlemap,
                                          VkCopyMemoryToImageInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkMemoryToImageCopyEXT(handlemap,
                                                 (VkMemoryToImageCopyEXT*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkCopyImageToMemoryInfoEXT(VulkanHandleMapping* handlemap,
                                          VkCopyImageToMemoryInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageToMemoryCopyEXT(handlemap,
                                                 (VkImageToMemoryCopyEXT*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkCopyImageToImageInfoEXT(VulkanHandleMapping* handlemap,
                                         VkCopyImageToImageInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->srcImage);
    handlemap->mapHandles_VkImage((VkImage*)&toMap->dstImage);
    if (toMap) {
        if (toMap->pRegions) {
            for (uint32_t i = 0; i < (uint32_t)toMap->regionCount; ++i) {
                handlemap_VkImageCopy2(handlemap, (VkImageCopy2*)(toMap->pRegions + i));
            }
        }
    }
}

void handlemap_VkHostImageLayoutTransitionInfoEXT(VulkanHandleMapping* handlemap,
                                                  VkHostImageLayoutTransitionInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkImage((VkImage*)&toMap->image);
    handlemap_VkImageSubresourceRange(handlemap,
                                      (VkImageSubresourceRange*)(&toMap->subresourceRange));
}

void handlemap_VkSubresourceHostMemcpySizeEXT(VulkanHandleMapping* handlemap,
                                              VkSubresourceHostMemcpySizeEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkHostImageCopyDevicePerformanceQueryEXT(
    VulkanHandleMapping* handlemap, VkHostImageCopyDevicePerformanceQueryEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_swapchain_maintenance1
void handlemap_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentFenceInfoEXT(VulkanHandleMapping* handlemap,
                                              VkSwapchainPresentFenceInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    if (toMap->pFences) {
        handlemap->mapHandles_VkFence((VkFence*)toMap->pFences, toMap->swapchainCount);
    }
}

void handlemap_VkSwapchainPresentModesCreateInfoEXT(VulkanHandleMapping* handlemap,
                                                    VkSwapchainPresentModesCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentModeInfoEXT(VulkanHandleMapping* handlemap,
                                             VkSwapchainPresentModeInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkSwapchainPresentScalingCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkSwapchainPresentScalingCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkReleaseSwapchainImagesInfoEXT(VulkanHandleMapping* handlemap,
                                               VkReleaseSwapchainImagesInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&toMap->swapchain);
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
#endif
#ifdef VK_EXT_texel_buffer_alignment
void handlemap_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_device_memory_report
void handlemap_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceMemoryReportCallbackDataEXT(VulkanHandleMapping* handlemap,
                                                   VkDeviceMemoryReportCallbackDataEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkDeviceDeviceMemoryReportCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_custom_border_color
void handlemap_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkSamplerCustomBorderColorCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
    handlemap_VkClearColorValue(handlemap, (VkClearColorValue*)(&toMap->customBorderColor));
}

void handlemap_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCustomBorderColorPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceCustomBorderColorFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_private_data
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
#endif
#ifdef VK_EXT_graphics_pipeline_library
void handlemap_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkGraphicsPipelineLibraryCreateInfoEXT(
    VulkanHandleMapping* handlemap, VkGraphicsPipelineLibraryCreateInfoEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
void handlemap_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_image_compression_control
void handlemap_VkPhysicalDeviceImageCompressionControlFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceImageCompressionControlFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageCompressionControlEXT(VulkanHandleMapping* handlemap,
                                            VkImageCompressionControlEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImageCompressionPropertiesEXT(VulkanHandleMapping* handlemap,
                                               VkImageCompressionPropertiesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_4444_formats
void handlemap_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDevice4444FormatsFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_primitive_topology_list_restart
void handlemap_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_extended_dynamic_state2
void handlemap_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
    VulkanHandleMapping* handlemap, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_GOOGLE_gfxstream
void handlemap_VkImportColorBufferGOOGLE(VulkanHandleMapping* handlemap,
                                         VkImportColorBufferGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkImportBufferGOOGLE(VulkanHandleMapping* handlemap, VkImportBufferGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

void handlemap_VkCreateBlobGOOGLE(VulkanHandleMapping* handlemap, VkCreateBlobGOOGLE* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_EXT_load_store_op_none
#endif
#ifdef VK_EXT_image_compression_control_swapchain
void handlemap_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
    VulkanHandleMapping* handlemap,
    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* toMap) {
    (void)handlemap;
    (void)toMap;
    if (toMap->pNext) {
        handlemap_extension_struct(handlemap, (void*)(toMap->pNext));
    }
}

#endif
#ifdef VK_QNX_external_memory_screen_buffer
#endif
void handlemap_extension_struct(VulkanHandleMapping* handlemap, void* structExtension_out) {
    if (!structExtension_out) {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch (structType) {
#ifdef VK_VERSION_1_0
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {
            handlemap_VkShaderModuleCreateInfo(
                handlemap, reinterpret_cast<VkShaderModuleCreateInfo*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            handlemap_VkPhysicalDeviceSubgroupProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            handlemap_VkPhysicalDevice16BitStorageFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
            handlemap_VkMemoryDedicatedRequirements(
                handlemap, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {
            handlemap_VkMemoryDedicatedAllocateInfo(
                handlemap, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {
            handlemap_VkMemoryAllocateFlagsInfo(
                handlemap, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
            handlemap_VkDeviceGroupRenderPassBeginInfo(
                handlemap,
                reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
            handlemap_VkDeviceGroupCommandBufferBeginInfo(
                handlemap,
                reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {
            handlemap_VkDeviceGroupSubmitInfo(
                handlemap, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {
            handlemap_VkDeviceGroupBindSparseInfo(
                handlemap, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {
            handlemap_VkBindBufferMemoryDeviceGroupInfo(
                handlemap,
                reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
            handlemap_VkBindImageMemoryDeviceGroupInfo(
                handlemap,
                reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
            handlemap_VkDeviceGroupDeviceCreateInfo(
                handlemap, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {
            handlemap_VkPhysicalDeviceFeatures2(
                handlemap, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            handlemap_VkPhysicalDevicePointClippingProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
            handlemap_VkRenderPassInputAttachmentAspectCreateInfo(
                handlemap, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
            handlemap_VkImageViewUsageCreateInfo(
                handlemap, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
            handlemap_VkPipelineTessellationDomainOriginStateCreateInfo(
                handlemap, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
            handlemap_VkRenderPassMultiviewCreateInfo(
                handlemap, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            handlemap_VkPhysicalDeviceMultiviewFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            handlemap_VkPhysicalDeviceMultiviewProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {
            handlemap_VkPhysicalDeviceVariablePointersFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            handlemap_VkPhysicalDeviceProtectedMemoryFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            handlemap_VkPhysicalDeviceProtectedMemoryProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {
            handlemap_VkProtectedSubmitInfo(
                handlemap, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
            handlemap_VkSamplerYcbcrConversionInfo(
                handlemap, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
            handlemap_VkBindImagePlaneMemoryInfo(
                handlemap, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
            handlemap_VkImagePlaneMemoryRequirementsInfo(
                handlemap,
                reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            handlemap_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
            handlemap_VkSamplerYcbcrConversionImageFormatProperties(
                handlemap, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            handlemap_VkPhysicalDeviceExternalImageFormatInfo(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
            handlemap_VkExternalImageFormatProperties(
                handlemap, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            handlemap_VkPhysicalDeviceIDProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {
            handlemap_VkExternalMemoryImageCreateInfo(
                handlemap, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {
            handlemap_VkExternalMemoryBufferCreateInfo(
                handlemap,
                reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {
            handlemap_VkExportMemoryAllocateInfo(
                handlemap, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {
            handlemap_VkExportFenceCreateInfo(
                handlemap, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {
            handlemap_VkExportSemaphoreCreateInfo(
                handlemap, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            handlemap_VkPhysicalDeviceMaintenance3Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {
            handlemap_VkPhysicalDeviceShaderDrawParametersFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {
            handlemap_VkPhysicalDeviceVulkan11Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan11Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {
            handlemap_VkPhysicalDeviceVulkan11Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan11Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {
            handlemap_VkPhysicalDeviceVulkan12Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan12Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {
            handlemap_VkPhysicalDeviceVulkan12Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan12Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {
            handlemap_VkImageFormatListCreateInfo(
                handlemap, reinterpret_cast<VkImageFormatListCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {
            handlemap_VkPhysicalDevice8BitStorageFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDevice8BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {
            handlemap_VkPhysicalDeviceDriverProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDriverProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {
            handlemap_VkPhysicalDeviceShaderAtomicInt64Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {
            handlemap_VkPhysicalDeviceShaderFloat16Int8Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {
            handlemap_VkPhysicalDeviceFloatControlsProperties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceFloatControlsProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {
            handlemap_VkDescriptorSetLayoutBindingFlagsCreateInfo(
                handlemap, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {
            handlemap_VkPhysicalDeviceDescriptorIndexingFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {
            handlemap_VkPhysicalDeviceDescriptorIndexingProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {
            handlemap_VkDescriptorSetVariableDescriptorCountAllocateInfo(
                handlemap, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {
            handlemap_VkDescriptorSetVariableDescriptorCountLayoutSupport(
                handlemap, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {
            handlemap_VkSubpassDescriptionDepthStencilResolve(
                handlemap,
                reinterpret_cast<VkSubpassDescriptionDepthStencilResolve*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {
            handlemap_VkPhysicalDeviceDepthStencilResolveProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {
            handlemap_VkPhysicalDeviceScalarBlockLayoutFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {
            handlemap_VkImageStencilUsageCreateInfo(
                handlemap, reinterpret_cast<VkImageStencilUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {
            handlemap_VkSamplerReductionModeCreateInfo(
                handlemap,
                reinterpret_cast<VkSamplerReductionModeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            handlemap_VkPhysicalDeviceSamplerFilterMinmaxProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {
            handlemap_VkPhysicalDeviceVulkanMemoryModelFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {
            handlemap_VkPhysicalDeviceImagelessFramebufferFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
            handlemap_VkFramebufferAttachmentsCreateInfo(
                handlemap,
                reinterpret_cast<VkFramebufferAttachmentsCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
            handlemap_VkRenderPassAttachmentBeginInfo(
                handlemap, reinterpret_cast<VkRenderPassAttachmentBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {
            handlemap_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {
            handlemap_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {
            handlemap_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
            handlemap_VkAttachmentReferenceStencilLayout(
                handlemap,
                reinterpret_cast<VkAttachmentReferenceStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            handlemap_VkAttachmentDescriptionStencilLayout(
                handlemap,
                reinterpret_cast<VkAttachmentDescriptionStencilLayout*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {
            handlemap_VkPhysicalDeviceHostQueryResetFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {
            handlemap_VkPhysicalDeviceTimelineSemaphoreFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {
            handlemap_VkPhysicalDeviceTimelineSemaphoreProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {
            handlemap_VkSemaphoreTypeCreateInfo(
                handlemap, reinterpret_cast<VkSemaphoreTypeCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {
            handlemap_VkTimelineSemaphoreSubmitInfo(
                handlemap, reinterpret_cast<VkTimelineSemaphoreSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            handlemap_VkPhysicalDeviceBufferDeviceAddressFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {
            handlemap_VkBufferOpaqueCaptureAddressCreateInfo(
                handlemap,
                reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {
            handlemap_VkMemoryOpaqueCaptureAddressAllocateInfo(
                handlemap,
                reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_VERSION_1_3
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {
            handlemap_VkPhysicalDeviceVulkan13Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan13Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: {
            handlemap_VkPhysicalDeviceVulkan13Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceVulkan13Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {
            handlemap_VkPipelineCreationFeedbackCreateInfo(
                handlemap,
                reinterpret_cast<VkPipelineCreationFeedbackCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {
            handlemap_VkPhysicalDeviceShaderTerminateInvocationFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {
            handlemap_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(
                    structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {
            handlemap_VkPhysicalDevicePrivateDataFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePrivateDataFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: {
            handlemap_VkDevicePrivateDataCreateInfo(
                handlemap, reinterpret_cast<VkDevicePrivateDataCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {
            handlemap_VkPhysicalDevicePipelineCreationCacheControlFeatures(
                handlemap, reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {
            handlemap_VkMemoryBarrier2(handlemap,
                                       reinterpret_cast<VkMemoryBarrier2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {
            handlemap_VkPhysicalDeviceSynchronization2Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceSynchronization2Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {
            handlemap_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {
            handlemap_VkPhysicalDeviceImageRobustnessFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceImageRobustnessFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {
            handlemap_VkPhysicalDeviceSubgroupSizeControlFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: {
            handlemap_VkPhysicalDeviceSubgroupSizeControlProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {
            handlemap_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
                handlemap, reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {
            handlemap_VkPhysicalDeviceInlineUniformBlockFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: {
            handlemap_VkPhysicalDeviceInlineUniformBlockProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceInlineUniformBlockProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: {
            handlemap_VkWriteDescriptorSetInlineUniformBlock(
                handlemap,
                reinterpret_cast<VkWriteDescriptorSetInlineUniformBlock*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: {
            handlemap_VkDescriptorPoolInlineUniformBlockCreateInfo(
                handlemap, reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfo*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {
            handlemap_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
            handlemap_VkPipelineRenderingCreateInfo(
                handlemap, reinterpret_cast<VkPipelineRenderingCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {
            handlemap_VkPhysicalDeviceDynamicRenderingFeatures(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDynamicRenderingFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {
            handlemap_VkCommandBufferInheritanceRenderingInfo(
                handlemap,
                reinterpret_cast<VkCommandBufferInheritanceRenderingInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {
            handlemap_VkPhysicalDeviceShaderIntegerDotProductFeatures(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderIntegerDotProductFeatures*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: {
            handlemap_VkPhysicalDeviceShaderIntegerDotProductProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceShaderIntegerDotProductProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: {
            handlemap_VkPhysicalDeviceTexelBufferAlignmentProperties(
                handlemap, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentProperties*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: {
            handlemap_VkFormatProperties3(
                handlemap, reinterpret_cast<VkFormatProperties3*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {
            handlemap_VkPhysicalDeviceMaintenance4Features(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance4Features*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: {
            handlemap_VkPhysicalDeviceMaintenance4Properties(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance4Properties*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {
            handlemap_VkImageSwapchainCreateInfoKHR(
                handlemap, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {
            handlemap_VkBindImageMemorySwapchainInfoKHR(
                handlemap,
                reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {
            handlemap_VkDeviceGroupPresentInfoKHR(
                handlemap, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {
            handlemap_VkDeviceGroupSwapchainCreateInfoKHR(
                handlemap,
                reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_dynamic_rendering
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {
            handlemap_VkRenderingFragmentShadingRateAttachmentInfoKHR(
                handlemap, reinterpret_cast<VkRenderingFragmentShadingRateAttachmentInfoKHR*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: {
            handlemap_VkRenderingFragmentDensityMapAttachmentInfoEXT(
                handlemap, reinterpret_cast<VkRenderingFragmentDensityMapAttachmentInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: {
            handlemap_VkAttachmentSampleCountInfoAMD(
                handlemap, reinterpret_cast<VkAttachmentSampleCountInfoAMD*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: {
            handlemap_VkMultiviewPerViewAttributesInfoNVX(
                handlemap,
                reinterpret_cast<VkMultiviewPerViewAttributesInfoNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {
            handlemap_VkPresentRegionsKHR(
                handlemap, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {
            handlemap_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_synchronization2
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {
            handlemap_VkQueueFamilyCheckpointProperties2NV(
                handlemap,
                reinterpret_cast<VkQueueFamilyCheckpointProperties2NV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_maintenance5
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR: {
            handlemap_VkPhysicalDeviceMaintenance5FeaturesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance5FeaturesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR: {
            handlemap_VkPhysicalDeviceMaintenance5PropertiesKHR(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceMaintenance5PropertiesKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR: {
            handlemap_VkPipelineCreateFlags2CreateInfoKHR(
                handlemap,
                reinterpret_cast<VkPipelineCreateFlags2CreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR: {
            handlemap_VkBufferUsageFlags2CreateInfoKHR(
                handlemap,
                reinterpret_cast<VkBufferUsageFlags2CreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID: {
            handlemap_VkNativeBufferANDROID(
                handlemap, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationStateStreamCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineVertexInputDivisorStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_provoking_vertex
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceProvokingVertexFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceProvokingVertexFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceProvokingVertexPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceProvokingVertexPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceLineRasterizationFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceLineRasterizationPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
            handlemap_VkPipelineRasterizationLineStateCreateInfoEXT(
                handlemap, reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_host_image_copy
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceHostImageCopyFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceHostImageCopyFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceHostImageCopyPropertiesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceHostImageCopyPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT: {
            handlemap_VkSubresourceHostMemcpySizeEXT(
                handlemap, reinterpret_cast<VkSubresourceHostMemcpySizeEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT: {
            handlemap_VkHostImageCopyDevicePerformanceQueryEXT(
                handlemap,
                reinterpret_cast<VkHostImageCopyDevicePerformanceQueryEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_swapchain_maintenance1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {
            handlemap_VkSwapchainPresentFenceInfoEXT(
                handlemap, reinterpret_cast<VkSwapchainPresentFenceInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: {
            handlemap_VkSwapchainPresentModesCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkSwapchainPresentModesCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: {
            handlemap_VkSwapchainPresentModeInfoEXT(
                handlemap, reinterpret_cast<VkSwapchainPresentModeInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: {
            handlemap_VkSwapchainPresentScalingCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkSwapchainPresentScalingCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: {
            handlemap_VkDeviceDeviceMemoryReportCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {
            handlemap_VkSamplerCustomBorderColorCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_graphics_pipeline_library
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: {
            handlemap_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: {
            handlemap_VkGraphicsPipelineLibraryCreateInfoEXT(
                handlemap,
                reinterpret_cast<VkGraphicsPipelineLibraryCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_2plane_444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_compression_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImageCompressionControlFeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(
                               structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: {
            handlemap_VkImageCompressionControlEXT(
                handlemap, reinterpret_cast<VkImageCompressionControlEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: {
            handlemap_VkImageCompressionPropertiesEXT(
                handlemap, reinterpret_cast<VkImageCompressionPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {
            handlemap_VkPhysicalDevice4444FormatsFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_primitive_topology_list_restart
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {
            handlemap_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
                handlemap, reinterpret_cast<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(
                               structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE: {
            handlemap_VkImportColorBufferGOOGLE(
                handlemap, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE: {
            handlemap_VkImportBufferGOOGLE(
                handlemap, reinterpret_cast<VkImportBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_CREATE_BLOB_GOOGLE: {
            handlemap_VkCreateBlobGOOGLE(
                handlemap, reinterpret_cast<VkCreateBlobGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_image_compression_control_swapchain
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: {
            handlemap_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
                handlemap,
                reinterpret_cast<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(
                    structExtension_out));
            break;
        }
#endif
        default: {
            return;
        }
    }
}

}  // namespace vk
}  // namespace gfxstream
