// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkDecoderSnapshot
//
// (impl) generated by scripts/genvk.py -registry
// ../../../../../hardware/google/gfxstream/codegen/vulkan/vulkan-docs-next/xml/vk.xml
// -registryGfxstream xml/vk_gfxstream.xml cereal -o
// ../../../../../hardware/google/gfxstream/host/vulkan/cereal
//
// Please do not modify directly;
// re-run mesa3d/src/gfxstream/codegen/generate-gfxstream-vulkan.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing vk.xml
// VULKAN_REGISTRY_SCRIPTS_DIR : Directory containing genvk.py
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
//
// python3 $VULKAN_REGISTRY_SCRIPTS_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o
// $CEREAL_OUTPUT_DIR
//

#include "VkDecoderSnapshot.h"

#include <mutex>

#include "VkDecoderGlobalState.h"
#include "VkReconstruction.h"
#include "VulkanBoxedHandles.h"
#include "VulkanHandleMapping.h"
#include "aemu/base/ThreadAnnotations.h"

using emugl::GfxApiLogger;
using emugl::HealthMonitor;

namespace gfxstream {
namespace vk {

class VkDecoderSnapshot::Impl {
   public:
    Impl() {}

    void clear() {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        mReconstruction.clear();
    }

    void saveReplayBuffers(android::base::Stream* stream) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        mReconstruction.saveReplayBuffers(stream);
    }

    static void loadReplayBuffers(android::base::Stream* stream,
                                  std::vector<uint64_t>* outHandleBuffer,
                                  std::vector<uint8_t>* outDecoderBuffer) {
        VkReconstruction::loadReplayBuffers(stream, outHandleBuffer, outDecoderBuffer);
    }

    VkSnapshotApiCallInfo* createApiCallInfo() {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        return mReconstruction.createApiCallInfo();
    }

    void destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        return mReconstruction.destroyApiCallInfoIfUnused(info);
    }
#ifdef VK_VERSION_1_0
    void vkCreateInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, const VkInstanceCreateInfo* pCreateInfo,
                          const VkAllocationCallbacks* pAllocator, VkInstance* pInstance) {
        if (!pInstance) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pInstance create
        mReconstruction.addHandles((const uint64_t*)pInstance, 1);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pInstance, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pInstance, 1);
    }
    void vkDestroyInstance(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkInstance instance, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // instance destroy
        mReconstruction.removeHandles((const uint64_t*)(&instance), 1, true);
    }
    void vkEnumeratePhysicalDevices(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkResult input_result, VkInstance instance,
                                    uint32_t* pPhysicalDeviceCount,
                                    VkPhysicalDevice* pPhysicalDevices) {
        if (!pPhysicalDevices) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pPhysicalDevices create
        mReconstruction.addHandles((const uint64_t*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
        mReconstruction.addHandleDependency((const uint64_t*)pPhysicalDevices,
                                            (*(pPhysicalDeviceCount)),
                                            (uint64_t)(uintptr_t)instance);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        if (pPhysicalDeviceCount) {
            mReconstruction.forEachHandleAddApi((const uint64_t*)pPhysicalDevices,
                                                (*(pPhysicalDeviceCount)), apiCallHandle,
                                                VkReconstruction::CREATED);
            mReconstruction.setCreatedHandlesForApi(
                apiCallHandle, (const uint64_t*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
        }
    }
    void vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkPhysicalDevice physicalDevice,
                                     VkPhysicalDeviceFeatures* pFeatures) {}
    void vkGetPhysicalDeviceFormatProperties(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkPhysicalDevice physicalDevice, VkFormat format,
                                             VkFormatProperties* pFormatProperties) {}
    void vkGetPhysicalDeviceImageFormatProperties(android::base::BumpPool* pool,
                                                  VkSnapshotApiCallInfo* apiCallInfo,
                                                  const uint8_t* apiCallPacket,
                                                  size_t apiCallPacketSize, VkResult input_result,
                                                  VkPhysicalDevice physicalDevice, VkFormat format,
                                                  VkImageType type, VkImageTiling tiling,
                                                  VkImageUsageFlags usage, VkImageCreateFlags flags,
                                                  VkImageFormatProperties* pImageFormatProperties) {
    }
    void vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkPhysicalDevice physicalDevice,
                                       VkPhysicalDeviceProperties* pProperties) {}
    void vkGetPhysicalDeviceQueueFamilyProperties(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {}
    void vkGetPhysicalDeviceMemoryProperties(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkPhysicalDevice physicalDevice,
                                             VkPhysicalDeviceMemoryProperties* pMemoryProperties) {}
    void vkGetInstanceProcAddr(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               PFN_vkVoidFunction input_result, VkInstance instance,
                               const char* pName) {}
    void vkGetDeviceProcAddr(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             PFN_vkVoidFunction input_result, VkDevice device, const char* pName) {}
    void vkCreateDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                        VkResult input_result, VkPhysicalDevice physicalDevice,
                        const VkDeviceCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
        if (!pDevice) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDevice create
        mReconstruction.addHandles((const uint64_t*)pDevice, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pDevice, 1,
                                            (uint64_t)(uintptr_t)physicalDevice);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pDevice, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pDevice, 1);
    }
    void vkDestroyDevice(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                         const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // device destroy
        mReconstruction.removeHandles((const uint64_t*)(&device), 1, true);
    }
    void vkEnumerateInstanceExtensionProperties(android::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* apiCallInfo,
                                                const uint8_t* apiCallPacket,
                                                size_t apiCallPacketSize, VkResult input_result,
                                                const char* pLayerName, uint32_t* pPropertyCount,
                                                VkExtensionProperties* pProperties) {}
    void vkEnumerateDeviceExtensionProperties(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkResult input_result,
                                              VkPhysicalDevice physicalDevice,
                                              const char* pLayerName, uint32_t* pPropertyCount,
                                              VkExtensionProperties* pProperties) {}
    void vkEnumerateInstanceLayerProperties(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, uint32_t* pPropertyCount,
                                            VkLayerProperties* pProperties) {}
    void vkEnumerateDeviceLayerProperties(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkPhysicalDevice physicalDevice,
                                          uint32_t* pPropertyCount,
                                          VkLayerProperties* pProperties) {}
    void vkGetDeviceQueue(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                          uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue) {}
    void vkQueueSubmit(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkResult input_result, VkQueue queue, uint32_t submitCount,
                       const VkSubmitInfo* pSubmits, VkFence fence) {}
    void vkQueueWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkResult input_result, VkQueue queue) {}
    void vkDeviceWaitIdle(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, VkDevice device) {}
    void vkAllocateMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, VkDevice device,
                          const VkMemoryAllocateInfo* pAllocateInfo,
                          const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory) {
        if (!pMemory) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pMemory create
        mReconstruction.addHandles((const uint64_t*)pMemory, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pMemory, 1,
                                            (uint64_t)(uintptr_t)device);
        const VkMemoryDedicatedAllocateInfo* dedicatedAllocateInfo =
            vk_find_struct<VkMemoryDedicatedAllocateInfo>(pAllocateInfo);
        if (dedicatedAllocateInfo) {
            if (dedicatedAllocateInfo->image) {
                mReconstruction.addHandleDependency(
                    (const uint64_t*)pMemory, 1,
                    (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImage(
                        dedicatedAllocateInfo->image));
            }
            if (dedicatedAllocateInfo->buffer) {
                mReconstruction.addHandleDependency(
                    (const uint64_t*)pMemory, 1,
                    (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkBuffer(
                        dedicatedAllocateInfo->buffer));
            }
        }
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pMemory, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pMemory, 1);
    }
    void vkFreeMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                      const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                      VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // memory destroy
        mReconstruction.removeHandles((const uint64_t*)(&memory), 1, true);
    }
    void vkMapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                     const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
                     VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
                     VkMemoryMapFlags flags, void** ppData) {}
    void vkUnmapMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                       VkDeviceMemory memory) {}
    void vkFlushMappedMemoryRanges(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
                                   uint32_t memoryRangeCount,
                                   const VkMappedMemoryRange* pMemoryRanges) {}
    void vkInvalidateMappedMemoryRanges(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkDevice device,
                                        uint32_t memoryRangeCount,
                                        const VkMappedMemoryRange* pMemoryRanges) {}
    void vkGetDeviceMemoryCommitment(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkDevice device, VkDeviceMemory memory,
                                     VkDeviceSize* pCommittedMemoryInBytes) {}
    void vkBindBufferMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkDevice device, VkBuffer buffer,
                            VkDeviceMemory memory, VkDeviceSize memoryOffset) {
        VkBuffer boxed_VkBuffer = unboxed_to_boxed_non_dispatchable_VkBuffer((&buffer)[0]);
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // buffer create
        mReconstruction.addHandleDependency(
            (const uint64_t*)&boxed_VkBuffer, 1,
            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDeviceMemory(memory),
            VkReconstruction::BOUND_MEMORY);
        mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkBuffer, 1,
                                            (uint64_t)(uintptr_t)((&boxed_VkBuffer)[0]),
                                            VkReconstruction::BOUND_MEMORY);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkBuffer, 1, apiCallHandle,
                                            VkReconstruction::BOUND_MEMORY);
    }
    void vkBindImageMemory(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkDevice device, VkImage image,
                           VkDeviceMemory memory, VkDeviceSize memoryOffset) {
        VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage((&image)[0]);
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // image create
        mReconstruction.addHandleDependency(
            (const uint64_t*)&boxed_VkImage, 1,
            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDeviceMemory(memory),
            VkReconstruction::BOUND_MEMORY);
        mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkImage, 1,
                                            (uint64_t)(uintptr_t)((&boxed_VkImage)[0]),
                                            VkReconstruction::BOUND_MEMORY);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiCallHandle,
                                            VkReconstruction::BOUND_MEMORY);
    }
    void vkGetBufferMemoryRequirements(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkDevice device, VkBuffer buffer,
                                       VkMemoryRequirements* pMemoryRequirements) {}
    void vkGetImageMemoryRequirements(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkDevice device, VkImage image,
                                      VkMemoryRequirements* pMemoryRequirements) {}
    void vkGetImageSparseMemoryRequirements(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device, VkImage image,
        uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {}
    void vkGetPhysicalDeviceSparseImageFormatProperties(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage,
        VkImageTiling tiling, uint32_t* pPropertyCount,
        VkSparseImageFormatProperties* pProperties) {}
    void vkQueueBindSparse(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkQueue queue, uint32_t bindInfoCount,
                           const VkBindSparseInfo* pBindInfo, VkFence fence) {}
    void vkCreateFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkResult input_result, VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                       const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
        if (!pFence) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pFence create
        mReconstruction.addHandles((const uint64_t*)pFence, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pFence, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pFence, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pFence, 1);
    }
    void vkDestroyFence(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                        VkFence fence, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // fence destroy
        mReconstruction.removeHandles((const uint64_t*)(&fence), 1, true);
    }
    void vkResetFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkResult input_result, VkDevice device, uint32_t fenceCount,
                       const VkFence* pFences) {}
    void vkGetFenceStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, VkDevice device, VkFence fence) {}
    void vkWaitForFences(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkResult input_result, VkDevice device, uint32_t fenceCount,
                         const VkFence* pFences, VkBool32 waitAll, uint64_t timeout) {}
    void vkCreateSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkDevice device,
                           const VkSemaphoreCreateInfo* pCreateInfo,
                           const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore) {
        if (!pSemaphore) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pSemaphore create
        mReconstruction.addHandles((const uint64_t*)pSemaphore, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pSemaphore, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pSemaphore, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSemaphore, 1);
    }
    void vkDestroySemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // semaphore destroy
        mReconstruction.removeHandles((const uint64_t*)(&semaphore), 1, true);
    }
    void vkCreateEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkResult input_result, VkDevice device, const VkEventCreateInfo* pCreateInfo,
                       const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
        if (!pEvent) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pEvent create
        mReconstruction.addHandles((const uint64_t*)pEvent, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pEvent, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pEvent, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pEvent, 1);
    }
    void vkDestroyEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                        VkEvent event, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // event destroy
        mReconstruction.removeHandles((const uint64_t*)(&event), 1, true);
    }
    void vkGetEventStatus(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, VkDevice device, VkEvent event) {}
    void vkSetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                    const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
                    VkDevice device, VkEvent event) {}
    void vkResetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                      const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
                      VkDevice device, VkEvent event) {}
    void vkCreateQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkDevice device,
                           const VkQueryPoolCreateInfo* pCreateInfo,
                           const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool) {
        if (!pQueryPool) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pQueryPool create
        mReconstruction.addHandles((const uint64_t*)pQueryPool, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pQueryPool, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pQueryPool, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pQueryPool, 1);
    }
    void vkDestroyQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // queryPool destroy
        mReconstruction.removeHandles((const uint64_t*)(&queryPool), 1, true);
    }
    void vkGetQueryPoolResults(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device, VkQueryPool queryPool,
                               uint32_t firstQuery, uint32_t queryCount, size_t dataSize,
                               void* pData, VkDeviceSize stride, VkQueryResultFlags flags) {}
    void vkCreateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                        VkResult input_result, VkDevice device,
                        const VkBufferCreateInfo* pCreateInfo,
                        const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
        if (!pBuffer) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pBuffer create
        mReconstruction.addHandles((const uint64_t*)pBuffer, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pBuffer, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pBuffer, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pBuffer, 1);
    }
    void vkDestroyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                         VkBuffer buffer, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // buffer destroy
        mReconstruction.removeHandles((const uint64_t*)(&buffer), 1, true);
    }
    void vkCreateBufferView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkDevice device,
                            const VkBufferViewCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkBufferView* pView) {
        if (!pView) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pView create
        mReconstruction.addHandles((const uint64_t*)pView, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pView, 1, (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pView, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pView, 1);
    }
    void vkDestroyBufferView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkDevice device, VkBufferView bufferView,
                             const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // bufferView destroy
        mReconstruction.removeHandles((const uint64_t*)(&bufferView), 1, true);
    }
    void vkCreateImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkResult input_result, VkDevice device, const VkImageCreateInfo* pCreateInfo,
                       const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
        if (!pImage) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pImage create
        mReconstruction.addHandles((const uint64_t*)pImage, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pImage, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pImage, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pImage, 1);
    }
    void vkDestroyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                        VkImage image, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // image destroy
        mReconstruction.removeHandles((const uint64_t*)(&image), 1, true);
    }
    void vkGetImageSubresourceLayout(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkDevice device, VkImage image,
                                     const VkImageSubresource* pSubresource,
                                     VkSubresourceLayout* pLayout) {}
    void vkCreateImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkDevice device,
                           const VkImageViewCreateInfo* pCreateInfo,
                           const VkAllocationCallbacks* pAllocator, VkImageView* pView) {
        if (!pView) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pView create
        mReconstruction.addHandles((const uint64_t*)pView, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pView, 1, (uint64_t)(uintptr_t)device);
        mReconstruction.addHandleDependency(
            (const uint64_t*)pView, 1,
            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImage(pCreateInfo->image),
            VkReconstruction::CREATED, VkReconstruction::BOUND_MEMORY);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pView, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pView, 1);
    }
    void vkDestroyImageView(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                            VkImageView imageView, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // imageView destroy
        mReconstruction.removeHandles((const uint64_t*)(&imageView), 1, true);
    }
    void vkCreateShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkResult input_result, VkDevice device,
                              const VkShaderModuleCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator,
                              VkShaderModule* pShaderModule) {
        if (!pShaderModule) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pShaderModule create
        mReconstruction.addHandles((const uint64_t*)pShaderModule, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pShaderModule, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pShaderModule, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pShaderModule, 1);
    }
    void vkDestroyShaderModule(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkDevice device, VkShaderModule shaderModule,
                               const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // shaderModule destroy
        mReconstruction.removeHandles((const uint64_t*)(&shaderModule), 1, false);
    }
    void vkCreatePipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device,
                               const VkPipelineCacheCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator,
                               VkPipelineCache* pPipelineCache) {
        if (!pPipelineCache) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pPipelineCache create
        mReconstruction.addHandles((const uint64_t*)pPipelineCache, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pPipelineCache, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelineCache, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelineCache, 1);
    }
    void vkDestroyPipelineCache(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkDevice device, VkPipelineCache pipelineCache,
                                const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pipelineCache destroy
        mReconstruction.removeHandles((const uint64_t*)(&pipelineCache), 1, true);
    }
    void vkGetPipelineCacheData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                VkPipelineCache pipelineCache, size_t* pDataSize, void* pData) {}
    void vkMergePipelineCaches(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device, VkPipelineCache dstCache,
                               uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches) {}
    void vkCreateGraphicsPipelines(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
                                   VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                   const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                   const VkAllocationCallbacks* pAllocator,
                                   VkPipeline* pPipelines) {
        if (!pPipelines) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pPipelines create
        mReconstruction.addHandles((const uint64_t*)pPipelines, ((createInfoCount)));
        mReconstruction.addHandleDependency((const uint64_t*)pPipelines, ((createInfoCount)),
                                            (uint64_t)(uintptr_t)device);
        for (uint32_t i = 0; i < createInfoCount; ++i) {
            for (uint32_t j = 0; j < pCreateInfos[i].stageCount; ++j) {
                mReconstruction.addHandleDependency(
                    (const uint64_t*)(pPipelines + i), 1,
                    (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkShaderModule(
                        pCreateInfos[i].pStages[j].module));
            }
            mReconstruction.addHandleDependency(
                (const uint64_t*)(pPipelines + i), 1,
                (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkRenderPass(
                    pCreateInfos[i].renderPass));
        }
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelines, ((createInfoCount)),
                                            apiCallHandle, VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelines,
                                                ((createInfoCount)));
    }
    void vkCreateComputePipelines(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkResult input_result, VkDevice device,
                                  VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                  const VkComputePipelineCreateInfo* pCreateInfos,
                                  const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
        if (!pPipelines) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pPipelines create
        mReconstruction.addHandles((const uint64_t*)pPipelines, ((createInfoCount)));
        mReconstruction.addHandleDependency((const uint64_t*)pPipelines, ((createInfoCount)),
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelines, ((createInfoCount)),
                                            apiCallHandle, VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelines,
                                                ((createInfoCount)));
    }
    void vkDestroyPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                           VkPipeline pipeline, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pipeline destroy
        mReconstruction.removeHandles((const uint64_t*)(&pipeline), 1, true);
    }
    void vkCreatePipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkPipelineLayoutCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator,
                                VkPipelineLayout* pPipelineLayout) {
        if (!pPipelineLayout) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pPipelineLayout create
        mReconstruction.addHandles((const uint64_t*)pPipelineLayout, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pPipelineLayout, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pPipelineLayout, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPipelineLayout, 1);
    }
    void vkDestroyPipelineLayout(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkDevice device, VkPipelineLayout pipelineLayout,
                                 const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pipelineLayout destroy
        mReconstruction.removeHandles((const uint64_t*)(&pipelineLayout), 1, true);
    }
    void vkCreateSampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkResult input_result, VkDevice device,
                         const VkSamplerCreateInfo* pCreateInfo,
                         const VkAllocationCallbacks* pAllocator, VkSampler* pSampler) {
        if (!pSampler) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pSampler create
        mReconstruction.addHandles((const uint64_t*)pSampler, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pSampler, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pSampler, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSampler, 1);
    }
    void vkDestroySampler(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                          VkSampler sampler, const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // sampler destroy
        mReconstruction.removeHandles((const uint64_t*)(&sampler), 1, true);
    }
    void vkCreateDescriptorSetLayout(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkResult input_result, VkDevice device,
                                     const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkDescriptorSetLayout* pSetLayout) {
        if (!pSetLayout) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pSetLayout create
        mReconstruction.addHandles((const uint64_t*)pSetLayout, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pSetLayout, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pSetLayout, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSetLayout, 1);
    }
    void vkDestroyDescriptorSetLayout(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
                                      const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // descriptorSetLayout destroy
        mReconstruction.removeHandles((const uint64_t*)(&descriptorSetLayout), 1, true);
    }
    void vkCreateDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkDescriptorPoolCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator,
                                VkDescriptorPool* pDescriptorPool) {
        if (!pDescriptorPool) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDescriptorPool create
        mReconstruction.addHandles((const uint64_t*)pDescriptorPool, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pDescriptorPool, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorPool, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pDescriptorPool, 1);
    }
    void vkDestroyDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkDevice device, VkDescriptorPool descriptorPool,
                                 const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // descriptorPool destroy
        mReconstruction.removeHandles((const uint64_t*)(&descriptorPool), 1, true);
    }
    void vkResetDescriptorPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device,
                               VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) {}
    void vkAllocateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkResult input_result, VkDevice device,
                                  const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                  VkDescriptorSet* pDescriptorSets) {
        if (!pDescriptorSets) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDescriptorSets create
        mReconstruction.addHandles((const uint64_t*)pDescriptorSets,
                                   pAllocateInfo->descriptorSetCount);
        mReconstruction.addHandleDependency((const uint64_t*)pDescriptorSets,
                                            pAllocateInfo->descriptorSetCount,
                                            (uint64_t)(uintptr_t)device);
        mReconstruction.addHandleDependency(
            (const uint64_t*)pDescriptorSets, pAllocateInfo->descriptorSetCount,
            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDescriptorPool(
                pAllocateInfo->descriptorPool));
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorSets,
                                            pAllocateInfo->descriptorSetCount, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pDescriptorSets,
                                                pAllocateInfo->descriptorSetCount);
    }
    void vkFreeDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkResult input_result, VkDevice device,
                              VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                              const VkDescriptorSet* pDescriptorSets) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDescriptorSets destroy
        mReconstruction.removeHandles((const uint64_t*)pDescriptorSets, ((descriptorSetCount)),
                                      true);
    }
    void vkUpdateDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkDevice device, uint32_t descriptorWriteCount,
                                const VkWriteDescriptorSet* pDescriptorWrites,
                                uint32_t descriptorCopyCount,
                                const VkCopyDescriptorSet* pDescriptorCopies) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDescriptorWrites action
        VkDecoderGlobalState* m_state = VkDecoderGlobalState::get();
        if (m_state->batchedDescriptorSetUpdateEnabled()) {
            return;
        }
        uint64_t handle = m_state->newGlobalVkGenericHandle();
        mReconstruction.addHandles((const uint64_t*)(&handle), 1);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < descriptorWriteCount; ++i) {
            mReconstruction.addHandleDependency(
                (const uint64_t*)(&handle), 1,
                (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkDescriptorSet(
                    pDescriptorWrites[i].dstSet));
            for (uint32_t j = 0; j < pDescriptorWrites[i].descriptorCount; ++j) {
                if ((pDescriptorWrites[i].pImageInfo)) {
                    if (pDescriptorWrites[i].descriptorType ==
                        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) {
                        mReconstruction.addHandleDependency(
                            (const uint64_t*)(&handle), 1,
                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkSampler(
                                pDescriptorWrites[i].pImageInfo[j].sampler));
                        mReconstruction.addHandleDependency(
                            (const uint64_t*)(&handle), 1,
                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImageView(
                                pDescriptorWrites[i].pImageInfo[j].imageView));
                    }
                    if (pDescriptorWrites[i].descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) {
                        mReconstruction.addHandleDependency(
                            (const uint64_t*)(&handle), 1,
                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkSampler(
                                pDescriptorWrites[i].pImageInfo[j].sampler));
                    }
                }
                if (pDescriptorWrites[i].pBufferInfo) {
                    if (pDescriptorWrites[i].descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) {
                        mReconstruction.addHandleDependency(
                            (const uint64_t*)(&handle), 1,
                            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkBuffer(
                                pDescriptorWrites[i].pBufferInfo[j].buffer));
                    }
                }
            }
        }
        mReconstruction.forEachHandleAddApi((const uint64_t*)(&handle), 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)(&handle), 1);
    }
    void vkCreateFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkResult input_result, VkDevice device,
                             const VkFramebufferCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer) {
        if (!pFramebuffer) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pFramebuffer create
        mReconstruction.addHandles((const uint64_t*)pFramebuffer, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pFramebuffer, 1,
                                            (uint64_t)(uintptr_t)device);
        mReconstruction.addHandleDependency(
            (const uint64_t*)pFramebuffer, 1,
            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkRenderPass(
                pCreateInfo->renderPass));
        for (uint32_t i = 0; i < pCreateInfo->attachmentCount; ++i) {
            mReconstruction.addHandleDependency(
                (const uint64_t*)pFramebuffer, 1,
                (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkImageView(
                    pCreateInfo->pAttachments[i]));
        }
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pFramebuffer, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pFramebuffer, 1);
    }
    void vkDestroyFramebuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkDevice device, VkFramebuffer framebuffer,
                              const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // framebuffer destroy
        mReconstruction.removeHandles((const uint64_t*)(&framebuffer), 1, true);
    }
    void vkCreateRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkDevice device,
                            const VkRenderPassCreateInfo* pCreateInfo,
                            const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
        if (!pRenderPass) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pRenderPass create
        mReconstruction.addHandles((const uint64_t*)pRenderPass, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pRenderPass, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pRenderPass, 1);
    }
    void vkDestroyRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkDevice device, VkRenderPass renderPass,
                             const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // renderPass destroy
        mReconstruction.removeHandles((const uint64_t*)(&renderPass), 1, true);
    }
    void vkGetRenderAreaGranularity(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkDevice device, VkRenderPass renderPass,
                                    VkExtent2D* pGranularity) {}
    void vkCreateCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkResult input_result, VkDevice device,
                             const VkCommandPoolCreateInfo* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool) {
        if (!pCommandPool) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pCommandPool create
        mReconstruction.addHandles((const uint64_t*)pCommandPool, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pCommandPool, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pCommandPool, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pCommandPool, 1);
    }
    void vkDestroyCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkDevice device, VkCommandPool commandPool,
                              const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandPool destroy
        mReconstruction.removeHandles((const uint64_t*)(&commandPool), 1, true);
    }
    void vkResetCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkDevice device, VkCommandPool commandPool,
                            VkCommandPoolResetFlags flags) {}
    void vkAllocateCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkResult input_result, VkDevice device,
                                  const VkCommandBufferAllocateInfo* pAllocateInfo,
                                  VkCommandBuffer* pCommandBuffers) {
        if (!pCommandBuffers) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pCommandBuffers create
        mReconstruction.addHandles((const uint64_t*)pCommandBuffers,
                                   pAllocateInfo->commandBufferCount);
        mReconstruction.addHandleDependency(
            (const uint64_t*)pCommandBuffers, pAllocateInfo->commandBufferCount,
            (uint64_t)(uintptr_t)unboxed_to_boxed_non_dispatchable_VkCommandPool(
                pAllocateInfo->commandPool));
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pCommandBuffers,
                                            pAllocateInfo->commandBufferCount, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pCommandBuffers,
                                                pAllocateInfo->commandBufferCount);
    }
    void vkFreeCommandBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkDevice device, VkCommandPool commandPool,
                              uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pCommandBuffers destroy
        mReconstruction.removeHandles((const uint64_t*)pCommandBuffers, ((commandBufferCount)),
                                      true);
    }
    void vkBeginCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkResult input_result, VkCommandBuffer commandBuffer,
                              const VkCommandBufferBeginInfo* pBeginInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkEndCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkCommandBuffer commandBuffer) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkResetCommandBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkResult input_result, VkCommandBuffer commandBuffer,
                              VkCommandBufferResetFlags flags) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleClearModifyApi((const uint64_t*)(&boxed), 1);
        }
    }
    void vkCmdBindPipeline(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                           VkPipeline pipeline) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetViewport(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, uint32_t firstViewport,
                          uint32_t viewportCount, const VkViewport* pViewports) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetScissor(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, uint32_t firstScissor,
                         uint32_t scissorCount, const VkRect2D* pScissors) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetLineWidth(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, float lineWidth) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthBias(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, float depthBiasConstantFactor,
                           float depthBiasClamp, float depthBiasSlopeFactor) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetBlendConstants(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, const float blendConstants[4]) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthBounds(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, float minDepthBounds,
                             float maxDepthBounds) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilCompareMask(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                    uint32_t compareMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilWriteMask(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                  uint32_t writeMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilReference(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                  uint32_t reference) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBindDescriptorSets(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer,
                                 VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                 uint32_t firstSet, uint32_t descriptorSetCount,
                                 const VkDescriptorSet* pDescriptorSets,
                                 uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBindIndexBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                              VkIndexType indexType) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBindVertexBuffers(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                uint32_t bindingCount, const VkBuffer* pBuffers,
                                const VkDeviceSize* pOffsets) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDraw(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                   const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                   VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
                   uint32_t firstVertex, uint32_t firstInstance) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDrawIndexed(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, uint32_t indexCount,
                          uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset,
                          uint32_t firstInstance) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDrawIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                           uint32_t drawCount, uint32_t stride) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDrawIndexedIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, VkBuffer buffer,
                                  VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDispatch(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                       uint32_t groupCountZ) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDispatchIndirect(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkCommandBuffer commandBuffer, VkBuffer buffer,
                               VkDeviceSize offset) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer,
                         uint32_t regionCount, const VkBufferCopy* pRegions) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                        VkCommandBuffer commandBuffer, VkImage srcImage,
                        VkImageLayout srcImageLayout, VkImage dstImage,
                        VkImageLayout dstImageLayout, uint32_t regionCount,
                        const VkImageCopy* pRegions) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBlitImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                        VkCommandBuffer commandBuffer, VkImage srcImage,
                        VkImageLayout srcImageLayout, VkImage dstImage,
                        VkImageLayout dstImageLayout, uint32_t regionCount,
                        const VkImageBlit* pRegions, VkFilter filter) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyBufferToImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
                                VkImageLayout dstImageLayout, uint32_t regionCount,
                                const VkBufferImageCopy* pRegions) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyImageToBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, VkImage srcImage,
                                VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                uint32_t regionCount, const VkBufferImageCopy* pRegions) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdUpdateBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                           VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdFillBuffer(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                         VkDeviceSize size, uint32_t data) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdClearColorImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, VkImage image,
                              VkImageLayout imageLayout, const VkClearColorValue* pColor,
                              uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdClearDepthStencilImage(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkCommandBuffer commandBuffer, VkImage image,
                                     VkImageLayout imageLayout,
                                     const VkClearDepthStencilValue* pDepthStencil,
                                     uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdClearAttachments(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                               const VkClearAttachment* pAttachments, uint32_t rectCount,
                               const VkClearRect* pRects) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResolveImage(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkImage srcImage,
                           VkImageLayout srcImageLayout, VkImage dstImage,
                           VkImageLayout dstImageLayout, uint32_t regionCount,
                           const VkImageResolve* pRegions) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkCommandBuffer commandBuffer, VkEvent event,
                       VkPipelineStageFlags stageMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResetEvent(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, VkEvent event,
                         VkPipelineStageFlags stageMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdWaitEvents(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                         VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
                         uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                         uint32_t bufferMemoryBarrierCount,
                         const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                         uint32_t imageMemoryBarrierCount,
                         const VkImageMemoryBarrier* pImageMemoryBarriers) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdPipelineBarrier(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
                              VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
                              uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                              uint32_t bufferMemoryBarrierCount,
                              const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                              uint32_t imageMemoryBarrierCount,
                              const VkImageMemoryBarrier* pImageMemoryBarriers) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBeginQuery(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                         VkQueryControlFlags flags) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndQuery(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                       VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResetQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                             uint32_t firstQuery, uint32_t queryCount) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdWriteTimestamp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
                             VkQueryPool queryPool, uint32_t query) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyQueryPoolResults(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                   VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
                                   VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride,
                                   VkQueryResultFlags flags) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdPushConstants(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                            VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
                            const void* pValues) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBeginRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer,
                              const VkRenderPassBeginInfo* pRenderPassBegin,
                              VkSubpassContents contents) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdNextSubpass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, VkSubpassContents contents) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndRenderPass(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdExecuteCommands(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                              const VkCommandBuffer* pCommandBuffers) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_VERSION_1_1
    void vkEnumerateInstanceVersion(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkResult input_result, uint32_t* pApiVersion) {}
    void vkBindBufferMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                             const VkBindBufferMemoryInfo* pBindInfos) {}
    void vkBindImageMemory2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                            const VkBindImageMemoryInfo* pBindInfos) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
            VkDeviceMemory boxed_VkDeviceMemory =
                unboxed_to_boxed_non_dispatchable_VkDeviceMemory(pBindInfos[i].memory);
            mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkImage, 1,
                                                (uint64_t)(uintptr_t)boxed_VkDeviceMemory,
                                                VkReconstruction::BOUND_MEMORY);
            mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkImage, 1,
                                                (uint64_t)(uintptr_t)boxed_VkImage,
                                                VkReconstruction::BOUND_MEMORY);
        }
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        // Note: the implementation does not work with bindInfoCount > 1
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
            mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiCallHandle,
                                                VkReconstruction::BOUND_MEMORY);
        }
    }
    void vkGetDeviceGroupPeerMemoryFeatures(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, uint32_t heapIndex,
                                            uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
                                            VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {}
    void vkCmdSetDeviceMask(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer, uint32_t deviceMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDispatchBase(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                           uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
                           uint32_t groupCountZ) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkEnumeratePhysicalDeviceGroups(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {}
    void vkGetImageMemoryRequirements2(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
                                       VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetBufferMemoryRequirements2(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkDevice device,
                                        const VkBufferMemoryRequirementsInfo2* pInfo,
                                        VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetImageSparseMemoryRequirements2(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
    void vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkPhysicalDevice physicalDevice,
                                      VkPhysicalDeviceFeatures2* pFeatures) {}
    void vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkPhysicalDevice physicalDevice,
                                        VkPhysicalDeviceProperties2* pProperties) {}
    void vkGetPhysicalDeviceFormatProperties2(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize,
                                              VkPhysicalDevice physicalDevice, VkFormat format,
                                              VkFormatProperties2* pFormatProperties) {}
    void vkGetPhysicalDeviceImageFormatProperties2(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
        VkImageFormatProperties2* pImageFormatProperties) {}
    void vkGetPhysicalDeviceQueueFamilyProperties2(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {}
    void vkGetPhysicalDeviceMemoryProperties2(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {}
    void vkGetPhysicalDeviceSparseImageFormatProperties2(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
        VkSparseImageFormatProperties2* pProperties) {}
    void vkTrimCommandPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                           VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {}
    void vkGetDeviceQueue2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                           const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue) {}
    void vkCreateSamplerYcbcrConversion(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkDevice device,
                                        const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkSamplerYcbcrConversion* pYcbcrConversion) {
        if (!pYcbcrConversion) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pYcbcrConversion create
        mReconstruction.addHandles((const uint64_t*)pYcbcrConversion, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pYcbcrConversion, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pYcbcrConversion, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pYcbcrConversion,
                                                1);
    }
    void vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                         const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // ycbcrConversion destroy
        mReconstruction.removeHandles((const uint64_t*)(&ycbcrConversion), 1, true);
    }
    void vkCreateDescriptorUpdateTemplate(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
        if (!pDescriptorUpdateTemplate) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDescriptorUpdateTemplate create
        mReconstruction.addHandles((const uint64_t*)pDescriptorUpdateTemplate, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pDescriptorUpdateTemplate, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorUpdateTemplate, 1,
                                            apiCallHandle, VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle,
                                                (const uint64_t*)pDescriptorUpdateTemplate, 1);
    }
    void vkDestroyDescriptorUpdateTemplate(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device,
                                           VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                           const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // descriptorUpdateTemplate destroy
        mReconstruction.removeHandles((const uint64_t*)(&descriptorUpdateTemplate), 1, true);
    }
    void vkUpdateDescriptorSetWithTemplate(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkDescriptorSet descriptorSet,
                                           VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                           const void* pData) {}
    void vkGetPhysicalDeviceExternalBufferProperties(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
        VkExternalBufferProperties* pExternalBufferProperties) {}
    void vkGetPhysicalDeviceExternalFenceProperties(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
        VkExternalFenceProperties* pExternalFenceProperties) {}
    void vkGetPhysicalDeviceExternalSemaphoreProperties(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {}
    void vkGetDescriptorSetLayoutSupport(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device,
                                         const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                         VkDescriptorSetLayoutSupport* pSupport) {}
#endif
#ifdef VK_VERSION_1_2
    void vkCmdDrawIndirectCount(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                uint32_t maxDrawCount, uint32_t stride) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDrawIndexedIndirectCount(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, VkBuffer buffer,
                                       VkDeviceSize offset, VkBuffer countBuffer,
                                       VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                       uint32_t stride) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCreateRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkResult input_result, VkDevice device,
                             const VkRenderPassCreateInfo2* pCreateInfo,
                             const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
        if (!pRenderPass) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pRenderPass create
        mReconstruction.addHandles((const uint64_t*)pRenderPass, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pRenderPass, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pRenderPass, 1);
    }
    void vkCmdBeginRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkCommandBuffer commandBuffer,
                               const VkRenderPassBeginInfo* pRenderPassBegin,
                               const VkSubpassBeginInfo* pSubpassBeginInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdNextSubpass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer,
                           const VkSubpassBeginInfo* pSubpassBeginInfo,
                           const VkSubpassEndInfo* pSubpassEndInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndRenderPass2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer,
                             const VkSubpassEndInfo* pSubpassEndInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkResetQueryPool(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                          VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {}
    void vkGetSemaphoreCounterValue(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkResult input_result, VkDevice device, VkSemaphore semaphore,
                                    uint64_t* pValue) {}
    void vkWaitSemaphores(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, VkDevice device,
                          const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {}
    void vkSignalSemaphore(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkDevice device,
                           const VkSemaphoreSignalInfo* pSignalInfo) {}
    void vkGetBufferDeviceAddress(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkDeviceAddress input_result, VkDevice device,
                                  const VkBufferDeviceAddressInfo* pInfo) {}
    void vkGetBufferOpaqueCaptureAddress(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         uint64_t input_result, VkDevice device,
                                         const VkBufferDeviceAddressInfo* pInfo) {}
    void vkGetDeviceMemoryOpaqueCaptureAddress(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, uint64_t input_result,
        VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {}
#endif
#ifdef VK_VERSION_1_3
    void vkGetPhysicalDeviceToolProperties(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkPhysicalDevice physicalDevice,
                                           uint32_t* pToolCount,
                                           VkPhysicalDeviceToolProperties* pToolProperties) {}
    void vkCreatePrivateDataSlot(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkResult input_result, VkDevice device,
                                 const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator,
                                 VkPrivateDataSlot* pPrivateDataSlot) {
        if (!pPrivateDataSlot) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pPrivateDataSlot create
        mReconstruction.addHandles((const uint64_t*)pPrivateDataSlot, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pPrivateDataSlot, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pPrivateDataSlot, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pPrivateDataSlot,
                                                1);
    }
    void vkDestroyPrivateDataSlot(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkDevice device, VkPrivateDataSlot privateDataSlot,
                                  const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // privateDataSlot destroy
        mReconstruction.removeHandles((const uint64_t*)(&privateDataSlot), 1, true);
    }
    void vkSetPrivateData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkResult input_result, VkDevice device, VkObjectType objectType,
                          uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    }
    void vkGetPrivateData(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
                          VkObjectType objectType, uint64_t objectHandle,
                          VkPrivateDataSlot privateDataSlot, uint64_t* pData) {}
    void vkCmdSetEvent2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                        VkCommandBuffer commandBuffer, VkEvent event,
                        const VkDependencyInfo* pDependencyInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResetEvent2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, VkEvent event,
                          VkPipelineStageFlags2 stageMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdWaitEvents2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, uint32_t eventCount,
                          const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdPipelineBarrier2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkCommandBuffer commandBuffer,
                               const VkDependencyInfo* pDependencyInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdWriteTimestamp2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                              VkQueryPool queryPool, uint32_t query) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkQueueSubmit2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                        VkResult input_result, VkQueue queue, uint32_t submitCount,
                        const VkSubmitInfo2* pSubmits, VkFence fence) {}
    void vkCmdCopyBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyBufferToImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer,
                                 const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyImageToBuffer2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer,
                                 const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBlitImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResolveImage2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer,
                            const VkResolveImageInfo2* pResolveImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBeginRendering(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndRendering(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetCullMode(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                          VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetFrontFace(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetPrimitiveTopology(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                   VkPrimitiveTopology primitiveTopology) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetViewportWithCount(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                   uint32_t viewportCount, const VkViewport* pViewports) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetScissorWithCount(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                  const VkRect2D* pScissors) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBindVertexBuffers2(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                 uint32_t bindingCount, const VkBuffer* pBuffers,
                                 const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                 const VkDeviceSize* pStrides) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthTestEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthWriteEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthCompareOp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthBoundsTestEnable(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer,
                                       VkBool32 depthBoundsTestEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilTestEnable(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                   VkBool32 stencilTestEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilOp(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                           VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
                           VkCompareOp compareOp) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetRasterizerDiscardEnable(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         VkBool32 rasterizerDiscardEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthBiasEnable(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetPrimitiveRestartEnable(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer,
                                        VkBool32 primitiveRestartEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkGetDeviceBufferMemoryRequirements(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkDevice device,
                                             const VkDeviceBufferMemoryRequirements* pInfo,
                                             VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetDeviceImageMemoryRequirements(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            const VkDeviceImageMemoryRequirements* pInfo,
                                            VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetDeviceImageSparseMemoryRequirements(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
        const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
#endif
#ifdef VK_KHR_swapchain
    void vkCreateSwapchainKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkResult input_result, VkDevice device,
                              const VkSwapchainCreateInfoKHR* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain) {
        if (!pSwapchain) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pSwapchain create
        mReconstruction.addHandles((const uint64_t*)pSwapchain, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pSwapchain, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pSwapchain, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pSwapchain, 1);
    }
    void vkDestroySwapchainKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkDevice device, VkSwapchainKHR swapchain,
                               const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // swapchain destroy
        mReconstruction.removeHandles((const uint64_t*)(&swapchain), 1, true);
    }
    void vkGetSwapchainImagesKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
                                 uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages) {}
    void vkAcquireNextImageKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
                               uint64_t timeout, VkSemaphore semaphore, VkFence fence,
                               uint32_t* pImageIndex) {}
    void vkQueuePresentKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkQueue queue,
                           const VkPresentInfoKHR* pPresentInfo) {}
    void vkGetDeviceGroupPresentCapabilitiesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {}
    void vkGetDeviceGroupSurfacePresentModesKHR(android::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* apiCallInfo,
                                                const uint8_t* apiCallPacket,
                                                size_t apiCallPacketSize, VkResult input_result,
                                                VkDevice device, VkSurfaceKHR surface,
                                                VkDeviceGroupPresentModeFlagsKHR* pModes) {}
    void vkGetPhysicalDevicePresentRectanglesKHR(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize, VkResult input_result,
                                                 VkPhysicalDevice physicalDevice,
                                                 VkSurfaceKHR surface, uint32_t* pRectCount,
                                                 VkRect2D* pRects) {}
    void vkAcquireNextImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkAcquireNextImageInfoKHR* pAcquireInfo,
                                uint32_t* pImageIndex) {}
#endif
#ifdef VK_KHR_dynamic_rendering
    void vkCmdBeginRenderingKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer,
                                const VkRenderingInfo* pRenderingInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndRenderingKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    void vkGetPhysicalDeviceFeatures2KHR(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkPhysicalDevice physicalDevice,
                                         VkPhysicalDeviceFeatures2* pFeatures) {}
    void vkGetPhysicalDeviceProperties2KHR(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkPhysicalDevice physicalDevice,
                                           VkPhysicalDeviceProperties2* pProperties) {}
    void vkGetPhysicalDeviceFormatProperties2KHR(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize,
                                                 VkPhysicalDevice physicalDevice, VkFormat format,
                                                 VkFormatProperties2* pFormatProperties) {}
    void vkGetPhysicalDeviceImageFormatProperties2KHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
        VkImageFormatProperties2* pImageFormatProperties) {}
    void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {}
    void vkGetPhysicalDeviceMemoryProperties2KHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {}
    void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
        VkSparseImageFormatProperties2* pProperties) {}
#endif
#ifdef VK_KHR_maintenance1
    void vkTrimCommandPoolKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkDevice device, VkCommandPool commandPool,
                              VkCommandPoolTrimFlags flags) {}
#endif
#ifdef VK_KHR_external_memory_capabilities
    void vkGetPhysicalDeviceExternalBufferPropertiesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
        VkExternalBufferProperties* pExternalBufferProperties) {}
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {}
#endif
#ifdef VK_KHR_external_semaphore_fd
    void vkImportSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {}
    void vkGetSemaphoreFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkResult input_result, VkDevice device,
                             const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {}
#endif
#ifdef VK_KHR_descriptor_update_template
    void vkCreateDescriptorUpdateTemplateKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
        if (!pDescriptorUpdateTemplate) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pDescriptorUpdateTemplate create
        mReconstruction.addHandles((const uint64_t*)pDescriptorUpdateTemplate, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pDescriptorUpdateTemplate, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pDescriptorUpdateTemplate, 1,
                                            apiCallHandle, VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle,
                                                (const uint64_t*)pDescriptorUpdateTemplate, 1);
    }
    void vkDestroyDescriptorUpdateTemplateKHR(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkDevice device,
                                              VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                              const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // descriptorUpdateTemplate destroy
        mReconstruction.removeHandles((const uint64_t*)(&descriptorUpdateTemplate), 1, true);
    }
    void vkUpdateDescriptorSetWithTemplateKHR(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkDevice device,
                                              VkDescriptorSet descriptorSet,
                                              VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                              const void* pData) {}
#endif
#ifdef VK_KHR_create_renderpass2
    void vkCreateRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkRenderPassCreateInfo2* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator,
                                VkRenderPass* pRenderPass) {
        if (!pRenderPass) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pRenderPass create
        mReconstruction.addHandles((const uint64_t*)pRenderPass, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pRenderPass, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pRenderPass, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pRenderPass, 1);
    }
    void vkCmdBeginRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer,
                                  const VkRenderPassBeginInfo* pRenderPassBegin,
                                  const VkSubpassBeginInfo* pSubpassBeginInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdNextSubpass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer,
                              const VkSubpassBeginInfo* pSubpassBeginInfo,
                              const VkSubpassEndInfo* pSubpassEndInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndRenderPass2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer,
                                const VkSubpassEndInfo* pSubpassEndInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    void vkGetPhysicalDeviceExternalFencePropertiesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
        VkExternalFenceProperties* pExternalFenceProperties) {}
#endif
#ifdef VK_KHR_external_fence_fd
    void vkImportFenceFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkResult input_result, VkDevice device,
                            const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {}
    void vkGetFenceFdKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkResult input_result, VkDevice device,
                         const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {}
#endif
#ifdef VK_KHR_get_memory_requirements2
    void vkGetImageMemoryRequirements2KHR(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device,
                                          const VkImageMemoryRequirementsInfo2* pInfo,
                                          VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetBufferMemoryRequirements2KHR(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device,
                                           const VkBufferMemoryRequirementsInfo2* pInfo,
                                           VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetImageSparseMemoryRequirements2KHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
        const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    void vkCreateSamplerYcbcrConversionKHR(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkSamplerYcbcrConversion* pYcbcrConversion) {
        if (!pYcbcrConversion) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pYcbcrConversion create
        mReconstruction.addHandles((const uint64_t*)pYcbcrConversion, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pYcbcrConversion, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pYcbcrConversion, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pYcbcrConversion,
                                                1);
    }
    void vkDestroySamplerYcbcrConversionKHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            VkSamplerYcbcrConversion ycbcrConversion,
                                            const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // ycbcrConversion destroy
        mReconstruction.removeHandles((const uint64_t*)(&ycbcrConversion), 1, true);
    }
#endif
#ifdef VK_KHR_bind_memory2
    void vkBindBufferMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                                const VkBindBufferMemoryInfo* pBindInfos) {}
    void vkBindImageMemory2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device, uint32_t bindInfoCount,
                               const VkBindImageMemoryInfo* pBindInfos) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
            VkDeviceMemory boxed_VkDeviceMemory =
                unboxed_to_boxed_non_dispatchable_VkDeviceMemory(pBindInfos[i].memory);
            mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkImage, 1,
                                                (uint64_t)(uintptr_t)boxed_VkDeviceMemory,
                                                VkReconstruction::BOUND_MEMORY);
            mReconstruction.addHandleDependency((const uint64_t*)&boxed_VkImage, 1,
                                                (uint64_t)(uintptr_t)boxed_VkImage,
                                                VkReconstruction::BOUND_MEMORY);
        }
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        // Note: the implementation does not work with bindInfoCount > 1
        for (uint32_t i = 0; i < bindInfoCount; ++i) {
            VkImage boxed_VkImage = unboxed_to_boxed_non_dispatchable_VkImage(pBindInfos[i].image);
            mReconstruction.forEachHandleAddApi((const uint64_t*)&boxed_VkImage, 1, apiCallHandle,
                                                VkReconstruction::BOUND_MEMORY);
        }
    }
#endif
#ifdef VK_KHR_maintenance3
    void vkGetDescriptorSetLayoutSupportKHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device,
                                            const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                            VkDescriptorSetLayoutSupport* pSupport) {}
#endif
#ifdef VK_KHR_buffer_device_address
    void vkGetBufferDeviceAddressKHR(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkDeviceAddress input_result, VkDevice device,
                                     const VkBufferDeviceAddressInfo* pInfo) {}
    void vkGetBufferOpaqueCaptureAddressKHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            uint64_t input_result, VkDevice device,
                                            const VkBufferDeviceAddressInfo* pInfo) {}
    void vkGetDeviceMemoryOpaqueCaptureAddressKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, uint64_t input_result,
        VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {}
#endif
#ifdef VK_KHR_pipeline_executable_properties
    void vkGetPipelineExecutablePropertiesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
        VkPipelineExecutablePropertiesKHR* pProperties) {}
    void vkGetPipelineExecutableStatisticsKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
        uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics) {}
    void vkGetPipelineExecutableInternalRepresentationsKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
        uint32_t* pInternalRepresentationCount,
        VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {}
#endif
#ifdef VK_KHR_synchronization2
    void vkCmdSetEvent2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer, VkEvent event,
                           const VkDependencyInfo* pDependencyInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResetEvent2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, VkEvent event,
                             VkPipelineStageFlags2 stageMask) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdWaitEvents2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, uint32_t eventCount,
                             const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdPipelineBarrier2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer,
                                  const VkDependencyInfo* pDependencyInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdWriteTimestamp2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                 VkQueryPool queryPool, uint32_t query) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkQueueSubmit2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkResult input_result, VkQueue queue, uint32_t submitCount,
                           const VkSubmitInfo2* pSubmits, VkFence fence) {}
    void vkCmdWriteBufferMarker2AMD(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                    VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkGetQueueCheckpointData2NV(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkQueue queue, uint32_t* pCheckpointDataCount,
                                     VkCheckpointData2NV* pCheckpointData) {}
#endif
#ifdef VK_KHR_copy_commands2
    void vkCmdCopyBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer,
                             const VkCopyBufferInfo2* pCopyBufferInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyBufferToImage2KHR(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer,
                                    const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdCopyImageToBuffer2KHR(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer,
                                    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBlitImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdResolveImage2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkCommandBuffer commandBuffer,
                               const VkResolveImageInfo2* pResolveImageInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_KHR_maintenance4
    void vkGetDeviceBufferMemoryRequirementsKHR(android::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* apiCallInfo,
                                                const uint8_t* apiCallPacket,
                                                size_t apiCallPacketSize, VkDevice device,
                                                const VkDeviceBufferMemoryRequirements* pInfo,
                                                VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetDeviceImageMemoryRequirementsKHR(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize, VkDevice device,
                                               const VkDeviceImageMemoryRequirements* pInfo,
                                               VkMemoryRequirements2* pMemoryRequirements) {}
    void vkGetDeviceImageSparseMemoryRequirementsKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
        const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {}
#endif
#ifdef VK_KHR_maintenance5
    void vkCmdBindIndexBuffer2KHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, VkBuffer buffer,
                                  VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkGetRenderingAreaGranularityKHR(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device,
                                          const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
                                          VkExtent2D* pGranularity) {}
    void vkGetDeviceImageSubresourceLayoutKHR(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkDevice device,
                                              const VkDeviceImageSubresourceInfoKHR* pInfo,
                                              VkSubresourceLayout2KHR* pLayout) {}
    void vkGetImageSubresourceLayout2KHR(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkImage image,
                                         const VkImageSubresource2KHR* pSubresource,
                                         VkSubresourceLayout2KHR* pLayout) {}
#endif
#ifdef VK_KHR_line_rasterization
    void vkCmdSetLineStippleKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                uint16_t lineStipplePattern) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_ANDROID_native_buffer
    void vkGetSwapchainGrallocUsageANDROID(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device, VkFormat format,
                                           VkImageUsageFlags imageUsage, int* grallocUsage) {}
    void vkAcquireImageANDROID(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device, VkImage image,
                               int nativeFenceFd, VkSemaphore semaphore, VkFence fence) {}
    void vkQueueSignalReleaseImageANDROID(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkQueue queue,
                                          uint32_t waitSemaphoreCount,
                                          const VkSemaphore* pWaitSemaphores, VkImage image,
                                          int* pNativeFenceFd) {}
    void vkGetSwapchainGrallocUsage2ANDROID(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device, VkFormat format,
                                            VkImageUsageFlags imageUsage,
                                            VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
                                            uint64_t* grallocConsumerUsage,
                                            uint64_t* grallocProducerUsage) {}
#endif
#ifdef VK_EXT_debug_report
    void vkCreateDebugReportCallbackEXT(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkInstance instance,
                                        const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkDebugReportCallbackEXT* pCallback) {
        if (!pCallback) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pCallback create
        mReconstruction.addHandles((const uint64_t*)pCallback, 1);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pCallback, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pCallback, 1);
    }
    void vkDestroyDebugReportCallbackEXT(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkInstance instance, VkDebugReportCallbackEXT callback,
                                         const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // callback destroy
        mReconstruction.removeHandles((const uint64_t*)(&callback), 1, true);
    }
    void vkDebugReportMessageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkInstance instance, VkDebugReportFlagsEXT flags,
                                 VkDebugReportObjectTypeEXT objectType, uint64_t object,
                                 size_t location, int32_t messageCode, const char* pLayerPrefix,
                                 const char* pMessage) {}
#endif
#ifdef VK_EXT_transform_feedback
    void vkCmdBindTransformFeedbackBuffersEXT(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
        uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers,
        const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBeginTransformFeedbackEXT(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                        uint32_t counterBufferCount,
                                        const VkBuffer* pCounterBuffers,
                                        const VkDeviceSize* pCounterBufferOffsets) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndTransformFeedbackEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                      uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                      const VkDeviceSize* pCounterBufferOffsets) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBeginQueryIndexedEXT(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                   VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags,
                                   uint32_t index) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndQueryIndexedEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                 const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                 VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                 uint32_t query, uint32_t index) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdDrawIndirectByteCountEXT(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, uint32_t instanceCount,
                                       uint32_t firstInstance, VkBuffer counterBuffer,
                                       VkDeviceSize counterBufferOffset, uint32_t counterOffset,
                                       uint32_t vertexStride) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_EXT_debug_utils
    void vkSetDebugUtilsObjectNameEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkResult input_result, VkDevice device,
                                      const VkDebugUtilsObjectNameInfoEXT* pNameInfo) {}
    void vkSetDebugUtilsObjectTagEXT(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkResult input_result, VkDevice device,
                                     const VkDebugUtilsObjectTagInfoEXT* pTagInfo) {}
    void vkQueueBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo) {}
    void vkQueueEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkQueue queue) {}
    void vkQueueInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo) {}
    void vkCmdBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer,
                                      const VkDebugUtilsLabelEXT* pLabelInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer,
                                       const VkDebugUtilsLabelEXT* pLabelInfo) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCreateDebugUtilsMessengerEXT(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkInstance instance,
                                        const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkDebugUtilsMessengerEXT* pMessenger) {
        if (!pMessenger) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pMessenger create
        mReconstruction.addHandles((const uint64_t*)pMessenger, 1);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pMessenger, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pMessenger, 1);
    }
    void vkDestroyDebugUtilsMessengerEXT(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkInstance instance, VkDebugUtilsMessengerEXT messenger,
                                         const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // messenger destroy
        mReconstruction.removeHandles((const uint64_t*)(&messenger), 1, true);
    }
    void vkSubmitDebugUtilsMessageEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkInstance instance,
                                      VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                      VkDebugUtilsMessageTypeFlagsEXT messageTypes,
                                      const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {}
#endif
#ifdef VK_EXT_image_drm_format_modifier
    void vkGetImageDrmFormatModifierPropertiesEXT(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties) {}
#endif
#ifdef VK_EXT_external_memory_host
    void vkGetMemoryHostPointerPropertiesEXT(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer,
        VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {}
#endif
#ifdef VK_EXT_tooling_info
    void vkGetPhysicalDeviceToolPropertiesEXT(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkResult input_result,
                                              VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                              VkPhysicalDeviceToolProperties* pToolProperties) {}
#endif
#ifdef VK_EXT_line_rasterization
    void vkCmdSetLineStippleEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                uint16_t lineStipplePattern) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_EXT_extended_dynamic_state
    void vkCmdSetCullModeEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetFrontFaceEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetPrimitiveTopologyEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer,
                                      VkPrimitiveTopology primitiveTopology) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetViewportWithCountEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                      const VkViewport* pViewports) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetScissorWithCountEXT(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                     const VkRect2D* pScissors) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdBindVertexBuffers2EXT(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                    uint32_t bindingCount, const VkBuffer* pBuffers,
                                    const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                    const VkDeviceSize* pStrides) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthTestEnableEXT(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthWriteEnableEXT(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthCompareOpEXT(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
                                   VkCompareOp depthCompareOp) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthBoundsTestEnableEXT(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkBool32 depthBoundsTestEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilTestEnableEXT(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetStencilOpEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                              VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
                              VkCompareOp compareOp) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_EXT_host_image_copy
    void vkCopyMemoryToImageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo) {}
    void vkCopyImageToMemoryEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device,
                                const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo) {}
    void vkCopyImageToImageEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkResult input_result, VkDevice device,
                               const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo) {}
    void vkTransitionImageLayoutEXT(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkResult input_result, VkDevice device,
                                    uint32_t transitionCount,
                                    const VkHostImageLayoutTransitionInfoEXT* pTransitions) {}
    void vkGetImageSubresourceLayout2EXT(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkImage image,
                                         const VkImageSubresource2KHR* pSubresource,
                                         VkSubresourceLayout2KHR* pLayout) {}
#endif
#ifdef VK_EXT_swapchain_maintenance1
    void vkReleaseSwapchainImagesEXT(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkResult input_result, VkDevice device,
                                     const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo) {}
#endif
#ifdef VK_EXT_private_data
    void vkCreatePrivateDataSlotEXT(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkResult input_result, VkDevice device,
                                    const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkPrivateDataSlot* pPrivateDataSlot) {}
    void vkDestroyPrivateDataSlotEXT(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkDevice device, VkPrivateDataSlot privateDataSlot,
                                     const VkAllocationCallbacks* pAllocator) {}
    void vkSetPrivateDataEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkResult input_result, VkDevice device, VkObjectType objectType,
                             uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
                             uint64_t data) {}
    void vkGetPrivateDataEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                             VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                             VkPrivateDataSlot privateDataSlot, uint64_t* pData) {}
#endif
#ifdef VK_EXT_extended_dynamic_state2
    void vkCmdSetPatchControlPointsEXT(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetRasterizerDiscardEnableEXT(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            VkBool32 rasterizerDiscardEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetDepthBiasEnableEXT(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetLogicOpEXT(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                            VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCmdSetPrimitiveRestartEnableEXT(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           VkBool32 primitiveRestartEnable) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_EXT_color_write_enable
    void vkCmdSetColorWriteEnableEXT(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                     const VkBool32* pColorWriteEnables) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    void vkMapMemoryIntoAddressSpaceGOOGLE(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           VkDeviceMemory memory, uint64_t* pAddress) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // memory modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            VkDeviceMemory boxed = unboxed_to_boxed_non_dispatchable_VkDeviceMemory((&memory)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews) {}
    void vkBeginCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         const VkCommandBufferBeginInfo* pBeginInfo) {}
    void vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer) {}
    void vkResetCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         VkCommandBufferResetFlags flags) {}
    void vkCommandBufferHostSyncGOOGLE(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, uint32_t needHostSync,
                                       uint32_t sequenceNumber) {}
    void vkCreateImageWithRequirementsGOOGLE(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkDevice device,
                                             const VkImageCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkImage* pImage,
                                             VkMemoryRequirements* pMemoryRequirements) {
        if (!pImage) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pImage create
        mReconstruction.addHandles((const uint64_t*)pImage, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pImage, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pImage, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pImage, 1);
    }
    void vkCreateBufferWithRequirementsGOOGLE(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, const VkBufferCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
        VkMemoryRequirements* pMemoryRequirements) {
        if (!pBuffer) return;
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // pBuffer create
        mReconstruction.addHandles((const uint64_t*)pBuffer, 1);
        mReconstruction.addHandleDependency((const uint64_t*)pBuffer, 1,
                                            (uint64_t)(uintptr_t)device);
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        mReconstruction.forEachHandleAddApi((const uint64_t*)pBuffer, 1, apiCallHandle,
                                            VkReconstruction::CREATED);
        mReconstruction.setCreatedHandlesForApi(apiCallHandle, (const uint64_t*)pBuffer, 1);
    }
    void vkGetMemoryHostAddressInfoGOOGLE(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          VkDeviceMemory memory, uint64_t* pAddress,
                                          uint64_t* pSize, uint64_t* pHostmemId) {}
    void vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                VkResult input_result, VkDevice device, VkDeviceMemory memory,
                                const VkAllocationCallbacks* pAllocator) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // memory destroy
        mReconstruction.removeHandles((const uint64_t*)(&memory), 1, true);
    }
    void vkQueueHostSyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                               const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                               VkQueue queue, uint32_t needHostSync, uint32_t sequenceNumber) {}
    void vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                  VkFence fence) {}
    void vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkQueue queue) {}
    void vkQueueBindSparseAsyncGOOGLE(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkQueue queue, uint32_t bindInfoCount,
                                      const VkBindSparseInfo* pBindInfo, VkFence fence) {}
    void vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkDevice device, VkFormat format, VkDeviceSize* pOffset,
                                      VkDeviceSize* pRowPitchAlignment) {}
    void vkGetLinearImageLayout2GOOGLE(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkDevice device, const VkImageCreateInfo* pCreateInfo,
                                       VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment) {}
    void vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkQueue queue, VkCommandBuffer commandBuffer,
                                    VkDeviceSize dataSize, const void* pData) {}
    void vkQueueCommitDescriptorSetUpdatesGOOGLE(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkQueue queue,
        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
        uint32_t descriptorSetCount, const VkDescriptorSetLayout* pSetLayouts,
        const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
        const uint32_t* pDescriptorSetPendingAllocation,
        const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
        const VkWriteDescriptorSet* pPendingDescriptorWrites) {}
    void vkCollectDescriptorPoolIdsGOOGLE(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkDescriptorPool descriptorPool,
                                          uint32_t* pPoolIdCount, uint64_t* pPoolIds) {}
    void vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkQueue queue,
        uint32_t waitSemaphoreCount, const VkSemaphore* pWaitSemaphores, VkImage image) {}
    void vkQueueFlushCommandsFromAuxMemoryGOOGLE(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize, VkQueue queue,
                                                 VkCommandBuffer commandBuffer,
                                                 VkDeviceMemory deviceMemory,
                                                 VkDeviceSize dataOffset, VkDeviceSize dataSize) {}
    void vkGetBlobGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                         VkResult input_result, VkDevice device, VkDeviceMemory memory) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // memory modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            VkDeviceMemory boxed = unboxed_to_boxed_non_dispatchable_VkDeviceMemory((&memory)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDevice device,
        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
        uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
        const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData) {}
    void vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkQueue queue, uint32_t submitCount,
                                   const VkSubmitInfo2* pSubmits, VkFence fence) {}
    void vkGetSemaphoreGOOGLE(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                              const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                              VkResult input_result, VkDevice device, VkSemaphore semaphore,
                              uint64_t syncId) {}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    void vkCmdTraceRaysKHR(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                           VkCommandBuffer commandBuffer,
                           const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                           const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                           const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                           const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
                           uint32_t width, uint32_t height, uint32_t depth) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkCreateRayTracingPipelinesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache,
        uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
        const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {}
    void vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkResult input_result,
        VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount,
        size_t dataSize, void* pData) {}
    void vkCmdTraceRaysIndirectKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
        const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
        const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
        const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
        const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
        VkDeviceAddress indirectDeviceAddress) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
    void vkGetRayTracingShaderGroupStackSizeKHR(
        android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
        const uint8_t* apiCallPacket, size_t apiCallPacketSize, VkDeviceSize input_result,
        VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) {}
    void vkCmdSetRayTracingPipelineStackSizeKHR(android::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* apiCallInfo,
                                                const uint8_t* apiCallPacket,
                                                size_t apiCallPacketSize,
                                                VkCommandBuffer commandBuffer,
                                                uint32_t pipelineStackSize) {
        std::lock_guard<std::mutex> lock(mReconstructionMutex);
        // commandBuffer modify
        auto apiCallHandle = apiCallInfo->handle;
        mReconstruction.setApiTrace(apiCallInfo, apiCallPacket, apiCallPacketSize);
        for (uint32_t i = 0; i < 1; ++i) {
            // commandBuffer is already boxed, no need to box again
            VkCommandBuffer boxed = VkCommandBuffer((&commandBuffer)[i]);
            mReconstruction.forEachHandleAddModifyApi((const uint64_t*)(&boxed), 1, apiCallHandle);
        }
    }
#endif
   private:
    std::mutex mReconstructionMutex;
    VkReconstruction mReconstruction GUARDED_BY(mReconstructionMutex);
};

VkDecoderSnapshot::VkDecoderSnapshot() : mImpl(new VkDecoderSnapshot::Impl()) {}

void VkDecoderSnapshot::clear() { mImpl->clear(); }

void VkDecoderSnapshot::saveReplayBuffers(android::base::Stream* stream) {
    mImpl->saveReplayBuffers(stream);
}

/*static*/
void VkDecoderSnapshot::loadReplayBuffers(android::base::Stream* stream,
                                          std::vector<uint64_t>* outHandleBuffer,
                                          std::vector<uint8_t>* outDecoderBuffer) {
    VkDecoderSnapshot::Impl::loadReplayBuffers(stream, outHandleBuffer, outDecoderBuffer);
}

VkSnapshotApiCallInfo* VkDecoderSnapshot::createApiCallInfo() { return mImpl->createApiCallInfo(); }

void VkDecoderSnapshot::destroyApiCallInfoIfUnused(VkSnapshotApiCallInfo* info) {
    mImpl->destroyApiCallInfoIfUnused(info);
}

VkDecoderSnapshot::~VkDecoderSnapshot() = default;
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateInstance(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator, VkInstance* pInstance) {
    mImpl->vkCreateInstance(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            pCreateInfo, pAllocator, pInstance);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyInstance(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkInstance instance,
                                          const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyInstance(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, instance,
                             pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkEnumeratePhysicalDevices(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
    uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices) {
    mImpl->vkEnumeratePhysicalDevices(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      input_result, instance, pPhysicalDeviceCount,
                                      pPhysicalDevices);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures(android::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* apiCallInfo,
                                                    const uint8_t* apiCallPacket,
                                                    size_t apiCallPacketSize,
                                                    VkPhysicalDevice physicalDevice,
                                                    VkPhysicalDeviceFeatures* pFeatures) {
    mImpl->vkGetPhysicalDeviceFeatures(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       physicalDevice, pFeatures);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceFormatProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format,
    VkFormatProperties* pFormatProperties) {
    mImpl->vkGetPhysicalDeviceFormatProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               physicalDevice, format, pFormatProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceImageFormatProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage,
    VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties) {
    mImpl->vkGetPhysicalDeviceImageFormatProperties(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, physicalDevice, format,
        type, tiling, usage, flags, pImageFormatProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceProperties(android::base::BumpPool* pool,
                                                      VkSnapshotApiCallInfo* apiCallInfo,
                                                      const uint8_t* apiCallPacket,
                                                      size_t apiCallPacketSize,
                                                      VkPhysicalDevice physicalDevice,
                                                      VkPhysicalDeviceProperties* pProperties) {
    mImpl->vkGetPhysicalDeviceProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         physicalDevice, pProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceQueueFamilyProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
    mImpl->vkGetPhysicalDeviceQueueFamilyProperties(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice,
        pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceMemoryProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
    mImpl->vkGetPhysicalDeviceMemoryProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               physicalDevice, pMemoryProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetInstanceProcAddr(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize,
                                              PFN_vkVoidFunction input_result, VkInstance instance,
                                              const char* pName) {
    mImpl->vkGetInstanceProcAddr(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 instance, pName);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetDeviceProcAddr(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            PFN_vkVoidFunction input_result, VkDevice device,
                                            const char* pName) {
    mImpl->vkGetDeviceProcAddr(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, pName);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateDevice(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkResult input_result, VkPhysicalDevice physicalDevice,
                                       const VkDeviceCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator, VkDevice* pDevice) {
    mImpl->vkCreateDevice(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                          physicalDevice, pCreateInfo, pAllocator, pDevice);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyDevice(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkDevice device, const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDevice(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkEnumerateInstanceExtensionProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, const char* pLayerName,
    uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
    mImpl->vkEnumerateInstanceExtensionProperties(pool, apiCallInfo, apiCallPacket,
                                                  apiCallPacketSize, input_result, pLayerName,
                                                  pPropertyCount, pProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkEnumerateDeviceExtensionProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties) {
    mImpl->vkEnumerateDeviceExtensionProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, physicalDevice, pLayerName,
                                                pPropertyCount, pProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkEnumerateInstanceLayerProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, uint32_t* pPropertyCount,
    VkLayerProperties* pProperties) {
    mImpl->vkEnumerateInstanceLayerProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              input_result, pPropertyCount, pProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkEnumerateDeviceLayerProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount, VkLayerProperties* pProperties) {
    mImpl->vkEnumerateDeviceLayerProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            input_result, physicalDevice, pPropertyCount,
                                            pProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetDeviceQueue(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, uint32_t queueFamilyIndex,
                                         uint32_t queueIndex, VkQueue* pQueue) {
    mImpl->vkGetDeviceQueue(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                            queueFamilyIndex, queueIndex, pQueue);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkQueueSubmit(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkResult input_result, VkQueue queue, uint32_t submitCount,
                                      const VkSubmitInfo* pSubmits, VkFence fence) {
    mImpl->vkQueueSubmit(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, queue,
                         submitCount, pSubmits, fence);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkQueueWaitIdle(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkQueue queue) {
    mImpl->vkQueueWaitIdle(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                           queue);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDeviceWaitIdle(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device) {
    mImpl->vkDeviceWaitIdle(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            device);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkAllocateMemory(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         const VkMemoryAllocateInfo* pAllocateInfo,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkDeviceMemory* pMemory) {
    mImpl->vkAllocateMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            device, pAllocateInfo, pAllocator, pMemory);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkFreeMemory(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkDevice device, VkDeviceMemory memory,
                                     const VkAllocationCallbacks* pAllocator) {
    mImpl->vkFreeMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, memory,
                        pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkMapMemory(android::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* apiCallInfo,
                                    const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                    VkResult input_result, VkDevice device, VkDeviceMemory memory,
                                    VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags,
                                    void** ppData) {
    mImpl->vkMapMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                       memory, offset, size, flags, ppData);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkUnmapMemory(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkDevice device, VkDeviceMemory memory) {
    mImpl->vkUnmapMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, memory);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkFlushMappedMemoryRanges(android::base::BumpPool* pool,
                                                  VkSnapshotApiCallInfo* apiCallInfo,
                                                  const uint8_t* apiCallPacket,
                                                  size_t apiCallPacketSize, VkResult input_result,
                                                  VkDevice device, uint32_t memoryRangeCount,
                                                  const VkMappedMemoryRange* pMemoryRanges) {
    mImpl->vkFlushMappedMemoryRanges(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     input_result, device, memoryRangeCount, pMemoryRanges);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkInvalidateMappedMemoryRanges(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges) {
    mImpl->vkInvalidateMappedMemoryRanges(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          input_result, device, memoryRangeCount, pMemoryRanges);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetDeviceMemoryCommitment(android::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* apiCallInfo,
                                                    const uint8_t* apiCallPacket,
                                                    size_t apiCallPacketSize, VkDevice device,
                                                    VkDeviceMemory memory,
                                                    VkDeviceSize* pCommittedMemoryInBytes) {
    mImpl->vkGetDeviceMemoryCommitment(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                       memory, pCommittedMemoryInBytes);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkBindBufferMemory(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device, VkBuffer buffer,
                                           VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    mImpl->vkBindBufferMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              device, buffer, memory, memoryOffset);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkBindImageMemory(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device, VkImage image,
                                          VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    mImpl->vkBindImageMemory(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             device, image, memory, memoryOffset);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetBufferMemoryRequirements(android::base::BumpPool* pool,
                                                      VkSnapshotApiCallInfo* apiCallInfo,
                                                      const uint8_t* apiCallPacket,
                                                      size_t apiCallPacketSize, VkDevice device,
                                                      VkBuffer buffer,
                                                      VkMemoryRequirements* pMemoryRequirements) {
    mImpl->vkGetBufferMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         device, buffer, pMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetImageMemoryRequirements(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize, VkDevice device,
                                                     VkImage image,
                                                     VkMemoryRequirements* pMemoryRequirements) {
    mImpl->vkGetImageMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                        image, pMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetImageSparseMemoryRequirements(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
    mImpl->vkGetImageSparseMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              device, image, pSparseMemoryRequirementCount,
                                              pSparseMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPhysicalDeviceSparseImageFormatProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
    VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
    uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {
    mImpl->vkGetPhysicalDeviceSparseImageFormatProperties(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, format, type, samples,
        usage, tiling, pPropertyCount, pProperties);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkQueueBindSparse(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkQueue queue,
                                          uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                          VkFence fence) {
    mImpl->vkQueueBindSparse(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             queue, bindInfoCount, pBindInfo, fence);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateFence(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkResult input_result, VkDevice device,
                                      const VkFenceCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator, VkFence* pFence) {
    mImpl->vkCreateFence(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                         pCreateInfo, pAllocator, pFence);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyFence(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkDevice device, VkFence fence,
                                       const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyFence(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, fence,
                          pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkResetFences(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkResult input_result, VkDevice device, uint32_t fenceCount,
                                      const VkFence* pFences) {
    mImpl->vkResetFences(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                         fenceCount, pFences);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetFenceStatus(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device, VkFence fence) {
    mImpl->vkGetFenceStatus(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            device, fence);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkWaitForFences(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkDevice device, uint32_t fenceCount,
                                        const VkFence* pFences, VkBool32 waitAll,
                                        uint64_t timeout) {
    mImpl->vkWaitForFences(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                           device, fenceCount, pFences, waitAll, timeout);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateSemaphore(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkSemaphoreCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkSemaphore* pSemaphore) {
    mImpl->vkCreateSemaphore(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             device, pCreateInfo, pAllocator, pSemaphore);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroySemaphore(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkSemaphore semaphore,
                                           const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroySemaphore(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                              semaphore, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateEvent(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkResult input_result, VkDevice device,
                                      const VkEventCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
    mImpl->vkCreateEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                         pCreateInfo, pAllocator, pEvent);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyEvent(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkDevice device, VkEvent event,
                                       const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, event,
                          pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetEventStatus(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device, VkEvent event) {
    mImpl->vkGetEventStatus(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            device, event);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkSetEvent(android::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
                                   size_t apiCallPacketSize, VkResult input_result, VkDevice device,
                                   VkEvent event) {
    mImpl->vkSetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                      event);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkResetEvent(android::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* apiCallInfo,
                                     const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                     VkResult input_result, VkDevice device, VkEvent event) {
    mImpl->vkResetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                        event);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateQueryPool(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkQueryPoolCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkQueryPool* pQueryPool) {
    mImpl->vkCreateQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             device, pCreateInfo, pAllocator, pQueryPool);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyQueryPool(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkQueryPool queryPool,
                                           const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                              queryPool, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetQueryPoolResults(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkQueryPool queryPool,
    uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride,
    VkQueryResultFlags flags) {
    mImpl->vkGetQueryPoolResults(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, queryPool, firstQuery, queryCount, dataSize, pData, stride,
                                 flags);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateBuffer(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkResult input_result, VkDevice device,
                                       const VkBufferCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
    mImpl->vkCreateBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                          pCreateInfo, pAllocator, pBuffer);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyBuffer(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkDevice device, VkBuffer buffer,
                                        const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, buffer,
                           pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateBufferView(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkBufferViewCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkBufferView* pView) {
    mImpl->vkCreateBufferView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              device, pCreateInfo, pAllocator, pView);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyBufferView(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkBufferView bufferView,
                                            const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyBufferView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                               bufferView, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateImage(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkResult input_result, VkDevice device,
                                      const VkImageCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator, VkImage* pImage) {
    mImpl->vkCreateImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device,
                         pCreateInfo, pAllocator, pImage);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyImage(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkDevice device, VkImage image,
                                       const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, image,
                          pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetImageSubresourceLayout(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkImage image,
    const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout) {
    mImpl->vkGetImageSubresourceLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                       image, pSubresource, pLayout);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateImageView(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkImageViewCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkImageView* pView) {
    mImpl->vkCreateImageView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             device, pCreateInfo, pAllocator, pView);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyImageView(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkDevice device, VkImageView imageView,
                                           const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyImageView(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                              imageView, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateShaderModule(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkDevice device,
                                             const VkShaderModuleCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkShaderModule* pShaderModule) {
    mImpl->vkCreateShaderModule(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                device, pCreateInfo, pAllocator, pShaderModule);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyShaderModule(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkDevice device,
                                              VkShaderModule shaderModule,
                                              const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyShaderModule(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                 shaderModule, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreatePipelineCache(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache) {
    mImpl->vkCreatePipelineCache(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, pCreateInfo, pAllocator, pPipelineCache);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyPipelineCache(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize, VkDevice device,
                                               VkPipelineCache pipelineCache,
                                               const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyPipelineCache(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                  pipelineCache, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetPipelineCacheData(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize, VkResult input_result,
                                               VkDevice device, VkPipelineCache pipelineCache,
                                               size_t* pDataSize, void* pData) {
    mImpl->vkGetPipelineCacheData(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pipelineCache, pDataSize, pData);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkMergePipelineCaches(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipelineCache dstCache,
    uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches) {
    mImpl->vkMergePipelineCaches(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, dstCache, srcCacheCount, pSrcCaches);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateGraphicsPipelines(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipelineCache pipelineCache,
    uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    mImpl->vkCreateGraphicsPipelines(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     input_result, device, pipelineCache, createInfoCount,
                                     pCreateInfos, pAllocator, pPipelines);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateComputePipelines(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipelineCache pipelineCache,
    uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    mImpl->vkCreateComputePipelines(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    input_result, device, pipelineCache, createInfoCount,
                                    pCreateInfos, pAllocator, pPipelines);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyPipeline(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkPipeline pipeline,
                                          const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyPipeline(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pipeline,
                             pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreatePipelineLayout(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout) {
    mImpl->vkCreatePipelineLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pCreateInfo, pAllocator, pPipelineLayout);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyPipelineLayout(android::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* apiCallInfo,
                                                const uint8_t* apiCallPacket,
                                                size_t apiCallPacketSize, VkDevice device,
                                                VkPipelineLayout pipelineLayout,
                                                const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyPipelineLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                   pipelineLayout, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateSampler(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkDevice device,
                                        const VkSamplerCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator,
                                        VkSampler* pSampler) {
    mImpl->vkCreateSampler(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                           device, pCreateInfo, pAllocator, pSampler);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroySampler(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkSampler sampler,
                                         const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroySampler(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, sampler,
                            pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateDescriptorSetLayout(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout) {
    mImpl->vkCreateDescriptorSetLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       input_result, device, pCreateInfo, pAllocator, pSetLayout);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyDescriptorSetLayout(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize, VkDevice device,
                                                     VkDescriptorSetLayout descriptorSetLayout,
                                                     const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDescriptorSetLayout(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                        descriptorSetLayout, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateDescriptorPool(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool) {
    mImpl->vkCreateDescriptorPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pCreateInfo, pAllocator, pDescriptorPool);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyDescriptorPool(android::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* apiCallInfo,
                                                const uint8_t* apiCallPacket,
                                                size_t apiCallPacketSize, VkDevice device,
                                                VkDescriptorPool descriptorPool,
                                                const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDescriptorPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                   descriptorPool, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkResetDescriptorPool(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkResult input_result,
                                              VkDevice device, VkDescriptorPool descriptorPool,
                                              VkDescriptorPoolResetFlags flags) {
    mImpl->vkResetDescriptorPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, descriptorPool, flags);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkAllocateDescriptorSets(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets) {
    mImpl->vkAllocateDescriptorSets(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    input_result, device, pAllocateInfo, pDescriptorSets);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkFreeDescriptorSets(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkDevice device,
                                             VkDescriptorPool descriptorPool,
                                             uint32_t descriptorSetCount,
                                             const VkDescriptorSet* pDescriptorSets) {
    mImpl->vkFreeDescriptorSets(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkUpdateDescriptorSets(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies) {
    mImpl->vkUpdateDescriptorSets(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                  descriptorWriteCount, pDescriptorWrites, descriptorCopyCount,
                                  pDescriptorCopies);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateFramebuffer(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkFramebufferCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkFramebuffer* pFramebuffer) {
    mImpl->vkCreateFramebuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, pCreateInfo, pAllocator, pFramebuffer);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyFramebuffer(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkDevice device, VkFramebuffer framebuffer,
                                             const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyFramebuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                framebuffer, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateRenderPass(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkRenderPassCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator,
                                           VkRenderPass* pRenderPass) {
    mImpl->vkCreateRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              device, pCreateInfo, pAllocator, pRenderPass);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyRenderPass(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkRenderPass renderPass,
                                            const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                               renderPass, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkGetRenderAreaGranularity(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity) {
    mImpl->vkGetRenderAreaGranularity(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                      renderPass, pGranularity);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCreateCommandPool(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkCommandPoolCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkCommandPool* pCommandPool) {
    mImpl->vkCreateCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, pCreateInfo, pAllocator, pCommandPool);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkDestroyCommandPool(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkDevice device, VkCommandPool commandPool,
                                             const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                commandPool, pAllocator);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkResetCommandPool(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           VkCommandPool commandPool,
                                           VkCommandPoolResetFlags flags) {
    mImpl->vkResetCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              device, commandPool, flags);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkAllocateCommandBuffers(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers) {
    mImpl->vkAllocateCommandBuffers(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    input_result, device, pAllocateInfo, pCommandBuffers);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkFreeCommandBuffers(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkDevice device, VkCommandPool commandPool,
                                             uint32_t commandBufferCount,
                                             const VkCommandBuffer* pCommandBuffers) {
    mImpl->vkFreeCommandBuffers(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                commandPool, commandBufferCount, pCommandBuffers);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkBeginCommandBuffer(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkCommandBuffer commandBuffer,
                                             const VkCommandBufferBeginInfo* pBeginInfo) {
    mImpl->vkBeginCommandBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                commandBuffer, pBeginInfo);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkEndCommandBuffer(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkCommandBuffer commandBuffer) {
    mImpl->vkEndCommandBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              commandBuffer);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkResetCommandBuffer(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkCommandBuffer commandBuffer,
                                             VkCommandBufferResetFlags flags) {
    mImpl->vkResetCommandBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                commandBuffer, flags);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBindPipeline(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          VkPipelineBindPoint pipelineBindPoint,
                                          VkPipeline pipeline) {
    mImpl->vkCmdBindPipeline(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             pipelineBindPoint, pipeline);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetViewport(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                         uint32_t viewportCount, const VkViewport* pViewports) {
    mImpl->vkCmdSetViewport(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            firstViewport, viewportCount, pViewports);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetScissor(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer, uint32_t firstScissor,
                                        uint32_t scissorCount, const VkRect2D* pScissors) {
    mImpl->vkCmdSetScissor(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           firstScissor, scissorCount, pScissors);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetLineWidth(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, float lineWidth) {
    mImpl->vkCmdSetLineWidth(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             lineWidth);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetDepthBias(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          float depthBiasConstantFactor, float depthBiasClamp,
                                          float depthBiasSlopeFactor) {
    mImpl->vkCmdSetDepthBias(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetBlendConstants(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, const float blendConstants[4]) {
    mImpl->vkCmdSetBlendConstants(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, blendConstants);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetDepthBounds(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, float minDepthBounds,
                                            float maxDepthBounds) {
    mImpl->vkCmdSetDepthBounds(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               minDepthBounds, maxDepthBounds);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetStencilCompareMask(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
    uint32_t compareMask) {
    mImpl->vkCmdSetStencilCompareMask(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, faceMask, compareMask);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetStencilWriteMask(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize,
                                                 VkCommandBuffer commandBuffer,
                                                 VkStencilFaceFlags faceMask, uint32_t writeMask) {
    mImpl->vkCmdSetStencilWriteMask(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, faceMask, writeMask);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetStencilReference(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize,
                                                 VkCommandBuffer commandBuffer,
                                                 VkStencilFaceFlags faceMask, uint32_t reference) {
    mImpl->vkCmdSetStencilReference(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, faceMask, reference);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBindDescriptorSets(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets) {
    mImpl->vkCmdBindDescriptorSets(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, pipelineBindPoint,
        layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBindIndexBuffer(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, VkBuffer buffer,
                                             VkDeviceSize offset, VkIndexType indexType) {
    mImpl->vkCmdBindIndexBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                buffer, offset, indexType);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBindVertexBuffers(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets) {
    mImpl->vkCmdBindVertexBuffers(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdDraw(android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo,
                                  const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                  VkCommandBuffer commandBuffer, uint32_t vertexCount,
                                  uint32_t instanceCount, uint32_t firstVertex,
                                  uint32_t firstInstance) {
    mImpl->vkCmdDraw(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                     vertexCount, instanceCount, firstVertex, firstInstance);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdDrawIndexed(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, uint32_t indexCount,
                                         uint32_t instanceCount, uint32_t firstIndex,
                                         int32_t vertexOffset, uint32_t firstInstance) {
    mImpl->vkCmdDrawIndexed(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdDrawIndirect(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkBuffer buffer,
                                          VkDeviceSize offset, uint32_t drawCount,
                                          uint32_t stride) {
    mImpl->vkCmdDrawIndirect(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             buffer, offset, drawCount, stride);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdDrawIndexedIndirect(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
    uint32_t drawCount, uint32_t stride) {
    mImpl->vkCmdDrawIndexedIndirect(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, buffer, offset, drawCount, stride);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdDispatch(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer, uint32_t groupCountX,
                                      uint32_t groupCountY, uint32_t groupCountZ) {
    mImpl->vkCmdDispatch(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                         groupCountX, groupCountY, groupCountZ);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdDispatchIndirect(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    mImpl->vkCmdDispatchIndirect(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 buffer, offset);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdCopyBuffer(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                        VkBuffer dstBuffer, uint32_t regionCount,
                                        const VkBufferCopy* pRegions) {
    mImpl->vkCmdCopyBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           srcBuffer, dstBuffer, regionCount, pRegions);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdCopyImage(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, VkImage srcImage,
                                       VkImageLayout srcImageLayout, VkImage dstImage,
                                       VkImageLayout dstImageLayout, uint32_t regionCount,
                                       const VkImageCopy* pRegions) {
    mImpl->vkCmdCopyImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                          srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount,
                          pRegions);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBlitImage(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, VkImage srcImage,
                                       VkImageLayout srcImageLayout, VkImage dstImage,
                                       VkImageLayout dstImageLayout, uint32_t regionCount,
                                       const VkImageBlit* pRegions, VkFilter filter) {
    mImpl->vkCmdBlitImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                          srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions,
                          filter);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdCopyBufferToImage(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
    VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
    mImpl->vkCmdCopyBufferToImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount,
                                  pRegions);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdCopyImageToBuffer(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkImage srcImage,
    VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount,
    const VkBufferImageCopy* pRegions) {
    mImpl->vkCmdCopyImageToBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount,
                                  pRegions);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdUpdateBuffer(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                          VkDeviceSize dstOffset, VkDeviceSize dataSize,
                                          const void* pData) {
    mImpl->vkCmdUpdateBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             dstBuffer, dstOffset, dataSize, pData);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdFillBuffer(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                        VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    mImpl->vkCmdFillBuffer(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           dstBuffer, dstOffset, size, data);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdClearColorImage(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, VkImage image,
                                             VkImageLayout imageLayout,
                                             const VkClearColorValue* pColor, uint32_t rangeCount,
                                             const VkImageSubresourceRange* pRanges) {
    mImpl->vkCmdClearColorImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                image, imageLayout, pColor, rangeCount, pRanges);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdClearDepthStencilImage(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkImage image,
    VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges) {
    mImpl->vkCmdClearDepthStencilImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       commandBuffer, image, imageLayout, pDepthStencil, rangeCount,
                                       pRanges);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdClearAttachments(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t attachmentCount,
    const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects) {
    mImpl->vkCmdClearAttachments(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 attachmentCount, pAttachments, rectCount, pRects);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdResolveImage(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkImage srcImage,
                                          VkImageLayout srcImageLayout, VkImage dstImage,
                                          VkImageLayout dstImageLayout, uint32_t regionCount,
                                          const VkImageResolve* pRegions) {
    mImpl->vkCmdResolveImage(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount,
                             pRegions);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdSetEvent(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer, VkEvent event,
                                      VkPipelineStageFlags stageMask) {
    mImpl->vkCmdSetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, event,
                         stageMask);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdResetEvent(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer, VkEvent event,
                                        VkPipelineStageFlags stageMask) {
    mImpl->vkCmdResetEvent(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           event, stageMask);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdWaitEvents(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t eventCount,
    const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    mImpl->vkCmdWaitEvents(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount,
                           pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers,
                           imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdPipelineBarrier(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    mImpl->vkCmdPipelineBarrier(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount,
                                pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers,
                                imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBeginQuery(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                        uint32_t query, VkQueryControlFlags flags) {
    mImpl->vkCmdBeginQuery(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           queryPool, query, flags);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdEndQuery(android::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* apiCallInfo,
                                      const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                      VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                      uint32_t query) {
    mImpl->vkCmdEndQuery(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                         queryPool, query);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdResetQueryPool(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                            uint32_t firstQuery, uint32_t queryCount) {
    mImpl->vkCmdResetQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               queryPool, firstQuery, queryCount);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdWriteTimestamp(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            VkPipelineStageFlagBits pipelineStage,
                                            VkQueryPool queryPool, uint32_t query) {
    mImpl->vkCmdWriteTimestamp(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pipelineStage, queryPool, query);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdCopyQueryPoolResults(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkQueryPool queryPool,
    uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset,
    VkDeviceSize stride, VkQueryResultFlags flags) {
    mImpl->vkCmdCopyQueryPoolResults(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, queryPool, firstQuery, queryCount, dstBuffer,
                                     dstOffset, stride, flags);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdPushConstants(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                           VkShaderStageFlags stageFlags, uint32_t offset,
                                           uint32_t size, const void* pValues) {
    mImpl->vkCmdPushConstants(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              layout, stageFlags, offset, size, pValues);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdBeginRenderPass(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             const VkRenderPassBeginInfo* pRenderPassBegin,
                                             VkSubpassContents contents) {
    mImpl->vkCmdBeginRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                pRenderPassBegin, contents);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdNextSubpass(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         VkSubpassContents contents) {
    mImpl->vkCmdNextSubpass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            contents);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdEndRenderPass(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer) {
    mImpl->vkCmdEndRenderPass(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer);
}
#endif
#ifdef VK_VERSION_1_0
void VkDecoderSnapshot::vkCmdExecuteCommands(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             uint32_t commandBufferCount,
                                             const VkCommandBuffer* pCommandBuffers) {
    mImpl->vkCmdExecuteCommands(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                commandBufferCount, pCommandBuffers);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkEnumerateInstanceVersion(android::base::BumpPool* pool,
                                                   VkSnapshotApiCallInfo* apiCallInfo,
                                                   const uint8_t* apiCallPacket,
                                                   size_t apiCallPacketSize, VkResult input_result,
                                                   uint32_t* pApiVersion) {
    mImpl->vkEnumerateInstanceVersion(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      input_result, pApiVersion);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkBindBufferMemory2(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            uint32_t bindInfoCount,
                                            const VkBindBufferMemoryInfo* pBindInfos) {
    mImpl->vkBindBufferMemory2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, bindInfoCount, pBindInfos);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkBindImageMemory2(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           uint32_t bindInfoCount,
                                           const VkBindImageMemoryInfo* pBindInfos) {
    mImpl->vkBindImageMemory2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              device, bindInfoCount, pBindInfos);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetDeviceGroupPeerMemoryFeatures(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
    mImpl->vkGetDeviceGroupPeerMemoryFeatures(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              device, heapIndex, localDeviceIndex,
                                              remoteDeviceIndex, pPeerMemoryFeatures);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkCmdSetDeviceMask(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    mImpl->vkCmdSetDeviceMask(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              deviceMask);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkCmdDispatchBase(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, uint32_t baseGroupX,
                                          uint32_t baseGroupY, uint32_t baseGroupZ,
                                          uint32_t groupCountX, uint32_t groupCountY,
                                          uint32_t groupCountZ) {
    mImpl->vkCmdDispatchBase(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY,
                             groupCountZ);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkEnumeratePhysicalDeviceGroups(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
    mImpl->vkEnumeratePhysicalDeviceGroups(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, instance, pPhysicalDeviceGroupCount,
                                           pPhysicalDeviceGroupProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetImageMemoryRequirements2(android::base::BumpPool* pool,
                                                      VkSnapshotApiCallInfo* apiCallInfo,
                                                      const uint8_t* apiCallPacket,
                                                      size_t apiCallPacketSize, VkDevice device,
                                                      const VkImageMemoryRequirementsInfo2* pInfo,
                                                      VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetImageMemoryRequirements2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetBufferMemoryRequirements2(android::base::BumpPool* pool,
                                                       VkSnapshotApiCallInfo* apiCallInfo,
                                                       const uint8_t* apiCallPacket,
                                                       size_t apiCallPacketSize, VkDevice device,
                                                       const VkBufferMemoryRequirementsInfo2* pInfo,
                                                       VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetBufferMemoryRequirements2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetImageSparseMemoryRequirements2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    mImpl->vkGetImageSparseMemoryRequirements2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               device, pInfo, pSparseMemoryRequirementCount,
                                               pSparseMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures2(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize,
                                                     VkPhysicalDevice physicalDevice,
                                                     VkPhysicalDeviceFeatures2* pFeatures) {
    mImpl->vkGetPhysicalDeviceFeatures2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        physicalDevice, pFeatures);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceProperties2(android::base::BumpPool* pool,
                                                       VkSnapshotApiCallInfo* apiCallInfo,
                                                       const uint8_t* apiCallPacket,
                                                       size_t apiCallPacketSize,
                                                       VkPhysicalDevice physicalDevice,
                                                       VkPhysicalDeviceProperties2* pProperties) {
    mImpl->vkGetPhysicalDeviceProperties2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          physicalDevice, pProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceFormatProperties2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format,
    VkFormatProperties2* pFormatProperties) {
    mImpl->vkGetPhysicalDeviceFormatProperties2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                physicalDevice, format, pFormatProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceImageFormatProperties2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties) {
    mImpl->vkGetPhysicalDeviceImageFormatProperties2(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, physicalDevice,
        pImageFormatInfo, pImageFormatProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceQueueFamilyProperties2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
    mImpl->vkGetPhysicalDeviceQueueFamilyProperties2(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice,
        pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceMemoryProperties2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    mImpl->vkGetPhysicalDeviceMemoryProperties2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                physicalDevice, pMemoryProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceSparseImageFormatProperties2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties) {
    mImpl->vkGetPhysicalDeviceSparseImageFormatProperties2(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pFormatInfo,
        pPropertyCount, pProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkTrimCommandPool(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, VkCommandPool commandPool,
                                          VkCommandPoolTrimFlags flags) {
    mImpl->vkTrimCommandPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                             commandPool, flags);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetDeviceQueue2(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
                                          VkQueue* pQueue) {
    mImpl->vkGetDeviceQueue2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                             pQueueInfo, pQueue);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkCreateSamplerYcbcrConversion(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion) {
    mImpl->vkCreateSamplerYcbcrConversion(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          input_result, device, pCreateInfo, pAllocator,
                                          pYcbcrConversion);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkDestroySamplerYcbcrConversion(android::base::BumpPool* pool,
                                                        VkSnapshotApiCallInfo* apiCallInfo,
                                                        const uint8_t* apiCallPacket,
                                                        size_t apiCallPacketSize, VkDevice device,
                                                        VkSamplerYcbcrConversion ycbcrConversion,
                                                        const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroySamplerYcbcrConversion(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           device, ycbcrConversion, pAllocator);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkCreateDescriptorUpdateTemplate(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    mImpl->vkCreateDescriptorUpdateTemplate(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            input_result, device, pCreateInfo, pAllocator,
                                            pDescriptorUpdateTemplate);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkDestroyDescriptorUpdateTemplate(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDescriptorUpdateTemplate(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             device, descriptorUpdateTemplate, pAllocator);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplate(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    mImpl->vkUpdateDescriptorSetWithTemplate(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             device, descriptorSet, descriptorUpdateTemplate,
                                             pData);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceExternalBufferProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties) {
    mImpl->vkGetPhysicalDeviceExternalBufferProperties(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalBufferInfo,
        pExternalBufferProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceExternalFenceProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties) {
    mImpl->vkGetPhysicalDeviceExternalFenceProperties(pool, apiCallInfo, apiCallPacket,
                                                      apiCallPacketSize, physicalDevice,
                                                      pExternalFenceInfo, pExternalFenceProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetPhysicalDeviceExternalSemaphoreProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    mImpl->vkGetPhysicalDeviceExternalSemaphoreProperties(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalSemaphoreInfo,
        pExternalSemaphoreProperties);
}
#endif
#ifdef VK_VERSION_1_1
void VkDecoderSnapshot::vkGetDescriptorSetLayoutSupport(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    mImpl->vkGetDescriptorSetLayoutSupport(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           device, pCreateInfo, pSupport);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkCmdDrawIndirectCount(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
    VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    mImpl->vkCmdDrawIndirectCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, buffer, offset, countBuffer, countBufferOffset,
                                  maxDrawCount, stride);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkCmdDrawIndexedIndirectCount(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
    VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    mImpl->vkCmdDrawIndexedIndirectCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer, buffer, offset, countBuffer,
                                         countBufferOffset, maxDrawCount, stride);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkCreateRenderPass2(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkRenderPassCreateInfo2* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkRenderPass* pRenderPass) {
    mImpl->vkCreateRenderPass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, pCreateInfo, pAllocator, pRenderPass);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkCmdBeginRenderPass2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
    mImpl->vkCmdBeginRenderPass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 pRenderPassBegin, pSubpassBeginInfo);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkCmdNextSubpass2(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer,
                                          const VkSubpassBeginInfo* pSubpassBeginInfo,
                                          const VkSubpassEndInfo* pSubpassEndInfo) {
    mImpl->vkCmdNextSubpass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             pSubpassBeginInfo, pSubpassEndInfo);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkCmdEndRenderPass2(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            const VkSubpassEndInfo* pSubpassEndInfo) {
    mImpl->vkCmdEndRenderPass2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pSubpassEndInfo);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkResetQueryPool(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkQueryPool queryPool,
                                         uint32_t firstQuery, uint32_t queryCount) {
    mImpl->vkResetQueryPool(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, queryPool,
                            firstQuery, queryCount);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkGetSemaphoreCounterValue(android::base::BumpPool* pool,
                                                   VkSnapshotApiCallInfo* apiCallInfo,
                                                   const uint8_t* apiCallPacket,
                                                   size_t apiCallPacketSize, VkResult input_result,
                                                   VkDevice device, VkSemaphore semaphore,
                                                   uint64_t* pValue) {
    mImpl->vkGetSemaphoreCounterValue(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      input_result, device, semaphore, pValue);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkWaitSemaphores(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {
    mImpl->vkWaitSemaphores(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            device, pWaitInfo, timeout);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkSignalSemaphore(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkDevice device,
                                          const VkSemaphoreSignalInfo* pSignalInfo) {
    mImpl->vkSignalSemaphore(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             device, pSignalInfo);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkGetBufferDeviceAddress(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize,
                                                 VkDeviceAddress input_result, VkDevice device,
                                                 const VkBufferDeviceAddressInfo* pInfo) {
    mImpl->vkGetBufferDeviceAddress(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    input_result, device, pInfo);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkGetBufferOpaqueCaptureAddress(android::base::BumpPool* pool,
                                                        VkSnapshotApiCallInfo* apiCallInfo,
                                                        const uint8_t* apiCallPacket,
                                                        size_t apiCallPacketSize,
                                                        uint64_t input_result, VkDevice device,
                                                        const VkBufferDeviceAddressInfo* pInfo) {
    mImpl->vkGetBufferOpaqueCaptureAddress(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           input_result, device, pInfo);
}
#endif
#ifdef VK_VERSION_1_2
void VkDecoderSnapshot::vkGetDeviceMemoryOpaqueCaptureAddress(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, uint64_t input_result, VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    mImpl->vkGetDeviceMemoryOpaqueCaptureAddress(pool, apiCallInfo, apiCallPacket,
                                                 apiCallPacketSize, input_result, device, pInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkGetPhysicalDeviceToolProperties(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
    mImpl->vkGetPhysicalDeviceToolProperties(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, physicalDevice, pToolCount,
                                             pToolProperties);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCreatePrivateDataSlot(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkPrivateDataSlot* pPrivateDataSlot) {
    mImpl->vkCreatePrivateDataSlot(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   input_result, device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkDestroyPrivateDataSlot(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize, VkDevice device,
                                                 VkPrivateDataSlot privateDataSlot,
                                                 const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyPrivateDataSlot(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                    privateDataSlot, pAllocator);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkSetPrivateData(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkResult input_result, VkDevice device,
                                         VkObjectType objectType, uint64_t objectHandle,
                                         VkPrivateDataSlot privateDataSlot, uint64_t data) {
    mImpl->vkSetPrivateData(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                            device, objectType, objectHandle, privateDataSlot, data);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkGetPrivateData(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkDevice device, VkObjectType objectType,
                                         uint64_t objectHandle, VkPrivateDataSlot privateDataSlot,
                                         uint64_t* pData) {
    mImpl->vkGetPrivateData(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, objectType,
                            objectHandle, privateDataSlot, pData);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetEvent2(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkCommandBuffer commandBuffer, VkEvent event,
                                       const VkDependencyInfo* pDependencyInfo) {
    mImpl->vkCmdSetEvent2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, event,
                          pDependencyInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdResetEvent2(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, VkEvent event,
                                         VkPipelineStageFlags2 stageMask) {
    mImpl->vkCmdResetEvent2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            event, stageMask);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdWaitEvents2(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, uint32_t eventCount,
                                         const VkEvent* pEvents,
                                         const VkDependencyInfo* pDependencyInfos) {
    mImpl->vkCmdWaitEvents2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            eventCount, pEvents, pDependencyInfos);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdPipelineBarrier2(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer,
                                              const VkDependencyInfo* pDependencyInfo) {
    mImpl->vkCmdPipelineBarrier2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 pDependencyInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdWriteTimestamp2(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             VkPipelineStageFlags2 stage, VkQueryPool queryPool,
                                             uint32_t query) {
    mImpl->vkCmdWriteTimestamp2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                stage, queryPool, query);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkQueueSubmit2(android::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* apiCallInfo,
                                       const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                       VkResult input_result, VkQueue queue, uint32_t submitCount,
                                       const VkSubmitInfo2* pSubmits, VkFence fence) {
    mImpl->vkQueueSubmit2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, queue,
                          submitCount, pSubmits, fence);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdCopyBuffer2(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer,
                                         const VkCopyBufferInfo2* pCopyBufferInfo) {
    mImpl->vkCmdCopyBuffer2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            pCopyBufferInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdCopyImage2(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer,
                                        const VkCopyImageInfo2* pCopyImageInfo) {
    mImpl->vkCmdCopyImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           pCopyImageInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdCopyBufferToImage2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    mImpl->vkCmdCopyBufferToImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, pCopyBufferToImageInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdCopyImageToBuffer2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    mImpl->vkCmdCopyImageToBuffer2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, pCopyImageToBufferInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdBlitImage2(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkCommandBuffer commandBuffer,
                                        const VkBlitImageInfo2* pBlitImageInfo) {
    mImpl->vkCmdBlitImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                           pBlitImageInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdResolveImage2(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           const VkResolveImageInfo2* pResolveImageInfo) {
    mImpl->vkCmdResolveImage2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              pResolveImageInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdBeginRendering(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            const VkRenderingInfo* pRenderingInfo) {
    mImpl->vkCmdBeginRendering(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pRenderingInfo);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdEndRendering(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer) {
    mImpl->vkCmdEndRendering(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetCullMode(android::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* apiCallInfo,
                                         const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                         VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    mImpl->vkCmdSetCullMode(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                            cullMode);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetFrontFace(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    mImpl->vkCmdSetFrontFace(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             frontFace);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetPrimitiveTopology(android::base::BumpPool* pool,
                                                  VkSnapshotApiCallInfo* apiCallInfo,
                                                  const uint8_t* apiCallPacket,
                                                  size_t apiCallPacketSize,
                                                  VkCommandBuffer commandBuffer,
                                                  VkPrimitiveTopology primitiveTopology) {
    mImpl->vkCmdSetPrimitiveTopology(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, primitiveTopology);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetViewportWithCount(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t viewportCount,
    const VkViewport* pViewports) {
    mImpl->vkCmdSetViewportWithCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, viewportCount, pViewports);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetScissorWithCount(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize,
                                                 VkCommandBuffer commandBuffer,
                                                 uint32_t scissorCount, const VkRect2D* pScissors) {
    mImpl->vkCmdSetScissorWithCount(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, scissorCount, pScissors);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdBindVertexBuffers2(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
    mImpl->vkCmdBindVertexBuffers2(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets,
                                   pSizes, pStrides);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetDepthTestEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    mImpl->vkCmdSetDepthTestEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, depthTestEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetDepthWriteEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    mImpl->vkCmdSetDepthWriteEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, depthWriteEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetDepthCompareOp(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    mImpl->vkCmdSetDepthCompareOp(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, depthCompareOp);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetDepthBoundsTestEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    mImpl->vkCmdSetDepthBoundsTestEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer, depthBoundsTestEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetStencilTestEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    mImpl->vkCmdSetStencilTestEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, stencilTestEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetStencilOp(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
    VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    mImpl->vkCmdSetStencilOp(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetRasterizerDiscardEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    mImpl->vkCmdSetRasterizerDiscardEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           commandBuffer, rasterizerDiscardEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetDepthBiasEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    mImpl->vkCmdSetDepthBiasEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, depthBiasEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkCmdSetPrimitiveRestartEnable(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    mImpl->vkCmdSetPrimitiveRestartEnable(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, primitiveRestartEnable);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkGetDeviceBufferMemoryRequirements(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetDeviceBufferMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkGetDeviceImageMemoryRequirements(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetDeviceImageMemoryRequirements(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_VERSION_1_3
void VkDecoderSnapshot::vkGetDeviceImageSparseMemoryRequirements(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    mImpl->vkGetDeviceImageSparseMemoryRequirements(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo,
        pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkCreateSwapchainKHR(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkDevice device,
                                             const VkSwapchainCreateInfoKHR* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator,
                                             VkSwapchainKHR* pSwapchain) {
    mImpl->vkCreateSwapchainKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                device, pCreateInfo, pAllocator, pSwapchain);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkDestroySwapchainKHR(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkDevice device,
                                              VkSwapchainKHR swapchain,
                                              const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroySwapchainKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                 swapchain, pAllocator);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkGetSwapchainImagesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages) {
    mImpl->vkGetSwapchainImagesKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   input_result, device, swapchain, pSwapchainImageCount,
                                   pSwapchainImages);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkAcquireNextImageKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkSwapchainKHR swapchain,
    uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex) {
    mImpl->vkAcquireNextImageKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, swapchain, timeout, semaphore, fence, pImageIndex);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkQueuePresentKHR(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkQueue queue,
                                          const VkPresentInfoKHR* pPresentInfo) {
    mImpl->vkQueuePresentKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             queue, pPresentInfo);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkGetDeviceGroupPresentCapabilitiesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {
    mImpl->vkGetDeviceGroupPresentCapabilitiesKHR(pool, apiCallInfo, apiCallPacket,
                                                  apiCallPacketSize, input_result, device,
                                                  pDeviceGroupPresentCapabilities);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkGetDeviceGroupSurfacePresentModesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes) {
    mImpl->vkGetDeviceGroupSurfacePresentModesKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, surface, pModes);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkGetPhysicalDevicePresentRectanglesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects) {
    mImpl->vkGetPhysicalDevicePresentRectanglesKHR(pool, apiCallInfo, apiCallPacket,
                                                   apiCallPacketSize, input_result, physicalDevice,
                                                   surface, pRectCount, pRects);
}
#endif
#ifdef VK_KHR_swapchain
void VkDecoderSnapshot::vkAcquireNextImage2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex) {
    mImpl->vkAcquireNextImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pAcquireInfo, pImageIndex);
}
#endif
#ifdef VK_KHR_dynamic_rendering
void VkDecoderSnapshot::vkCmdBeginRenderingKHR(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize,
                                               VkCommandBuffer commandBuffer,
                                               const VkRenderingInfo* pRenderingInfo) {
    mImpl->vkCmdBeginRenderingKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, pRenderingInfo);
}
#endif
#ifdef VK_KHR_dynamic_rendering
void VkDecoderSnapshot::vkCmdEndRenderingKHR(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer) {
    mImpl->vkCmdEndRenderingKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceFeatures2KHR(android::base::BumpPool* pool,
                                                        VkSnapshotApiCallInfo* apiCallInfo,
                                                        const uint8_t* apiCallPacket,
                                                        size_t apiCallPacketSize,
                                                        VkPhysicalDevice physicalDevice,
                                                        VkPhysicalDeviceFeatures2* pFeatures) {
    mImpl->vkGetPhysicalDeviceFeatures2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           physicalDevice, pFeatures);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceProperties2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties) {
    mImpl->vkGetPhysicalDeviceProperties2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             physicalDevice, pProperties);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceFormatProperties2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, VkFormat format,
    VkFormatProperties2* pFormatProperties) {
    mImpl->vkGetPhysicalDeviceFormatProperties2KHR(pool, apiCallInfo, apiCallPacket,
                                                   apiCallPacketSize, physicalDevice, format,
                                                   pFormatProperties);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceImageFormatProperties2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties) {
    mImpl->vkGetPhysicalDeviceImageFormatProperties2KHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, physicalDevice,
        pImageFormatInfo, pImageFormatProperties);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
    mImpl->vkGetPhysicalDeviceQueueFamilyProperties2KHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice,
        pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceMemoryProperties2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
    mImpl->vkGetPhysicalDeviceMemoryProperties2KHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pMemoryProperties);
}
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkDecoderSnapshot::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties) {
    mImpl->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pFormatInfo,
        pPropertyCount, pProperties);
}
#endif
#ifdef VK_KHR_maintenance1
void VkDecoderSnapshot::vkTrimCommandPoolKHR(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkDevice device, VkCommandPool commandPool,
                                             VkCommandPoolTrimFlags flags) {
    mImpl->vkTrimCommandPoolKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                commandPool, flags);
}
#endif
#ifdef VK_KHR_external_memory_capabilities
void VkDecoderSnapshot::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties) {
    mImpl->vkGetPhysicalDeviceExternalBufferPropertiesKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalBufferInfo,
        pExternalBufferProperties);
}
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void VkDecoderSnapshot::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
    mImpl->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalSemaphoreInfo,
        pExternalSemaphoreProperties);
}
#endif
#ifdef VK_KHR_external_semaphore_fd
void VkDecoderSnapshot::vkImportSemaphoreFdKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
    mImpl->vkImportSemaphoreFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pImportSemaphoreFdInfo);
}
#endif
#ifdef VK_KHR_external_semaphore_fd
void VkDecoderSnapshot::vkGetSemaphoreFdKHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {
    mImpl->vkGetSemaphoreFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, pGetFdInfo, pFd);
}
#endif
#ifdef VK_KHR_descriptor_update_template
void VkDecoderSnapshot::vkCreateDescriptorUpdateTemplateKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
    mImpl->vkCreateDescriptorUpdateTemplateKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               input_result, device, pCreateInfo, pAllocator,
                                               pDescriptorUpdateTemplate);
}
#endif
#ifdef VK_KHR_descriptor_update_template
void VkDecoderSnapshot::vkDestroyDescriptorUpdateTemplateKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDescriptorUpdateTemplateKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                device, descriptorUpdateTemplate, pAllocator);
}
#endif
#ifdef VK_KHR_descriptor_update_template
void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) {
    mImpl->vkUpdateDescriptorSetWithTemplateKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                device, descriptorSet, descriptorUpdateTemplate,
                                                pData);
}
#endif
#ifdef VK_KHR_create_renderpass2
void VkDecoderSnapshot::vkCreateRenderPass2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass) {
    mImpl->vkCreateRenderPass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pCreateInfo, pAllocator, pRenderPass);
}
#endif
#ifdef VK_KHR_create_renderpass2
void VkDecoderSnapshot::vkCmdBeginRenderPass2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
    mImpl->vkCmdBeginRenderPass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif
#ifdef VK_KHR_create_renderpass2
void VkDecoderSnapshot::vkCmdNextSubpass2KHR(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer,
                                             const VkSubpassBeginInfo* pSubpassBeginInfo,
                                             const VkSubpassEndInfo* pSubpassEndInfo) {
    mImpl->vkCmdNextSubpass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                pSubpassBeginInfo, pSubpassEndInfo);
}
#endif
#ifdef VK_KHR_create_renderpass2
void VkDecoderSnapshot::vkCmdEndRenderPass2KHR(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize,
                                               VkCommandBuffer commandBuffer,
                                               const VkSubpassEndInfo* pSubpassEndInfo) {
    mImpl->vkCmdEndRenderPass2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, pSubpassEndInfo);
}
#endif
#ifdef VK_KHR_external_fence_capabilities
void VkDecoderSnapshot::vkGetPhysicalDeviceExternalFencePropertiesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties) {
    mImpl->vkGetPhysicalDeviceExternalFencePropertiesKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, physicalDevice, pExternalFenceInfo,
        pExternalFenceProperties);
}
#endif
#ifdef VK_KHR_external_fence_fd
void VkDecoderSnapshot::vkImportFenceFdKHR(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkResult input_result, VkDevice device,
                                           const VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
    mImpl->vkImportFenceFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                              device, pImportFenceFdInfo);
}
#endif
#ifdef VK_KHR_external_fence_fd
void VkDecoderSnapshot::vkGetFenceFdKHR(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkDevice device,
                                        const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {
    mImpl->vkGetFenceFdKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                           device, pGetFdInfo, pFd);
}
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkDecoderSnapshot::vkGetImageMemoryRequirements2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetImageMemoryRequirements2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkDecoderSnapshot::vkGetBufferMemoryRequirements2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetBufferMemoryRequirements2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkDecoderSnapshot::vkGetImageSparseMemoryRequirements2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    mImpl->vkGetImageSparseMemoryRequirements2KHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo,
        pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
void VkDecoderSnapshot::vkCreateSamplerYcbcrConversionKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion) {
    mImpl->vkCreateSamplerYcbcrConversionKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, device, pCreateInfo, pAllocator,
                                             pYcbcrConversion);
}
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
void VkDecoderSnapshot::vkDestroySamplerYcbcrConversionKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroySamplerYcbcrConversionKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              device, ycbcrConversion, pAllocator);
}
#endif
#ifdef VK_KHR_bind_memory2
void VkDecoderSnapshot::vkBindBufferMemory2KHR(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize, VkResult input_result,
                                               VkDevice device, uint32_t bindInfoCount,
                                               const VkBindBufferMemoryInfo* pBindInfos) {
    mImpl->vkBindBufferMemory2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, bindInfoCount, pBindInfos);
}
#endif
#ifdef VK_KHR_bind_memory2
void VkDecoderSnapshot::vkBindImageMemory2KHR(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkResult input_result,
                                              VkDevice device, uint32_t bindInfoCount,
                                              const VkBindImageMemoryInfo* pBindInfos) {
    mImpl->vkBindImageMemory2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, bindInfoCount, pBindInfos);
}
#endif
#ifdef VK_KHR_maintenance3
void VkDecoderSnapshot::vkGetDescriptorSetLayoutSupportKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport) {
    mImpl->vkGetDescriptorSetLayoutSupportKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              device, pCreateInfo, pSupport);
}
#endif
#ifdef VK_KHR_buffer_device_address
void VkDecoderSnapshot::vkGetBufferDeviceAddressKHR(android::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* apiCallInfo,
                                                    const uint8_t* apiCallPacket,
                                                    size_t apiCallPacketSize,
                                                    VkDeviceAddress input_result, VkDevice device,
                                                    const VkBufferDeviceAddressInfo* pInfo) {
    mImpl->vkGetBufferDeviceAddressKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       input_result, device, pInfo);
}
#endif
#ifdef VK_KHR_buffer_device_address
void VkDecoderSnapshot::vkGetBufferOpaqueCaptureAddressKHR(android::base::BumpPool* pool,
                                                           VkSnapshotApiCallInfo* apiCallInfo,
                                                           const uint8_t* apiCallPacket,
                                                           size_t apiCallPacketSize,
                                                           uint64_t input_result, VkDevice device,
                                                           const VkBufferDeviceAddressInfo* pInfo) {
    mImpl->vkGetBufferOpaqueCaptureAddressKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              input_result, device, pInfo);
}
#endif
#ifdef VK_KHR_buffer_device_address
void VkDecoderSnapshot::vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, uint64_t input_result, VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
    mImpl->vkGetDeviceMemoryOpaqueCaptureAddressKHR(pool, apiCallInfo, apiCallPacket,
                                                    apiCallPacketSize, input_result, device, pInfo);
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
void VkDecoderSnapshot::vkGetPipelineExecutablePropertiesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties) {
    mImpl->vkGetPipelineExecutablePropertiesKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, device, pPipelineInfo,
                                                pExecutableCount, pProperties);
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
void VkDecoderSnapshot::vkGetPipelineExecutableStatisticsKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics) {
    mImpl->vkGetPipelineExecutableStatisticsKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, device, pExecutableInfo,
                                                pStatisticCount, pStatistics);
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
void VkDecoderSnapshot::vkGetPipelineExecutableInternalRepresentationsKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
    mImpl->vkGetPipelineExecutableInternalRepresentationsKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, pExecutableInfo,
        pInternalRepresentationCount, pInternalRepresentations);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkCmdSetEvent2KHR(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkCommandBuffer commandBuffer, VkEvent event,
                                          const VkDependencyInfo* pDependencyInfo) {
    mImpl->vkCmdSetEvent2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             event, pDependencyInfo);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkCmdResetEvent2KHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, VkEvent event,
                                            VkPipelineStageFlags2 stageMask) {
    mImpl->vkCmdResetEvent2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               event, stageMask);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkCmdWaitEvents2KHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer, uint32_t eventCount,
                                            const VkEvent* pEvents,
                                            const VkDependencyInfo* pDependencyInfos) {
    mImpl->vkCmdWaitEvents2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               eventCount, pEvents, pDependencyInfos);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkCmdPipelineBarrier2KHR(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize,
                                                 VkCommandBuffer commandBuffer,
                                                 const VkDependencyInfo* pDependencyInfo) {
    mImpl->vkCmdPipelineBarrier2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, pDependencyInfo);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkCmdWriteTimestamp2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
    VkQueryPool queryPool, uint32_t query) {
    mImpl->vkCmdWriteTimestamp2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, stage, queryPool, query);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkQueueSubmit2KHR(android::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* apiCallInfo,
                                          const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                          VkResult input_result, VkQueue queue,
                                          uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                                          VkFence fence) {
    mImpl->vkQueueSubmit2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                             queue, submitCount, pSubmits, fence);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkCmdWriteBufferMarker2AMD(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
    VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    mImpl->vkCmdWriteBufferMarker2AMD(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, stage, dstBuffer, dstOffset, marker);
}
#endif
#ifdef VK_KHR_synchronization2
void VkDecoderSnapshot::vkGetQueueCheckpointData2NV(android::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* apiCallInfo,
                                                    const uint8_t* apiCallPacket,
                                                    size_t apiCallPacketSize, VkQueue queue,
                                                    uint32_t* pCheckpointDataCount,
                                                    VkCheckpointData2NV* pCheckpointData) {
    mImpl->vkGetQueueCheckpointData2NV(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                       pCheckpointDataCount, pCheckpointData);
}
#endif
#ifdef VK_KHR_copy_commands2
void VkDecoderSnapshot::vkCmdCopyBuffer2KHR(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            const VkCopyBufferInfo2* pCopyBufferInfo) {
    mImpl->vkCmdCopyBuffer2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               pCopyBufferInfo);
}
#endif
#ifdef VK_KHR_copy_commands2
void VkDecoderSnapshot::vkCmdCopyImage2KHR(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           const VkCopyImageInfo2* pCopyImageInfo) {
    mImpl->vkCmdCopyImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              pCopyImageInfo);
}
#endif
#ifdef VK_KHR_copy_commands2
void VkDecoderSnapshot::vkCmdCopyBufferToImage2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    mImpl->vkCmdCopyBufferToImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, pCopyBufferToImageInfo);
}
#endif
#ifdef VK_KHR_copy_commands2
void VkDecoderSnapshot::vkCmdCopyImageToBuffer2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    mImpl->vkCmdCopyImageToBuffer2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, pCopyImageToBufferInfo);
}
#endif
#ifdef VK_KHR_copy_commands2
void VkDecoderSnapshot::vkCmdBlitImage2KHR(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer,
                                           const VkBlitImageInfo2* pBlitImageInfo) {
    mImpl->vkCmdBlitImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              pBlitImageInfo);
}
#endif
#ifdef VK_KHR_copy_commands2
void VkDecoderSnapshot::vkCmdResolveImage2KHR(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize,
                                              VkCommandBuffer commandBuffer,
                                              const VkResolveImageInfo2* pResolveImageInfo) {
    mImpl->vkCmdResolveImage2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                 pResolveImageInfo);
}
#endif
#ifdef VK_KHR_maintenance4
void VkDecoderSnapshot::vkGetDeviceBufferMemoryRequirementsKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetDeviceBufferMemoryRequirementsKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_KHR_maintenance4
void VkDecoderSnapshot::vkGetDeviceImageMemoryRequirementsKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    VkMemoryRequirements2* pMemoryRequirements) {
    mImpl->vkGetDeviceImageMemoryRequirementsKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo, pMemoryRequirements);
}
#endif
#ifdef VK_KHR_maintenance4
void VkDecoderSnapshot::vkGetDeviceImageSparseMemoryRequirementsKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
    mImpl->vkGetDeviceImageSparseMemoryRequirementsKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, pInfo,
        pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif
#ifdef VK_KHR_maintenance5
void VkDecoderSnapshot::vkCmdBindIndexBuffer2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
    VkDeviceSize size, VkIndexType indexType) {
    mImpl->vkCmdBindIndexBuffer2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                    commandBuffer, buffer, offset, size, indexType);
}
#endif
#ifdef VK_KHR_maintenance5
void VkDecoderSnapshot::vkGetRenderingAreaGranularityKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
    VkExtent2D* pGranularity) {
    mImpl->vkGetRenderingAreaGranularityKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            device, pRenderingAreaInfo, pGranularity);
}
#endif
#ifdef VK_KHR_maintenance5
void VkDecoderSnapshot::vkGetDeviceImageSubresourceLayoutKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo,
    VkSubresourceLayout2KHR* pLayout) {
    mImpl->vkGetDeviceImageSubresourceLayoutKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                device, pInfo, pLayout);
}
#endif
#ifdef VK_KHR_maintenance5
void VkDecoderSnapshot::vkGetImageSubresourceLayout2KHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkImage image,
    const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout) {
    mImpl->vkGetImageSubresourceLayout2KHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           device, image, pSubresource, pLayout);
}
#endif
#ifdef VK_KHR_line_rasterization
void VkDecoderSnapshot::vkCmdSetLineStippleKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
    uint16_t lineStipplePattern) {
    mImpl->vkCmdSetLineStippleKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif
#ifdef VK_ANDROID_native_buffer
void VkDecoderSnapshot::vkGetSwapchainGrallocUsageANDROID(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkFormat format,
    VkImageUsageFlags imageUsage, int* grallocUsage) {
    mImpl->vkGetSwapchainGrallocUsageANDROID(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, device, format, imageUsage,
                                             grallocUsage);
}
#endif
#ifdef VK_ANDROID_native_buffer
void VkDecoderSnapshot::vkAcquireImageANDROID(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkResult input_result,
                                              VkDevice device, VkImage image, int nativeFenceFd,
                                              VkSemaphore semaphore, VkFence fence) {
    mImpl->vkAcquireImageANDROID(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, image, nativeFenceFd, semaphore, fence);
}
#endif
#ifdef VK_ANDROID_native_buffer
void VkDecoderSnapshot::vkQueueSignalReleaseImageANDROID(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkQueue queue, uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores, VkImage image, int* pNativeFenceFd) {
    mImpl->vkQueueSignalReleaseImageANDROID(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            input_result, queue, waitSemaphoreCount,
                                            pWaitSemaphores, image, pNativeFenceFd);
}
#endif
#ifdef VK_ANDROID_native_buffer
void VkDecoderSnapshot::vkGetSwapchainGrallocUsage2ANDROID(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkFormat format,
    VkImageUsageFlags imageUsage, VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
    uint64_t* grallocConsumerUsage, uint64_t* grallocProducerUsage) {
    mImpl->vkGetSwapchainGrallocUsage2ANDROID(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, format,
        imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
}
#endif
#ifdef VK_EXT_debug_report
void VkDecoderSnapshot::vkCreateDebugReportCallbackEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback) {
    mImpl->vkCreateDebugReportCallbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          input_result, instance, pCreateInfo, pAllocator,
                                          pCallback);
}
#endif
#ifdef VK_EXT_debug_report
void VkDecoderSnapshot::vkDestroyDebugReportCallbackEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkInstance instance, VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDebugReportCallbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           instance, callback, pAllocator);
}
#endif
#ifdef VK_EXT_debug_report
void VkDecoderSnapshot::vkDebugReportMessageEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkInstance instance, VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode,
    const char* pLayerPrefix, const char* pMessage) {
    mImpl->vkDebugReportMessageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, instance,
                                   flags, objectType, object, location, messageCode, pLayerPrefix,
                                   pMessage);
}
#endif
#ifdef VK_EXT_transform_feedback
void VkDecoderSnapshot::vkCmdBindTransformFeedbackBuffersEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes) {
    mImpl->vkCmdBindTransformFeedbackBuffersEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                commandBuffer, firstBinding, bindingCount, pBuffers,
                                                pOffsets, pSizes);
}
#endif
#ifdef VK_EXT_transform_feedback
void VkDecoderSnapshot::vkCmdBeginTransformFeedbackEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
    uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
    const VkDeviceSize* pCounterBufferOffsets) {
    mImpl->vkCmdBeginTransformFeedbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          commandBuffer, firstCounterBuffer, counterBufferCount,
                                          pCounterBuffers, pCounterBufferOffsets);
}
#endif
#ifdef VK_EXT_transform_feedback
void VkDecoderSnapshot::vkCmdEndTransformFeedbackEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
    uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
    const VkDeviceSize* pCounterBufferOffsets) {
    mImpl->vkCmdEndTransformFeedbackEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        commandBuffer, firstCounterBuffer, counterBufferCount,
                                        pCounterBuffers, pCounterBufferOffsets);
}
#endif
#ifdef VK_EXT_transform_feedback
void VkDecoderSnapshot::vkCmdBeginQueryIndexedEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
    VkQueryControlFlags flags, uint32_t index) {
    mImpl->vkCmdBeginQueryIndexedEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, queryPool, query, flags, index);
}
#endif
#ifdef VK_EXT_transform_feedback
void VkDecoderSnapshot::vkCmdEndQueryIndexedEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
    uint32_t index) {
    mImpl->vkCmdEndQueryIndexedEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                   commandBuffer, queryPool, query, index);
}
#endif
#ifdef VK_EXT_transform_feedback
void VkDecoderSnapshot::vkCmdDrawIndirectByteCountEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t instanceCount,
    uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset,
    uint32_t counterOffset, uint32_t vertexStride) {
    mImpl->vkCmdDrawIndirectByteCountEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer, instanceCount, firstInstance, counterBuffer,
                                         counterBufferOffset, counterOffset, vertexStride);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkSetDebugUtilsObjectNameEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
    mImpl->vkSetDebugUtilsObjectNameEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        input_result, device, pNameInfo);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkSetDebugUtilsObjectTagEXT(android::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* apiCallInfo,
                                                    const uint8_t* apiCallPacket,
                                                    size_t apiCallPacketSize, VkResult input_result,
                                                    VkDevice device,
                                                    const VkDebugUtilsObjectTagInfoEXT* pTagInfo) {
    mImpl->vkSetDebugUtilsObjectTagEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       input_result, device, pTagInfo);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkQueueBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                                       VkSnapshotApiCallInfo* apiCallInfo,
                                                       const uint8_t* apiCallPacket,
                                                       size_t apiCallPacketSize, VkQueue queue,
                                                       const VkDebugUtilsLabelEXT* pLabelInfo) {
    mImpl->vkQueueBeginDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          queue, pLabelInfo);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkQueueEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize, VkQueue queue) {
    mImpl->vkQueueEndDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkQueueInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                                        VkSnapshotApiCallInfo* apiCallInfo,
                                                        const uint8_t* apiCallPacket,
                                                        size_t apiCallPacketSize, VkQueue queue,
                                                        const VkDebugUtilsLabelEXT* pLabelInfo) {
    mImpl->vkQueueInsertDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           queue, pLabelInfo);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkCmdBeginDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize,
                                                     VkCommandBuffer commandBuffer,
                                                     const VkDebugUtilsLabelEXT* pLabelInfo) {
    mImpl->vkCmdBeginDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        commandBuffer, pLabelInfo);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkCmdEndDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                                   VkSnapshotApiCallInfo* apiCallInfo,
                                                   const uint8_t* apiCallPacket,
                                                   size_t apiCallPacketSize,
                                                   VkCommandBuffer commandBuffer) {
    mImpl->vkCmdEndDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkCmdInsertDebugUtilsLabelEXT(android::base::BumpPool* pool,
                                                      VkSnapshotApiCallInfo* apiCallInfo,
                                                      const uint8_t* apiCallPacket,
                                                      size_t apiCallPacketSize,
                                                      VkCommandBuffer commandBuffer,
                                                      const VkDebugUtilsLabelEXT* pLabelInfo) {
    mImpl->vkCmdInsertDebugUtilsLabelEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer, pLabelInfo);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkCreateDebugUtilsMessengerEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger) {
    mImpl->vkCreateDebugUtilsMessengerEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          input_result, instance, pCreateInfo, pAllocator,
                                          pMessenger);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkDestroyDebugUtilsMessengerEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkInstance instance, VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyDebugUtilsMessengerEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           instance, messenger, pAllocator);
}
#endif
#ifdef VK_EXT_debug_utils
void VkDecoderSnapshot::vkSubmitDebugUtilsMessageEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
    mImpl->vkSubmitDebugUtilsMessageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        instance, messageSeverity, messageTypes, pCallbackData);
}
#endif
#ifdef VK_EXT_image_drm_format_modifier
void VkDecoderSnapshot::vkGetImageDrmFormatModifierPropertiesEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkImage image,
    VkImageDrmFormatModifierPropertiesEXT* pProperties) {
    mImpl->vkGetImageDrmFormatModifierPropertiesEXT(pool, apiCallInfo, apiCallPacket,
                                                    apiCallPacketSize, input_result, device, image,
                                                    pProperties);
}
#endif
#ifdef VK_EXT_external_memory_host
void VkDecoderSnapshot::vkGetMemoryHostPointerPropertiesEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
    mImpl->vkGetMemoryHostPointerPropertiesEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               input_result, device, handleType, pHostPointer,
                                               pMemoryHostPointerProperties);
}
#endif
#ifdef VK_EXT_tooling_info
void VkDecoderSnapshot::vkGetPhysicalDeviceToolPropertiesEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkPhysicalDevice physicalDevice,
    uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
    mImpl->vkGetPhysicalDeviceToolPropertiesEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, physicalDevice, pToolCount,
                                                pToolProperties);
}
#endif
#ifdef VK_EXT_line_rasterization
void VkDecoderSnapshot::vkCmdSetLineStippleEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
    uint16_t lineStipplePattern) {
    mImpl->vkCmdSetLineStippleEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                  commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetCullModeEXT(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkCommandBuffer commandBuffer,
                                            VkCullModeFlags cullMode) {
    mImpl->vkCmdSetCullModeEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                               cullMode);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetFrontFaceEXT(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    mImpl->vkCmdSetFrontFaceEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                frontFace);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetPrimitiveTopologyEXT(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize,
                                                     VkCommandBuffer commandBuffer,
                                                     VkPrimitiveTopology primitiveTopology) {
    mImpl->vkCmdSetPrimitiveTopologyEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        commandBuffer, primitiveTopology);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetViewportWithCountEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t viewportCount,
    const VkViewport* pViewports) {
    mImpl->vkCmdSetViewportWithCountEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        commandBuffer, viewportCount, pViewports);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetScissorWithCountEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t scissorCount,
    const VkRect2D* pScissors) {
    mImpl->vkCmdSetScissorWithCountEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       commandBuffer, scissorCount, pScissors);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdBindVertexBuffers2EXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t firstBinding,
    uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
    mImpl->vkCmdBindVertexBuffers2EXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets,
                                      pSizes, pStrides);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetDepthTestEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    mImpl->vkCmdSetDepthTestEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, depthTestEnable);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetDepthWriteEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    mImpl->vkCmdSetDepthWriteEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       commandBuffer, depthWriteEnable);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetDepthCompareOpEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    mImpl->vkCmdSetDepthCompareOpEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, depthCompareOp);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetDepthBoundsTestEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    mImpl->vkCmdSetDepthBoundsTestEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            commandBuffer, depthBoundsTestEnable);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetStencilTestEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    mImpl->vkCmdSetStencilTestEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                        commandBuffer, stencilTestEnable);
}
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkDecoderSnapshot::vkCmdSetStencilOpEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
    VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    mImpl->vkCmdSetStencilOpEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                                faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif
#ifdef VK_EXT_host_image_copy
void VkDecoderSnapshot::vkCopyMemoryToImageEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo) {
    mImpl->vkCopyMemoryToImageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pCopyMemoryToImageInfo);
}
#endif
#ifdef VK_EXT_host_image_copy
void VkDecoderSnapshot::vkCopyImageToMemoryEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo) {
    mImpl->vkCopyImageToMemoryEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, pCopyImageToMemoryInfo);
}
#endif
#ifdef VK_EXT_host_image_copy
void VkDecoderSnapshot::vkCopyImageToImageEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo) {
    mImpl->vkCopyImageToImageEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                 device, pCopyImageToImageInfo);
}
#endif
#ifdef VK_EXT_host_image_copy
void VkDecoderSnapshot::vkTransitionImageLayoutEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, uint32_t transitionCount,
    const VkHostImageLayoutTransitionInfoEXT* pTransitions) {
    mImpl->vkTransitionImageLayoutEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      input_result, device, transitionCount, pTransitions);
}
#endif
#ifdef VK_EXT_host_image_copy
void VkDecoderSnapshot::vkGetImageSubresourceLayout2EXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkImage image,
    const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout) {
    mImpl->vkGetImageSubresourceLayout2EXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           device, image, pSubresource, pLayout);
}
#endif
#ifdef VK_EXT_swapchain_maintenance1
void VkDecoderSnapshot::vkReleaseSwapchainImagesEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo) {
    mImpl->vkReleaseSwapchainImagesEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       input_result, device, pReleaseInfo);
}
#endif
#ifdef VK_EXT_private_data
void VkDecoderSnapshot::vkCreatePrivateDataSlotEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkPrivateDataSlot* pPrivateDataSlot) {
    mImpl->vkCreatePrivateDataSlotEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      input_result, device, pCreateInfo, pAllocator,
                                      pPrivateDataSlot);
}
#endif
#ifdef VK_EXT_private_data
void VkDecoderSnapshot::vkDestroyPrivateDataSlotEXT(android::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* apiCallInfo,
                                                    const uint8_t* apiCallPacket,
                                                    size_t apiCallPacketSize, VkDevice device,
                                                    VkPrivateDataSlot privateDataSlot,
                                                    const VkAllocationCallbacks* pAllocator) {
    mImpl->vkDestroyPrivateDataSlotEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                       privateDataSlot, pAllocator);
}
#endif
#ifdef VK_EXT_private_data
void VkDecoderSnapshot::vkSetPrivateDataEXT(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkResult input_result, VkDevice device,
                                            VkObjectType objectType, uint64_t objectHandle,
                                            VkPrivateDataSlot privateDataSlot, uint64_t data) {
    mImpl->vkSetPrivateDataEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                               device, objectType, objectHandle, privateDataSlot, data);
}
#endif
#ifdef VK_EXT_private_data
void VkDecoderSnapshot::vkGetPrivateDataEXT(android::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* apiCallInfo,
                                            const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                            VkDevice device, VkObjectType objectType,
                                            uint64_t objectHandle,
                                            VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
    mImpl->vkGetPrivateDataEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                               objectType, objectHandle, privateDataSlot, pData);
}
#endif
#ifdef VK_EXT_extended_dynamic_state2
void VkDecoderSnapshot::vkCmdSetPatchControlPointsEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
    mImpl->vkCmdSetPatchControlPointsEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer, patchControlPoints);
}
#endif
#ifdef VK_EXT_extended_dynamic_state2
void VkDecoderSnapshot::vkCmdSetRasterizerDiscardEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    mImpl->vkCmdSetRasterizerDiscardEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                              commandBuffer, rasterizerDiscardEnable);
}
#endif
#ifdef VK_EXT_extended_dynamic_state2
void VkDecoderSnapshot::vkCmdSetDepthBiasEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    mImpl->vkCmdSetDepthBiasEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                      commandBuffer, depthBiasEnable);
}
#endif
#ifdef VK_EXT_extended_dynamic_state2
void VkDecoderSnapshot::vkCmdSetLogicOpEXT(android::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* apiCallInfo,
                                           const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                           VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
    mImpl->vkCmdSetLogicOpEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                              logicOp);
}
#endif
#ifdef VK_EXT_extended_dynamic_state2
void VkDecoderSnapshot::vkCmdSetPrimitiveRestartEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    mImpl->vkCmdSetPrimitiveRestartEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             commandBuffer, primitiveRestartEnable);
}
#endif
#ifdef VK_EXT_color_write_enable
void VkDecoderSnapshot::vkCmdSetColorWriteEnableEXT(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t attachmentCount,
    const VkBool32* pColorWriteEnables) {
    mImpl->vkCmdSetColorWriteEnableEXT(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                       commandBuffer, attachmentCount, pColorWriteEnables);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkMapMemoryIntoAddressSpaceGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkDeviceMemory memory,
    uint64_t* pAddress) {
    mImpl->vkMapMemoryIntoAddressSpaceGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                             input_result, device, memory, pAddress);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
    uint32_t bufferInfoCount, uint32_t bufferViewCount, const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews) {
    mImpl->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, descriptorSet,
        descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
        pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos,
        pBufferInfos, pBufferViews);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkBeginCommandBufferAsyncGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo) {
    mImpl->vkBeginCommandBufferAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           commandBuffer, pBeginInfo);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkEndCommandBufferAsyncGOOGLE(android::base::BumpPool* pool,
                                                      VkSnapshotApiCallInfo* apiCallInfo,
                                                      const uint8_t* apiCallPacket,
                                                      size_t apiCallPacketSize,
                                                      VkCommandBuffer commandBuffer) {
    mImpl->vkEndCommandBufferAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkResetCommandBufferAsyncGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
    mImpl->vkResetCommandBufferAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                           commandBuffer, flags);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkCommandBufferHostSyncGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t needHostSync,
    uint32_t sequenceNumber) {
    mImpl->vkCommandBufferHostSyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         commandBuffer, needHostSync, sequenceNumber);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkCreateImageWithRequirementsGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements) {
    mImpl->vkCreateImageWithRequirementsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                               input_result, device, pCreateInfo, pAllocator,
                                               pImage, pMemoryRequirements);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkCreateBufferWithRequirementsGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements) {
    mImpl->vkCreateBufferWithRequirementsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                                input_result, device, pCreateInfo, pAllocator,
                                                pBuffer, pMemoryRequirements);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkGetMemoryHostAddressInfoGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkDeviceMemory memory,
    uint64_t* pAddress, uint64_t* pSize, uint64_t* pHostmemId) {
    mImpl->vkGetMemoryHostAddressInfoGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            input_result, device, memory, pAddress, pSize,
                                            pHostmemId);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkFreeMemorySyncGOOGLE(android::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* apiCallInfo,
                                               const uint8_t* apiCallPacket,
                                               size_t apiCallPacketSize, VkResult input_result,
                                               VkDevice device, VkDeviceMemory memory,
                                               const VkAllocationCallbacks* pAllocator) {
    mImpl->vkFreeMemorySyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                  device, memory, pAllocator);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueHostSyncGOOGLE(android::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* apiCallInfo,
                                              const uint8_t* apiCallPacket,
                                              size_t apiCallPacketSize, VkQueue queue,
                                              uint32_t needHostSync, uint32_t sequenceNumber) {
    mImpl->vkQueueHostSyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                 needHostSync, sequenceNumber);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueSubmitAsyncGOOGLE(android::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* apiCallInfo,
                                                 const uint8_t* apiCallPacket,
                                                 size_t apiCallPacketSize, VkQueue queue,
                                                 uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                                 VkFence fence) {
    mImpl->vkQueueSubmitAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                    submitCount, pSubmits, fence);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueWaitIdleAsyncGOOGLE(android::base::BumpPool* pool,
                                                   VkSnapshotApiCallInfo* apiCallInfo,
                                                   const uint8_t* apiCallPacket,
                                                   size_t apiCallPacketSize, VkQueue queue) {
    mImpl->vkQueueWaitIdleAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueBindSparseAsyncGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkQueue queue, uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo, VkFence fence) {
    mImpl->vkQueueBindSparseAsyncGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                        bindInfoCount, pBindInfo, fence);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkGetLinearImageLayoutGOOGLE(android::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* apiCallInfo,
                                                     const uint8_t* apiCallPacket,
                                                     size_t apiCallPacketSize, VkDevice device,
                                                     VkFormat format, VkDeviceSize* pOffset,
                                                     VkDeviceSize* pRowPitchAlignment) {
    mImpl->vkGetLinearImageLayoutGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device,
                                        format, pOffset, pRowPitchAlignment);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkGetLinearImageLayout2GOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, const VkImageCreateInfo* pCreateInfo,
    VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment) {
    mImpl->vkGetLinearImageLayout2GOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                         device, pCreateInfo, pOffset, pRowPitchAlignment);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueFlushCommandsGOOGLE(android::base::BumpPool* pool,
                                                   VkSnapshotApiCallInfo* apiCallInfo,
                                                   const uint8_t* apiCallPacket,
                                                   size_t apiCallPacketSize, VkQueue queue,
                                                   VkCommandBuffer commandBuffer,
                                                   VkDeviceSize dataSize, const void* pData) {
    mImpl->vkQueueFlushCommandsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                      commandBuffer, dataSize, pData);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueCommitDescriptorSetUpdatesGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkQueue queue, uint32_t descriptorPoolCount,
    const VkDescriptorPool* pDescriptorPools, uint32_t descriptorSetCount,
    const VkDescriptorSetLayout* pSetLayouts, const uint64_t* pDescriptorSetPoolIds,
    const uint32_t* pDescriptorSetWhichPool, const uint32_t* pDescriptorSetPendingAllocation,
    const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
    const VkWriteDescriptorSet* pPendingDescriptorWrites) {
    mImpl->vkQueueCommitDescriptorSetUpdatesGOOGLE(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue, descriptorPoolCount,
        pDescriptorPools, descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds,
        pDescriptorSetWhichPool, pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices,
        pendingDescriptorWriteCount, pPendingDescriptorWrites);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkCollectDescriptorPoolIdsGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorPool descriptorPool,
    uint32_t* pPoolIdCount, uint64_t* pPoolIds) {
    mImpl->vkCollectDescriptorPoolIdsGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                            device, descriptorPool, pPoolIdCount, pPoolIds);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkQueue queue, uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores, VkImage image) {
    mImpl->vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(pool, apiCallInfo, apiCallPacket,
                                                       apiCallPacketSize, queue, waitSemaphoreCount,
                                                       pWaitSemaphores, image);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueFlushCommandsFromAuxMemoryGOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkQueue queue, VkCommandBuffer commandBuffer,
    VkDeviceMemory deviceMemory, VkDeviceSize dataOffset, VkDeviceSize dataSize) {
    mImpl->vkQueueFlushCommandsFromAuxMemoryGOOGLE(pool, apiCallInfo, apiCallPacket,
                                                   apiCallPacketSize, queue, commandBuffer,
                                                   deviceMemory, dataOffset, dataSize);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkGetBlobGOOGLE(android::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* apiCallInfo,
                                        const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                        VkResult input_result, VkDevice device,
                                        VkDeviceMemory memory) {
    mImpl->vkGetBlobGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                           device, memory);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDevice device, VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate, uint32_t imageInfoCount,
    uint32_t bufferInfoCount, uint32_t bufferViewCount, uint32_t inlineUniformBlockCount,
    const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews,
    const uint8_t* pInlineUniformBlockData) {
    mImpl->vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, device, descriptorSet,
        descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount,
        inlineUniformBlockCount, pImageInfoEntryIndices, pBufferInfoEntryIndices,
        pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews, pInlineUniformBlockData);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkQueueSubmitAsync2GOOGLE(android::base::BumpPool* pool,
                                                  VkSnapshotApiCallInfo* apiCallInfo,
                                                  const uint8_t* apiCallPacket,
                                                  size_t apiCallPacketSize, VkQueue queue,
                                                  uint32_t submitCount,
                                                  const VkSubmitInfo2* pSubmits, VkFence fence) {
    mImpl->vkQueueSubmitAsync2GOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, queue,
                                     submitCount, pSubmits, fence);
}
#endif
#ifdef VK_GOOGLE_gfxstream
void VkDecoderSnapshot::vkGetSemaphoreGOOGLE(android::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* apiCallInfo,
                                             const uint8_t* apiCallPacket, size_t apiCallPacketSize,
                                             VkResult input_result, VkDevice device,
                                             VkSemaphore semaphore, uint64_t syncId) {
    mImpl->vkGetSemaphoreGOOGLE(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result,
                                device, semaphore, syncId);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkDecoderSnapshot::vkCmdTraceRaysKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width,
    uint32_t height, uint32_t depth) {
    mImpl->vkCmdTraceRaysKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer,
                             pRaygenShaderBindingTable, pMissShaderBindingTable,
                             pHitShaderBindingTable, pCallableShaderBindingTable, width, height,
                             depth);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkDecoderSnapshot::vkCreateRayTracingPipelinesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device,
    VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache,
    uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
    mImpl->vkCreateRayTracingPipelinesKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                          input_result, device, deferredOperation, pipelineCache,
                                          createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkDecoderSnapshot::vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkResult input_result, VkDevice device, VkPipeline pipeline,
    uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
    mImpl->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, input_result, device, pipeline,
        firstGroup, groupCount, dataSize, pData);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkDecoderSnapshot::vkCmdTraceRaysIndirectKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer,
    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
    VkDeviceAddress indirectDeviceAddress) {
    mImpl->vkCmdTraceRaysIndirectKHR(pool, apiCallInfo, apiCallPacket, apiCallPacketSize,
                                     commandBuffer, pRaygenShaderBindingTable,
                                     pMissShaderBindingTable, pHitShaderBindingTable,
                                     pCallableShaderBindingTable, indirectDeviceAddress);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkDecoderSnapshot::vkGetRayTracingShaderGroupStackSizeKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkDeviceSize input_result, VkDevice device, VkPipeline pipeline,
    uint32_t group, VkShaderGroupShaderKHR groupShader) {
    mImpl->vkGetRayTracingShaderGroupStackSizeKHR(pool, apiCallInfo, apiCallPacket,
                                                  apiCallPacketSize, input_result, device, pipeline,
                                                  group, groupShader);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkDecoderSnapshot::vkCmdSetRayTracingPipelineStackSizeKHR(
    android::base::BumpPool* pool, VkSnapshotApiCallInfo* apiCallInfo, const uint8_t* apiCallPacket,
    size_t apiCallPacketSize, VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
    mImpl->vkCmdSetRayTracingPipelineStackSizeKHR(
        pool, apiCallInfo, apiCallPacket, apiCallPacketSize, commandBuffer, pipelineStackSize);
}
#endif

}  // namespace vk
}  // namespace gfxstream
